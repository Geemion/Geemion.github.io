<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Windows核心编程读书笔记4（第7、8、9章） | Lyon&#39;s blog</title>
  <meta name="author" content="Lyon">
  
  <meta name="description" content="Walk steps step by step">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Windows核心编程读书笔记4（第7、8、9章）"/>
  <meta property="og:site_name" content="Lyon&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  #<link href="/favicon.ico" rel="icon">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Lyon&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="/js/jquery.min.js"></script>
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?0fe72895c9bcfd0d09da12b5378b1b91";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Lyon&#39;s blog</a></h1>
  <h2><a href="/">I hear and I forget.I see and I remember.I do and I understand.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-10-23T08:49:04.000Z"><a href="/2015/10/23/Read-Notes/Read-Notes-Windows-Via-C-C-4/">2015-10-23</a></time>
      
      
  
    <h1 class="title">Windows核心编程读书笔记4（第7、8、9章）</h1>
  

    </header>
	
<!-- Table of Contents -->

  <div id="toc" class="toc-article">
  <strong class="toc-title">文章目录</strong>
  
  </div>


	
    <div class="entry">
      
        <p>#第7章 线程调度、优先级和关联性</p>
<p>##关于线程调度</p>
<ul>
<li>线程上下文结构存在于线程内核对象中，每隔20ms（GetSystemTimeAdjustment的lpTimeIncrement参数）Windows系统将查看当前存在的所有线程内核对象，只有某些对象被视为可以调度的对象。Windows选择可调度的线程内核对象中的一个，将它加载到CPU的寄存器中，它的值是上次保存在线程的环境中的值。这项操作称为上下文转换。</li>
<li>可利用spy++工具查看线程已被调度次数，通过CREATE_SUSPENGED标志创建一个暂停的线程</li>
<li>大多数线程是不可调度的，挂起次数非0(线程内核对象中有一个值表示线程挂起次数SuspendThread增加挂起次数1 ResumeThread减小1)、等待事件发生</li>
</ul>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回线程前一个暂停数，谨慎使用该函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">SuspendThread</span><span class="params">(  HANDLE hThread   <span class="comment">// handle to thread);</span></span></span></span><br></pre></td></tr></table></figure>
<p>##暂停和恢复进程的运行</p>
<ul>
<li>Windows中只能通过暂停进程中所有线程暂停进程，通过调试方式</li>
<li>调试进程的WaitForDebugEvent返回后，被调试进程的所有线程被挂起，直到调试进程调用ContinueDebugEvent<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挂起进程</span></span><br><span class="line"><span class="function">VOID <span class="title">SuspendProcess</span><span class="params">(DWORD dwProcessID, BOOL fSuspend)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="comment">//Get the list of threads in the system.</span></span><br><span class="line">   HANDLE hSnapshot = CreateToolhelp32Snapshot(</span><br><span class="line">      TH32CS_SNAPTHREAD, dwProcessID);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(hSnapshot != INVALID_HANDLE_VALUE) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//Walk the list of threads.</span></span><br><span class="line">      THREADENTRY32 te = &#123; <span class="keyword">sizeof</span>(te) &#125;;</span><br><span class="line">      BOOL fOk = Thread32First(hSnapshot, &amp;te);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(; fOk; fOk = Thread32Next(hSnapshot, &amp;te)) </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//Is this thread in the desired process?</span></span><br><span class="line">         <span class="keyword">if</span>(te.th32OwnerProcessID == dwProcessID) </span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">//Attempt to convert the thread ID into a handle.</span></span><br><span class="line">            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,</span><br><span class="line">               FALSE, te.th32ThreadID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hThread != <span class="literal">NULL</span>) </span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//Suspend or resume the thread.</span></span><br><span class="line">               <span class="keyword">if</span>(fSuspend)</span><br><span class="line">                  SuspendThread(hThread);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                  ResumeThread(hThread);</span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(hThread);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      CloseHandle(hSnapshot);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##睡眠方式</p>
<ul>
<li>VOID Sleep(DWORD dwMilliseconds)，可使线程暂停自己运行 放弃该线程自己剩余时间片</li>
<li>Windows不是一个实时操作系统，所以系统将在大约的指定毫秒数内使线程不可调度。取决于线程调度时间片大小（一般是15毫秒左右）以及其他线程的运行情况。</li>
<li>Sleep(0)这将告诉系统，调用线程将释放剩余的时间片，并迫使系统调度另一个线程。但是，系统可以对刚刚调用Sleep的线程重新调度。如果不存在多个拥有相同优先级的可调度线程，就会出现这种情况。</li>
<li>Sleep(0)和SwitchToThread的区别在于：如果存在另一个更低优先级的线程，前者不会将CPU让出，而后者会。即如果存在多个线程，SwitchThread总是让出CPU。<br>##超线程技术</li>
<li>超线程技术即有多个逻辑cpu，每个线程都有自己的一组寄存器但共享执行资源（如cpu高速缓存）</li>
<li>YieldProcessor用于支持超线程技术的CPU切换超线程。<br>##计算线程执行时间</li>
<li>两个GetTicketCount64之间的时间（前提不中断,如果发生线程调度就会包含线程调度时间）</li>
<li><p>GetThreadTimes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadTimes</span><span class="params">(  HANDLE hThread,             <span class="comment">// handle to thread</span></span><br><span class="line">  LPFILETIME lpCreationTime,  <span class="comment">// thread creation time</span></span><br><span class="line">  LPFILETIME lpExitTime,      <span class="comment">// thread exit time</span></span><br><span class="line">  LPFILETIME lpKernelTime,    <span class="comment">// thread kernel-mode time</span></span><br><span class="line">  LPFILETIME lpUserTime       <span class="comment">// thread user-mode time);</span></span><br><span class="line"></span><br><span class="line">__int64 FileTimeToQuadWord(PFILETIME pft)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (Int64ShllMod32(</span><br><span class="line">      pft-&gt;dwHighDateTime, <span class="number">32</span>) | pft-&gt;dwLowDateTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerformLongOperation</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">   FILETIME ftKernelTimeStart, ftKernelTimeEnd;</span><br><span class="line">   FILETIME ftUserTimeStart,   ftUserTimeEnd;</span><br><span class="line"></span><br><span class="line">   FILETIME ftDummy;</span><br><span class="line">   __int64 qwKernelTimeElapsed, qwUserTimeElapsed,</span><br><span class="line">      qwTotalTimeElapsed;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Get starting times.</span></span><br><span class="line">   GetThreadTimes(GetCurrentThread(), &amp;ftDummy,</span><br><span class="line">      &amp;ftDummy, &amp;ftKernelTimeStart, &amp;ftUserTimeStart);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Perform complex algorithm here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//Get ending times.</span></span><br><span class="line">   GetThreadTimes(GetCurrentThread(), &amp;ftDummy,</span><br><span class="line">      &amp;ftDummy, &amp;ftKernelTimeEnd, &amp;ftUserTimeEnd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Get the elapsed kernel and user times by </span></span><br><span class="line">   <span class="comment">//converting the start and end times </span></span><br><span class="line">   <span class="comment">//from FILETIMEs to quad words, and then </span></span><br><span class="line">   <span class="comment">//subtract the start times from the end times.</span></span><br><span class="line"></span><br><span class="line">   qwKernelTimeElapsed = </span><br><span class="line">      FileTimeToQuadWord(&amp;ftKernelTimeEnd) -</span><br><span class="line">      FileTimeToQuadWord(&amp;ftKernelTimeStart);</span><br><span class="line"></span><br><span class="line">   qwUserTimeElapsed = </span><br><span class="line">      FileTimeToQuadWord(&amp;ftUserTimeEnd) -</span><br><span class="line">      FileTimeToQuadWord(&amp;ftUserTimeStart);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Get total time duration by adding the kernel</span></span><br><span class="line">   <span class="comment">//and user times.</span></span><br><span class="line"></span><br><span class="line">   qwTotalTimeElapsed = qwKernelTimeElapsed + </span><br><span class="line">      qwUserTimeElapsed;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//The total elapsed time is in </span></span><br><span class="line">   <span class="comment">//qwTotalTimeElapsed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于计时，最基本的有clock、GetTickCount、timeGetTime等；为了地提高精度，可以使用QueryPerformanceCounter；为了去掉因线程调度中断的时间和Sleep、Wait的时间，可以使用GetThreadTimes、GetProcessTimes等。在Vista以上的系统中，有新的机制，可以使用ReadTimeStampCounter（对应GetTickCount）、QueryThreadCycleTime（不考虑中断休眠，对应GetThreadTimes）、QueryProcessCycleTime等。对于没有考虑线程调度影响的函数，可以先用SetThreadPriority提高优先级尽量独占时间片。应该确保每次调用QueryPerformanceCounter的时候在同一CPU核心上，使用SetThreadAffinityMask。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CStopwatch </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   CStopwatch() </span><br><span class="line">   &#123; </span><br><span class="line">      QueryPerformanceFrequency(&amp;m_liPerfFreq);</span><br><span class="line">      Start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span> </span><br><span class="line">   </span>&#123; </span><br><span class="line">      QueryPerformanceCounter(&amp;m_liPerfStart);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   __<span class="function">int64 <span class="title">Now</span><span class="params">()</span> <span class="keyword">const</span> </span><br><span class="line">   </span>&#123;</span><br><span class="line">      <span class="comment">//Returns # of milliseconds since</span></span><br><span class="line">      <span class="comment">//Start was called</span></span><br><span class="line"></span><br><span class="line">      LARGE_INTEGER liPerfNow;</span><br><span class="line">      QueryPerformanceCounter(&amp;liPerfNow);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (((liPerfNow.QuadPart - </span><br><span class="line">         m_liPerfStart.QuadPart) * <span class="number">1000</span>)/</span><br><span class="line">         m_liPerfFreq.QuadPart);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Counts per second</span></span><br><span class="line">   LARGE_INTEGER m_liPerfFreq;   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//Starting count</span></span><br><span class="line">   LARGE_INTEGER m_liPerfStart;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a stopwatch timer</span></span><br><span class="line"><span class="comment">//(which defaults to the current time).</span></span><br><span class="line">CStopwatch stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Execute the code I want to profile here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Get how much time has elapsed up to now.</span></span><br><span class="line">  __int64 qwElapsedTime = stopwatch.Now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//qwElapsedTime indicates how long </span></span><br><span class="line"><span class="comment">//the profiled code executed in milliseconds.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##在实际上线文中谈CONTEXT结构</p>
<ul>
<li>CONTEXT结构特定与CUP,可分为用户模式上下文和内核模式上下文。用户模式CONTEXT可通过GetThreadContext查看不过必须先调用SuspendThread</li>
<li>可通过SetThreadContext改变CONTEXT中结构成员，先SuspendThread、再SetThreadContext改变线程上下文，可以改变执行流等，一般用于调试器 “跳到指定位置执行” 的功能等。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(  HANDLE hThread,       <span class="comment">// handle to thread with context</span></span><br><span class="line">  LPCONTEXT lpContext   <span class="comment">// context structure);</span></span><br><span class="line"></span><br><span class="line">kd&gt; dt _context</span><br><span class="line">hal!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Dr0              : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Dr1              : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> Dr2              : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> Dr3              : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> Dr6              : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Dr7              : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SegFs            : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> SegEs            : Uint4B</span><br><span class="line">   +<span class="number">0x098</span> SegDs            : Uint4B</span><br><span class="line">   +<span class="number">0x09c</span> Edi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> Esi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a4</span> Ebx              : Uint4B</span><br><span class="line">   +<span class="number">0x0a8</span> Edx              : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> Ecx              : Uint4B</span><br><span class="line">   +<span class="number">0x0b0</span> Eax              : Uint4B</span><br><span class="line">   +<span class="number">0x0b4</span> Ebp              : Uint4B</span><br><span class="line">   +<span class="number">0x0b8</span> Eip              : Uint4B</span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : Uint4B</span><br><span class="line">   +<span class="number">0x0c4</span> Esp              : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>] UChar</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##线程优先级</p>
<ul>
<li>每个线程都会被赋予一个从0（最低）到3 1（最高）的优先级号码，系统在启动时会创键一个优先级为0的线程负责在没有其他线程运行时执行</li>
<li>高优先级线程可以被调度时（没有Sleep、Wait等），低优先级线程得不到时间片；即使低优先级线程正在执行，一旦有高优先级线程可以调度，前者会被中断并让出CPU资源。</li>
<li><p>Window s支持6个优先级类：即空闲idle、低于正常below、正常normal、高于正常above normal、高high和实时real-time。当然，正常优先级是最常用的优先级类， 9 9 %的应用程序均使用这个优先级类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实时      进程中的线程必须立即对事件作出响 应，以便执行关键时间的任务。该进程中的线程还会抢先于操作系统组件之前运行。</span><br><span class="line">          使用本优先级类时必须极端小心 </span><br><span class="line">高        进程中的线程必须立即对事件作出响应，以便执行关键时间的任务。TaskManager（任务管理器）在这个类上运行，</span><br><span class="line">          以便用户可以撤消脱离控制的进程 </span><br><span class="line">高于正常  进程中的线程在正常优先级与高优先级之间运行</span><br><span class="line">正常      进程中的线程没有特殊的调度需求 </span><br><span class="line">低于正常  进程中的线程在正常优先级与空闲优先级之间运行（这是Wi n d o w s2 <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>中的新优先级类） </span><br><span class="line">空闲      进程中的线程在系统空闲时运行。该进程通常由屏幕保护程序或后台实用程序和搜集统计数据的软件使用</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关键时间  对于实时优先级类来说，线程在优先级<span class="number">3</span> <span class="number">1</span>上运行，对于其他优先级类来说，线程在优先级<span class="number">1</span> <span class="number">5</span>上运行 </span><br><span class="line">最高      线程在高于正常优先级的上两级上运行 </span><br><span class="line">高于正常  线程在正常优先级的上一级上运行 </span><br><span class="line">正常      线程在进程的优先级类上正常运行 </span><br><span class="line">低于正常  线程在低于正常优先级的下一级上运行 </span><br><span class="line">最低      线程在低于正常优先级的下两级上运行 </span><br><span class="line">空闲      对于实时优先级类来说，线程在优先级<span class="number">1</span> <span class="number">6</span>上运行对于其他优先级类来说，线程在优先级<span class="number">1</span>上运行</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过CreateProcess fdwCreate参数设置进程优先级，命令行启动使用 Start /LOW CALC.EXE</p>
</li>
<li><p>SetPriorityClass设置进程的优先级类，SetThreadPriority设置线程的相对优先级（相对于进程优先级类），二者共同决定线程的实际优先级（这个映射根据Windows版本不同而异，是一个0~31的整数，用户不可访问）。将线程的实际优先级设置为最高（31）是危险的，因为它将抢占系统资源，导致IO不能响应等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwThreadID;</span><br><span class="line"></span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFunc,</span><br><span class="line">   <span class="literal">NULL</span>, CREATE_SUSPENDED, &amp;dwThreadID);</span><br><span class="line"></span><br><span class="line">SetThreadPriority(hThread, THREAD_PRIORITY_IDLE);</span><br><span class="line"></span><br><span class="line">ResumeThread(hThread);</span><br><span class="line">CloseHandle(hThread);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当线程有IO事件或消息到来时，操作系统会暂时提高线程的优先级；或者线程可调度但长时间（数秒）都得不到时间片的时候，系统也会暂时提高线程优先级。可以设置是否允许系统自动提升优先级：SetProcessPriorityBoost、SetThreadPriorityBoost。</p>
</li>
<li>特定类型计算机的几个相关CPU核心之间可以共享内存缓存等，因此Windows支持设置线程关联CPU核心SetProcessAffinityMask、SetThreadAffinityMask。当然这组API也可以用于为特定线程提供专用CPU资源以提高性能。子进程默认继承父进程的核心关联设置。</li>
<li>SetThreadIdealProcessor设置线程最多可以使用的闲置CPU数量。该设置会覆盖AffinityMask。进程的默认AffinityMask可以在镜像文件头中设置（因为没有链接选项只有手工写文件）：ImageLoad-&gt;GetImageConfigInformation-&gt;ilcd.ProcessAffinityMask-&gt;SetImageConfigInformation-&gt;ImageUnload。</li>
</ul>
<p>#第8章 用户模式下的线程同步</p>
<p>##关于线程同步</p>
<ul>
<li>当所有的线程在互相之间不需要进行通信的情况下就能够顺利地运行时,Windows的运行性能最好。但很少存在这样的情况</li>
<li>使用线程间通信的的情况，当有多个线程访问共享资源而不使资源被破坏时、当一个线程需要将某个任务已经完成的情况通知另外一个或多个线程时</li>
<li>其他参考学习资料:<br><a href="http://blog.csdn.net/column/details/killthreadseries.html" target="_blank" rel="external">秒杀多线程面试题系列</a></li>
<li>多线程同步的一些方法:<br>原子访问、关键段、Slim读/写锁、条件变量<br>##原子访问</li>
<li>原子访问，是指线程在访问资源时能够确保所有其他线程都不在同一时间内访问相同的资源</li>
<li>Interlocked系列函数：InterlockedIncrement（对应++）、InterlockedExchangeAdd（对应+=）、InterlockedExchange（对应=）、InterlockedCompareExchange（cas）。</li>
<li>spinlock（自旋锁）是CAS的应用。使用自旋锁的时候因为有while(true) { …; Sleep(0); }这样的循环，因此线程优先级不能太高，使用SetThreadPriorityBoost来禁用优先级提升，避免被自动提升后不会让出CPU（或者使用SwitchToThread）。自旋锁适用于单个线程不会占用资源太久的情况（因为一个线程占有资源期间，其他线程在循环检测浪费CPU）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用原子访问循环锁实现关键段</span></span><br><span class="line">BOOL g_fResourceInUse=FALSE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//wait to access the resource</span></span><br><span class="line"><span class="keyword">while</span>(InterLockedExchange(&amp;g_fResourceInUse,TRUE)==ATRUE)</span><br><span class="line">Sleep(<span class="number">0</span>);<span class="comment">//SwitchTOThread();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Access the resource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wo no longer need to access the resource</span></span><br><span class="line">InterlockedExchange(%g_fResourceInUse,FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##高速缓存行</p>
<ul>
<li>如果想创建一个能够在多处理器计算机上运行的高性能应用程序，必须懂得CPU的高速缓存行</li>
<li>通常情况下，应用程序只能对一组相邻的字节进行处理。如果这些字节在高速缓存中，那么CPU就不必访问内存总线，而访问内存总线需要多得多的时间。</li>
<li>CacheLine：是Cache和内存通信的基本单位，可能是32/64字节等，CPU读写内存的时候会先将对应的CacheLine加载进Cache，修改完成后Flush到内存上。因此数据组织为CacheLine Size对齐、以及将只读和读写数据分别组织到不同的CacheLine都能提高效率。多个CPU（或者具有独立Cache的多个CPU核心）访问同一地址时，该地址附近的数据会被多个Cache映射成各自的CacheLine，如果其中某个CPU修改了其CacheLine的数据，该CPU会通知其他CPU更新各自的CacheLine，这种行为会影响性能，故尽量避免跨线程共享数据以及利用AffinityMask尽量使用同一个CPU。</li>
<li>volatile的作用：编译器不会将变量优化成寄存器变量，即每次读写都会访问内存。对struct应用该关键字会影响每个字段。</li>
<li>GetLogicalProcessorInformation提供CPU描述信息（比如能够查询到包括4个CPU核心，3级Cache，1、2级Cache为各个核心独有，3级Cache为共享Cache，其Cache Line Size为64字节等）</li>
<li>volatile的作用：编译器不会将变量优化成寄存器变量，即每次读写都会访问内存。对struct应用该关键字会影响每个字段。</li>
</ul>
<p>##关键代码段</p>
<ul>
<li><p>关键代码段是指一个小代码段，在代码能够执行前，它必须独占对某些共享资源的访问权。这是让若干行代码能够“以原子操作方式”来使用资源的一种方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_TIMES = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span>   g_nIndex = <span class="number">0</span>;</span><br><span class="line">DWORD g_dwTimes[MAX_TIMES];</span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line">InitializeCriticalSection(g_cs);</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">FirstThread</span><span class="params">(PVOID pvParam)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(g_nIndex &lt; MAX_TIMES) </span><br><span class="line">   &#123;</span><br><span class="line">      EnterCriticalSection(&amp;g_cs);</span><br><span class="line">      g_dwTimes[g_nIndex] = GetTickCount();</span><br><span class="line">      g_nIndex++;</span><br><span class="line">      LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SecondThread</span><span class="params">(PVOID pvParam)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(g_nIndex &lt; MAX_TIMES)</span><br><span class="line">   &#123;</span><br><span class="line">      EnterCriticalSection(&amp;g_cs);</span><br><span class="line">      g_nIndex++;</span><br><span class="line">      g_dwTimes[g_nIndex - <span class="number">1</span>] = GetTickCount();</span><br><span class="line">      LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CRITICAL_SECTION内部记录了拥有访问权的线程以及引用次数。TryEnterCriticalSection如果返回TRUE，则已经增加了计数需要对称调用LeaveCriticalSection。</p>
</li>
<li>CRITICAL_SECTION在实现上结合了spinlock（自旋锁），调用EnterCriticalSection时发现资源正被占用需要切换到内核态休眠之前（切换到内核态开销很大，高达数千CPU周期），可以尝试进行一定次数的循环判断。使用InitializeCriticalSectionAndSpinCount可以启用结合自旋锁功能（作为参考，用于保护进程堆的CS的SpinCount为4000），使用SetCriticalSectionSpinCount可以修改旋转次数。当SpinCount为1的时候,关键段内部用于休眠和唤醒的事件对象会第一时间创建，而不是等到EnterCriticalSection的时候才创建。建议总是启用自旋锁。</li>
<li>一些使用关键端的技巧<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个共享资源使用一个CRITICAL_SECTION变量</span><br><span class="line">同时访问多个资源,按照完全相同的顺序请求对资源的访问</span><br><span class="line">不要长时间运行关键代码段</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##Slim读/写锁</p>
<ul>
<li>Slim Reader/Writer Lock是性能比关键段更好的选择，相比后者，它的缺陷是不能递归加锁、且没有TryLock。InitializeSRWLock、AcquireSRWLockShared（申请读锁）、AcquireSRWLockExclusive（申请写锁）。</li>
<li>在都能完成任务的情况下，性能从高到底依次是：无锁、volatile、Interlocked、SRW、CRITICAL_SECTION、内核对象（因为切换到内核态开销很大）。</li>
</ul>
<p>##条件变量</p>
<ul>
<li>SleepConditionVariableCS、SleepConditionVariableSRW用法：已经获得锁（CS、SRW）的线程开始在一个ConditionVariable对象上睡眠，同时释放锁；如果其他线程Wakeup这个ConditionVariable对象，则函数返回TRUE，且再度获得锁；如果超时，返回FALSE，不会获得锁。应用：消费者获得锁后发现没有产品于是开始休眠等待生产者产出产品后唤醒。</li>
</ul>
<p>在都能完成任务的情况下，性能从高到底依次是：无锁、volatile、Interlocked、SRW、CRITICAL_SECTION、内核对象（因为切换到内核态开销很大）。</p>
<p>#第9章 用内核对象进行线程同步</p>
<p>##关于内核对象同步</p>
<ul>
<li>内核对象用于线程同步更灵活比如可以设置等待时间以及跨进程等，但开销更大（需要切换到内核模式）。</li>
<li>内核对象中都有一个表示触发状态的BOOLEAN值。</li>
<li>进程和线程对象在结束前是非触发，结束后是触发状态，其他时候不会再改变。</li>
<li>文件对象有正在处理的异步IO请求时处于非触发，其他时候触发。</li>
<li>进程和线程对象在结束前是非触发，结束后是触发状态，其他时候不会再改变。</li>
<li>控制台输入句柄在没有输入的时候非触发。<br>##等待函数</li>
<li><p>等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态为止。这些等待函数中最常用的是WaitForSingleObject</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(  HANDLE hHandle,        <span class="comment">// handle to object</span></span><br><span class="line">  DWORD dwMilliseconds   <span class="comment">// time-out interval);</span></span><br><span class="line">DWORD WaitForSingleObjectEx(  HANDLE hHandle,        <span class="comment">// handle to object</span></span><br><span class="line">  DWORD dwMilliseconds,  <span class="comment">// time-out interval</span></span><br><span class="line">  BOOL bAlertable        <span class="comment">// alertable option);</span></span><br><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">  DWORD nCount,             <span class="comment">// number of handles in array</span></span><br><span class="line">  CONST HANDLE *lpHandles,  <span class="comment">// object-handle array</span></span><br><span class="line">  BOOL bWaitAll,            <span class="comment">// wait option</span></span><br><span class="line">  DWORD dwMilliseconds      <span class="comment">// time-out interval);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内核对象触发后，Wait在上面的线程被唤醒，决定哪一个线程首先被唤醒的规则基本上就是等待顺序的先入先出，和线程的优先级等无关。<br>##事件内核对象</p>
</li>
<li>在所有的内核对象中，事件内核对象是个最基本的对象。它们包含一个使用计数（与所有内核对象一样），一个用于指明该事件是个自动重置的事件还是一个人工重置的事件的布尔值，另一个用于指明该事件处于已通知状态还是未通知状态的布尔值。</li>
<li><p>事件能够通知一个操作已经完成。有两种不同类型的事件对象。一种是人工重置的事件，另一种是自动重置的事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">// SD</span></span><br><span class="line">  BOOL bManualReset,                       <span class="comment">// reset type True人工重置事件、FALSE自动重置事件</span></span><br><span class="line">  BOOL bInitialState,                      <span class="comment">// initial state True已通知、false未通知状态</span></span><br><span class="line">  LPCTSTR lpName                           <span class="comment">// object name);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SetEvent将事件变为已通知状态，ResetEvent把事件变为未通知状态</p>
</li>
<li>当线程成功地等待到该对象时，自动重置的事件就会自动重置到未通知状态。</li>
<li>当不再需要事件内核对象时，应该调用CloseHandle函数。</li>
<li>PulseEvent会在Event对象上产生一个触发脉冲。近似于SetEvent(h);ResetEvent(h);两句。</li>
</ul>
<p>##可等待的计时器内核对象</p>
<ul>
<li><p>等待定时器是在某个时间或按规定的间隔时间发出自己的信号通知的内核对象。它们通常用来在某个时间执行某个操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateWaitableTimer</span><span class="params">(  LPSECURITY_ATTRIBUTES lpTimerAttributes, <span class="comment">// SD</span></span><br><span class="line">  BOOL bManualReset,                       <span class="comment">// reset type</span></span><br><span class="line">  LPCTSTR lpTimerName                      <span class="comment">// object name);</span></span><br><span class="line"><span class="comment">// Declare our local variables.</span></span><br><span class="line">HANDLE hTimer;</span><br><span class="line">SYSTEMTIME st;</span><br><span class="line">FILETIME ftLocal, ftUTC;</span><br><span class="line">LARGE_INTEGER liUTC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an auto-reset timer.</span></span><br><span class="line">hTimer = CreateWaitableTimer(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First signaling is at January 1, 2002, at 1:00 P.M. (local time).</span></span><br><span class="line">st.wYear         = <span class="number">2002</span>; <span class="comment">// Year</span></span><br><span class="line">st.wMonth        = <span class="number">1</span>;    <span class="comment">// January</span></span><br><span class="line">st.wDayOfWeek    = <span class="number">0</span>;    <span class="comment">// Ignored</span></span><br><span class="line">st.wDay          = <span class="number">1</span>;    <span class="comment">// The first of the month</span></span><br><span class="line">st.wHour         = <span class="number">13</span>;   <span class="comment">// 1PM</span></span><br><span class="line">st.wMinute       = <span class="number">0</span>;    <span class="comment">// 0 minutes into the hour</span></span><br><span class="line">st.wSecond       = <span class="number">0</span>;    <span class="comment">// 0 seconds into the minute</span></span><br><span class="line">st.wMilliseconds = <span class="number">0</span>;    <span class="comment">// 0 milliseconds into the second</span></span><br><span class="line"></span><br><span class="line">SystemTimeToFileTime(&amp;st, &amp;ftLocal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert local time to UTC time.</span></span><br><span class="line">LocalFileTimeToFileTime(&amp;ftLocal, &amp;ftUTC);</span><br><span class="line"><span class="comment">// Convert FILETIME to LARGE_INTEGER because of different alignment.</span></span><br><span class="line">liUTC.LowPart  = ftUTC.dwLowDateTime;</span><br><span class="line">liUTC.HighPart = ftUTC.dwHighDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the timer.</span></span><br><span class="line">SetWaitableTimer(hTimer, &amp;liUTC, <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">   <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetWaitableTimer</span><span class="params">(</span><br><span class="line">  HANDLE hTimer,                          <span class="comment">// handle to timer</span></span><br><span class="line">  <span class="keyword">const</span> LARGE_INTEGER *pDueTime,          <span class="comment">// timer due time</span></span><br><span class="line">  LONG lPeriod,                           <span class="comment">// timer interval</span></span><br><span class="line">  PTIMERAPCROUTINE pfnCompletionRoutine,  <span class="comment">// completion routine</span></span><br><span class="line">  LPVOID lpArgToCompletionRoutine,        <span class="comment">// completion routine parameter</span></span><br><span class="line">  BOOL fResume                            <span class="comment">// resume state);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>WaitableTimer在平时处于非触发，第一次时间到或者之后周期性时间到都会处于触发状态。另外在SetWaitableTimer的时候可以传入回调指定在触发的时候往APC（Asynchronous Procedure Call）队列中加入回调，但必须定时器触发时线程正处于Alertable（使用SleepEx等带Ex的API）状态下才会入队列（避免因为回调处理太慢及其他因素导致过量入队）。一般定时器的APC和WaitFor两种模式不混用。SetWaitableTimer指定第一次的时间时，正数表示绝对时间（SystemTimeToFileTime得到），负数表示相对时间。每次调用SetWaitableTimer会自动取消上次调用的设置，故两次调用间不必CancelWaitableTimer。该定时器和基于消息的SetTimer定时器建议适时选用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunc</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="comment">//Create a timer.(It doesn't matter whether it's manual-reset</span></span><br><span class="line">   <span class="comment">//or auto-reset.)</span></span><br><span class="line">   HANDLE hTimer = CreateWaitableTimer(<span class="literal">NULL</span>, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Set timer to go off in 5 seconds.</span></span><br><span class="line">   LARGE_INTEGER li = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   SetWaitableTimer(hTimer, &amp;li, <span class="number">5000</span>, TimerAPCRoutine, <span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Wait in an alertable state for the timer to go off.</span></span><br><span class="line">   SleepEx(INFINITE, TRUE);</span><br><span class="line"></span><br><span class="line">   CloseHandle(hTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##信号量内核对象</p>
<ul>
<li>信号量内核对象用于对资源进行计数。它们与所有内核对象一样，包含一个使用数量，但是它们也包含另外两个带符号的32位值，一个是最大资源数量，一个是当前资源数量。最大资源数量用于标识信标能够控制的资源的最大数量，而当前资源数量则用于标识当前可以使用的资源的数量。</li>
<li>Semaphore的当前计数非0时处于触发。ReleaseSemaphore增加计数发现达到最大时会返回FALSE，WaitFor减少计数到0的时候会休眠。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, <span class="comment">// SD</span></span><br><span class="line">  LONG lInitialCount,                          <span class="comment">// initial count</span></span><br><span class="line">  LONG lMaximumCount,                          <span class="comment">// maximum count</span></span><br><span class="line">  LPCTSTR lpName                               <span class="comment">// object name);</span></span><br><span class="line"></span><br><span class="line">BOOL ReleaseSemaphore(  HANDLE hSemaphore,       <span class="comment">// handle to semaphore</span></span><br><span class="line">  LONG lReleaseCount,      <span class="comment">// count increment amount</span></span><br><span class="line">  LPLONG lpPreviousCount   <span class="comment">// previous count);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##互斥量内核对象</p>
<ul>
<li>互斥对象（mutex）内核对象能够确保线程拥有对单个资源的互斥访问权。</li>
<li>互斥对象的行为特性与关键代码段相同，但是互斥对象属于内核对象，而关键代码段则属于用户方式对象。这意味着互斥对象的运行速度比关键代码段要慢。但是这也意味着不同进程中的多个线程能够访问单个互斥对象，并且这意味着线程在等待访问资源时可以设定一个超时值。</li>
<li>Mutex和CriticalSection在使用上完全相同，都记录了Owner线程和递归次数。由于CriticalSection和Mutex记录了Owner线程，因此需要该线程来释放计数，如果在计数减少到0前线程退出了，则同步对象处于Abandoned（遗弃）状态。对于Abandoned的情况，系统能检测到发生在Mutex上的问题，并在底层自动释放计数，只是WaitFor会返回WAIT_ABANDONED表示Mutex对象的计数是由系统自动回收的，该Mutex保护的资源可能处在未定义状态。而CS的计数不会被自动释放，一旦Abandoned则CS永远的失效了。</li>
<li><code>p264</code></li>
</ul>
<p>##其他线程同步函数</p>
<ul>
<li>异步设备I / O使得线程能够启动一个读操作或写操作，但是不必等待读操作或写操作完成。</li>
<li>WaitForInputIdle：进程中创建第一个窗口的线程的消息队列中没有需要处理的输入消息后返回。</li>
<li>MsgWaitForMultipleObjects：等待的内核对象触发后或者线程的消息队列中有相应消息后返回。</li>
<li>WaitForDenugEvent</li>
<li>SignalObjectAndWait增加一个对象计数的同时原子地等待另一个对象。能够增加计数的对象只限于Event（SetEvent）、Mutex（ReleaseMutex）、Semaphore（ReleaseSemaphore），而等待的对象类型不限。使用：客户端填充好请求于是通知服务端准备处理并等待服务端处理完毕。</li>
<li>在Vista以上可以通过WCT（等待链遍历，Wait Chain Traversal）相关API来追踪死锁。OpenThreadWaitChainSession、GetThreadWaitChain。</li>
</ul>

      
    </div>
    <footer>
      

        
          <div class="alignleft post-nav">
            <em>上一篇: </em><a href="/2015/10/27/Read-Notes/Read-Notes-Windows-Via-C-C-5/">Windows核心编程读书笔记5（第10、11、12章）</a>
          </div>
        
        
          <div class="alignright post-nav">
            <em>下一篇: </em><a href="/2015/10/22/Windows/Different-From-several-Ways-Create-Process/">几种创建进程函数的不同</a>
          </div>
          <div class="clearfix"></div>
        

        
          <div class="copyright">
            
              <span class="claim">转载请注明youngroe.com</span>
            
            
              <span class="from-link">
                <em>本文链接地址:</em>
                <a href="/2015/10/23/Read-Notes/Read-Notes-Windows-Via-C-C-4/">
                  http://www.youngroe.com/2015/10/23/Read-Notes/Read-Notes-Windows-Via-C-C-4/
                </a>
              </span>
            
          </div>
        
        
  
  <div class="categories">
    <a href="/categories/Read-Notes/">Read Notes</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Windows核心编程/">Windows核心编程</a>
  </div>

        <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone"></a><a href="#" class="bds_tsina" data-cmd="tsina"></a><a href="#" class="bds_tqq" data-cmd="tqq"></a><a href="#" class="bds_renren" data-cmd="renren"></a><a href="#" class="bds_weixin" data-cmd="weixin"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"������","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
        
          <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
      </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/img/Alipay.png" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/img/WeChatpay.png" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>
<! -- 添加捐赠图标 -->
        
        <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
  clientID: '503c39aa3fb2b8c1b734',
  clientSecret: '65d784ff7a95a9dbf4a4208c9e32166ca29654f2',
  repo: 'geemion.github.io',
  owner: 'geemion',
  admin: 'geemion',
  pagerDirection:'first',
  id: md5(window.location.pathname)
})

gitalk.render('gitalk-container')
</script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
  <div id="container"></div>
</span>
</article>


<section id="comment">
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Cybersecurity/">Cybersecurity</a><small>1</small></li>
  
    <li><a href="/categories/Debug/">Debug</a><small>7</small></li>
  
    <li><a href="/categories/Kernel/">Kernel</a><small>4</small></li>
  
    <li><a href="/categories/Learning/">Learning</a><small>8</small></li>
  
    <li><a href="/categories/Life/">Life</a><small>7</small></li>
  
    <li><a href="/categories/Others/">Others</a><small>1</small></li>
  
    <li><a href="/categories/Read-Notes/">Read Notes</a><small>7</small></li>
  
    <li><a href="/categories/Tools/">Tools</a><small>6</small></li>
  
    <li><a href="/categories/Vulnerabilities/">Vulnerabilities</a><small>0</small></li>
  
    <li><a href="/categories/Windows/">Windows</a><small>14</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/07/01/Windows/delphi_reverse_summary/">Delphi程序逆向反汇编技巧小记</a>
      </li>
    
      <li>
        <a href="/2019/06/25/Kernel/kernel_enum_wfp_callout_function/">Windows内核重拾：如何枚举系统中Windows Filtering Platform (WFP)驱动中的callout函数</a>
      </li>
    
      <li>
        <a href="/2019/05/06/Kernel/windows-driver-testing-basics/">Windows内核重拾：Windows驱动测试基础：工具、功能和示例（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/">如何正确的对Windows软件进行逆向工程（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2019/01/12/Windows/a_crash_lead_deadlock/">Windows平台下一个崩溃而导致的死锁分析</a>
      </li>
    
      <li>
        <a href="/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a>
      </li>
    
      <li>
        <a href="/2018/10/06/Cybersecurity/ddos-protection-techniques/">现代DDoS对抗技术概述（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2018/09/18/Life/xian/">西安周末游</a>
      </li>
    
      <li>
        <a href="/2018/01/06/Kernel/WindowsKernel_DebugObject/">Windows内核重拾：DebugObject</a>
      </li>
    
      <li>
        <a href="/2017/10/23/Tools/IDA-Pro-ClassInformer-Tutorial/">IDA Pro ClassInformer使用指南（翻译）</a>
      </li>
    
      <li>
        <a href="/2017/05/23/Windows/Kernel Data and Filtering Support/">Kernel Data and Filtering Support for Windows Server 2008（翻译）</a>
      </li>
    
      <li>
        <a href="/2017/05/17/Windows/Windows-x64-Shellcode/">Windows x64 Shellcode编写指南(翻译)</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/ASM/" style="font-size: 12.5px;">ASM</a> <a href="/tags/Boost/" style="font-size: 10px;">Boost</a> <a href="/tags/DDoS/" style="font-size: 10px;">DDoS</a> <a href="/tags/DNS-over-HTTPS/" style="font-size: 10px;">DNS-over-HTTPS</a> <a href="/tags/Delphi/" style="font-size: 10px;">Delphi</a> <a href="/tags/Dll劫持/" style="font-size: 10px;">Dll劫持</a> <a href="/tags/GCC-GDB/" style="font-size: 10px;">GCC&GDB</a> <a href="/tags/GetVersionEx/" style="font-size: 10px;">GetVersionEx</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IDA-Pro/" style="font-size: 12.5px;">IDA Pro</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MSDN/" style="font-size: 12.5px;">MSDN</a> <a href="/tags/Malware/" style="font-size: 12.5px;">Malware</a> <a href="/tags/MiniDumpWriteDump/" style="font-size: 10px;">MiniDumpWriteDump</a> <a href="/tags/PEB/" style="font-size: 10px;">PEB</a> <a href="/tags/Procmon/" style="font-size: 10px;">Procmon</a> <a href="/tags/Runtime-Error/" style="font-size: 10px;">Runtime Error</a> <a href="/tags/SEH/" style="font-size: 10px;">SEH</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/SysinternalsSuite/" style="font-size: 10px;">SysinternalsSuite</a> <a href="/tags/Tips/" style="font-size: 10px;">Tips</a> <a href="/tags/UAC/" style="font-size: 10px;">UAC</a> <a href="/tags/UAF漏洞/" style="font-size: 10px;">UAF漏洞</a> <a href="/tags/VC/" style="font-size: 10px;">VC</a> <a href="/tags/Visual-Studio/" style="font-size: 12.5px;">Visual Studio</a> <a href="/tags/Windbg/" style="font-size: 10px;">Windbg</a> <a href="/tags/Windows/" style="font-size: 20px;">Windows</a> <a href="/tags/Windows核心编程/" style="font-size: 17.5px;">Windows核心编程</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/getaddrinfo/" style="font-size: 10px;">getaddrinfo</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/libeay32/" style="font-size: 10px;">libeay32</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/ndk/" style="font-size: 10px;">ndk</a> <a href="/tags/sublime-text3/" style="font-size: 10px;">sublime text3</a> <a href="/tags/x64/" style="font-size: 12.5px;">x64</a> <a href="/tags/体验/" style="font-size: 10px;">体验</a> <a href="/tags/内核/" style="font-size: 12.5px;">内核</a> <a href="/tags/内核结构/" style="font-size: 15px;">内核结构</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/安全机制/" style="font-size: 10px;">安全机制</a> <a href="/tags/异常处理/" style="font-size: 10px;">异常处理</a> <a href="/tags/提权/" style="font-size: 10px;">提权</a> <a href="/tags/服务/" style="font-size: 10px;">服务</a> <a href="/tags/权限/" style="font-size: 12.5px;">权限</a> <a href="/tags/栈溢出漏洞/" style="font-size: 10px;">栈溢出漏洞</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/浮躁/" style="font-size: 10px;">浮躁</a> <a href="/tags/漏洞调试/" style="font-size: 12.5px;">漏洞调试</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/脱壳/" style="font-size: 10px;">脱壳</a> <a href="/tags/西安/" style="font-size: 10px;">西安</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/调试/" style="font-size: 15px;">调试</a> <a href="/tags/转换/" style="font-size: 10px;">转换</a> <a href="/tags/进程/" style="font-size: 10px;">进程</a> <a href="/tags/逆向/" style="font-size: 10px;">逆向</a> <a href="/tags/重庆/" style="font-size: 10px;">重庆</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
<li><a href="http://blog.ourren.com/" title="Ourren">Ourren</a></li>
<li><a href="http://www.hyjal.net/" title="Hyjal">Hyjal</a></li>
<li><a href="http://www.jianshu.com/users/fa15f4e416ae/latest_articles" title="Daemonceltics">Daemonceltics</a></li>
<li><a href="http://papap.info/" title="isee">isee</a></li>
</ul>
</div>

  <script type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=putG&d=yoFnN6V-ovhL-H4e9_69LvkTiX4uX7rEYJ15yL3G1Wg"></script>
</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 Lyon
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>

</body>

</html>