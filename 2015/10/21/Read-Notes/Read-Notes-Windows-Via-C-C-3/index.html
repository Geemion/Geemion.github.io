<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Windows核心编程读书笔记3（第5章 作业 第6章 线程基础） | Lyon&#39;s blog</title>
  <meta name="author" content="Lyon">
  
  <meta name="description" content="Walk steps step by step">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Windows核心编程读书笔记3（第5章 作业 第6章 线程基础）"/>
  <meta property="og:site_name" content="Lyon&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  #<link href="/favicon.ico" rel="icon">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Lyon&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="/js/jquery.min.js"></script>
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1d807422614f63c8de98cdc3b546860c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
    
</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Lyon&#39;s blog</a></h1>
  <h2><a href="/">I hear and I forget.I see and I remember.I do and I understand.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <time datetime="2015-10-21T11:22:19.000Z"><a href="/2015/10/21/Read-Notes/Read-Notes-Windows-Via-C-C-3/">2015-10-21</a></time>
      
      
  
    <h1 class="title">Windows核心编程读书笔记3（第5章 作业 第6章 线程基础）</h1>
  

    </header>
	
<!-- Table of Contents -->

  <div id="toc" class="toc-article">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第5章_作业"><span class="toc-number">1.</span> <span class="toc-text">第5章 作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要作业"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对作业中的进程施加限制"><span class="toc-number">1.2.</span> <span class="toc-text">对作业中的进程施加限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将进程放入作业中"><span class="toc-number">1.3.</span> <span class="toc-text">将进程放入作业中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止作业中所有进程的运行"><span class="toc-number">1.4.</span> <span class="toc-text">终止作业中所有进程的运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作业通知信息"><span class="toc-number">1.5.</span> <span class="toc-text">作业通知信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第6章_线程基础知识"><span class="toc-number">2.</span> <span class="toc-text">第6章 线程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于线程"><span class="toc-number">2.1.</span> <span class="toc-text">关于线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何时创建线程"><span class="toc-number">2.2.</span> <span class="toc-text">何时创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何时不应创建线程"><span class="toc-number">2.3.</span> <span class="toc-text">何时不应创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateThread函数"><span class="toc-number">2.4.</span> <span class="toc-text">CreateThread函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止线程的运行"><span class="toc-number">2.5.</span> <span class="toc-text">终止线程的运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程内幕"><span class="toc-number">2.6.</span> <span class="toc-text">线程内幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C/C++运行库注意事项"><span class="toc-number">2.6.1.</span> <span class="toc-text">C/C++运行库注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解自己身份"><span class="toc-number">2.7.</span> <span class="toc-text">了解自己身份</span></a></li></ol></li></ol>
  </div>


	
    <div class="entry">
      
        <h1 id="第5章_作业">第5章 作业</h1><h2 id="为什么需要作业">为什么需要作业</h2><ul>
<li>因为Windows并不维护进程之间的父/子关系，即使父进程已经终止运行，子进程仍然会继续运行。为了管理一组进程设计了作业内核对象</li>
<li>将作业对象视为一个进程的容器，通过作业可以对进程施加一些限制。</li>
<li>作业将一组进程组合在一起创建一个沙箱</li>
<li>StartRestrictesProcess函数，当一个进程与作业关联后就无法从作业中去除</li>
<li>Vista开始，通过explorer创建的一个进程自动同一个专用的作业关联 PCA前缀，主要是为了检测兼容性 </li>
<li>从命令行启动调试器不会同默认作业关联</li>
<li>CreateJobObject、OPenJobObject<h2 id="对作业中的进程施加限制">对作业中的进程施加限制</h2></li>
<li>当作业运行时，它会维护一些统计信息，比如作业中的进程已经使用了多少CPU时间。</li>
<li>对作业施加的最后一种限制类型与安全性相关（注意，一旦使用这种限制，就无法取消安全性限制）</li>
<li>作业创建后通过设置沙箱对对进程施加限制</li>
<li>限制包括独占系统资源、改变用户界面、访问安全资源</li>
<li>当客户的作业句柄变量都被关闭后，即使作业对象还存在（因为进程没有全部结束），也不能再通过作业名打开作业再操作了。</li>
<li>SetInformationJobObject、QueryInformationJobObject用于设置和查询限制</li>
</ul>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetInformationJobObject</span><span class="params">(</span><br><span class="line">  HANDLE hJob,                           <span class="comment">// handle to job</span></span><br><span class="line">  JOBOBJECTINFOCLASS JobObjectInfoClass, <span class="comment">// information class</span></span><br><span class="line">  LPVOID lpJobObjectInfo,                <span class="comment">// limit information</span></span><br><span class="line">  DWORD cbJobObjectInfoLength            <span class="comment">// size of limit information</span></span><br><span class="line">)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _JOBOBJECT_SECURITY_LIMIT_INFORMATION &#123;</span><br><span class="line">    DWORD SecurityLimitFlags ;指明是否不允许管理员访问、不允许无限制的标记访问、强</span><br><span class="line">制使用特定的访问标记，或者停用某些安全性标识符和优先权</span><br><span class="line">    HANDLE JobToken ;         作业中的所有进程使用的访问标记</span><br><span class="line">    PTOKEN_GROUPS SidsToDisable ;指明为访问检查停用哪些S I D</span><br><span class="line">    PTOKEN_PRIVILEGES PrivilegesToDelete ;指明要从访问标记中删除哪些优先权</span><br><span class="line">    PTOKEN_GROUPS RestrictedSids ; 指明应该添加给访问标记的一组仅为拒绝(deny only )的S I D</span><br><span class="line">&#125; JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;</span><br><span class="line"><span class="function">BOOL <span class="title">QueryInformationJobObject</span><span class="params">(</span><br><span class="line">  HANDLE hJob,                           <span class="comment">// handle to job</span></span><br><span class="line">  JOBOBJECTINFOCLASS JobObjectInfoClass, <span class="comment">// information class</span></span><br><span class="line">  LPVOID lpJobObjectInfo,                <span class="comment">// limit information</span></span><br><span class="line">  DWORD cbJobObjectInfoLength,           <span class="comment">// limit information size</span></span><br><span class="line">  LPDWORD lpReturnLength                 <span class="comment">// data written);</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="将进程放入作业中">将进程放入作业中</h2><ul>
<li>CreateProcess 使用CREATE_SUSPENDED标志创建进程，在创建新进程且允许运行之前调用AssignProcessToJobObject可使用IsProcessInJob检查是否在作业中,然后调用ResumeThread</li>
<li>父进程位于某一作业中，子进程创建后也自动加入同一作业。除非作业的基本限制中包含JOB_OBJECT_LIMIT_BREAKAWAY_OK（允许进程时脱离作业），并且CreateProcess时指定CREATE_BREAKAWAY_FROM_JOB标记。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AssignProcessToJobObject</span><span class="params">(</span><br><span class="line">  HANDLE hJob,     <span class="comment">// handle to job</span></span><br><span class="line">  HANDLE hProcess  <span class="comment">// handle to process</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数告诉系统，将该进程（由hProcess标识）视为现有作业（由hJob标识）的一部分。</li>
</ul>
<h2 id="终止作业中所有进程的运行">终止作业中所有进程的运行</h2><ul>
<li><p>TerminateJobObject强制结束作业，同时结束作业内所有进程（等价于对作业内每个进程调TerminateProcess）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TerminateJobObject</span><span class="params">(  HANDLE hJob,    <span class="comment">// handle to job</span></span><br><span class="line">  UINT uExitCode  <span class="comment">// exit code);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>QueryInformationJobObject除了查看作业限制外，也可以查看作业信息，包括总进程数、活跃进程数、总时间、总IO次数、进程ID列表等。更多信息可以使用Performance Data Helper函数库PDH.dll</p>
</li>
</ul>
<h2 id="作业通知信息">作业通知信息</h2><ul>
<li>作业结束后（所有内部进程结束），内核对象处于激活态，可通过Waitforsingleobject作业对象可以得到作业通知信息</li>
<li>作业通知机制：将作业对象和IO完成端口绑定，作业中的事件（进程结束、时间到期、内存达到限制等）将通过完成端口事件来通知。</li>
<li>程序</li>
</ul>
<h1 id="第6章_线程基础知识">第6章 线程基础知识</h1><h2 id="关于线程">关于线程</h2><ul>
<li>像进程一样，线程在数据上也分为两个部分：线程内核对象（包括统计信息）、栈。（进程的两个部分是，内核对象和地址空间）。</li>
<li>操作系统利用线程内核对象管理线程，存放线程统计信息。线程栈用于维护线程执行时需要的函数参数和局部变量</li>
<li>进程内的线程共享地址空间，共享内核对象句柄<h2 id="何时创建线程">何时创建线程</h2></li>
<li>进程必须有一个主线程</li>
<li>利用多线程可以为编程提供很多便利，文件索引、磁盘整理、拼写检查。。。。</li>
<li>多线程合理利用了多cup<h2 id="何时不应创建线程">何时不应创建线程</h2></li>
<li>多线程可能会产生一些问题，应该谨慎使用</li>
<li>线程函数必须有一个返回值，它将成为该线程的退出代码。这与C/C++运行期库关于让主线程的退出代码作为进程的退出代码的原则是相似的。</li>
<li>线程函数（实际上是你的所有函数）应该尽可能使用函数参数和局部变量。当使用静态变量和全局变量时，多个线程可以同时访问这些变量，这可能破坏变量的内容。然而，参数和局部变量是在线程堆栈中创建的，因此它们不太可能被另一个线程破坏。</li>
</ul>
<h2 id="CreateThread函数">CreateThread函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span> <span class="params">(</span><br><span class="line">  SEC_ATTRS SecurityAttributes,</span><br><span class="line">  ULONG StackSize,</span><br><span class="line">  SEC_THREAD_START StartFunction,</span><br><span class="line">  PVOID ThreadParameter,</span><br><span class="line">  ULONG CreationFlags,</span><br><span class="line">  PULONG ThreadId</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>CreateThread 系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。</li>
<li>系统从进程的地址空间中分配内存，供线程的堆栈使用。新线程可以访问进程的内核对象的所有句柄、进程中的所有内存和在这个相同的进程中的所有其他线程的堆栈。这使得单个进程中的多个线程确实能够非常容易地互相通信。</li>
<li><code>在C/C++编程中不要使用CreateThread、ExitThread，应该使用编译器厂商提供的包装函数</code>，如MS的_beginthreadex、_endthreadex。因为使用前者，C/C++的CRT不能正常初始化和释放线程相关资源（C/C++中有一些全局变量如errno和一些有内部状态的函数strtok、asctime都需要通过TLS来正确实现，毕竟C库函数的诞生早于多线程）。事实上，如果在C/C++中使用了CreateThread和EndThread，部分有内部状态的函数还是可以正常使用的，因为这些函数内部会尝试取得TLS，发现还未分配的话会自动分配，CRT的Dll版本库也会在得到线程退出通知时尝试释放TLS，只是因为这份TLS是中途分配的信息不够全面，部分状态函数还是会有问题，因此在C/C++中还是要尽量使用后者。</li>
<li>SecurityAttributes 如果想要该线程内核对象的默认安全属性，可以（并且通常能够）传递NULL。如果希望所有的子进程能够继承该线程对象的句<br>柄，必须设定一个SEC_ATTRS结构，</li>
<li>StackSize 设定线程可以将多少地址空间用于它自己的堆栈。每个线程拥有它自己的堆栈 一般默认为1MB。 /STACK传递的值不是0，就能使该函数将所有的存储器保留并分配给线程的堆栈。由于所有的存储器预先作了分配，因此可以确保线程拥有指定容量的可用堆栈存储器。</li>
<li>StartFunction指明想要新线程执行的线程函数的地址 ThreadParameter 该参数传递给线程函数</li>
<li>CreationFlags 设定用于控制创建线程的其他标志 ThreadId 使用这个地址来存放系统分配给新线程的ID</li>
</ul>
<h2 id="终止线程的运行">终止线程的运行</h2><ul>
<li><p>线程函数返回（最好使用这种方法）。这是确保所有线程资源被正确地清除的唯一办法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果线程能够返回，就可以确保下列事项的实现：</span><br><span class="line">在线程函数中创建的所有C + +对象均将通过它们的撤消函数正确地撤消。</span><br><span class="line">操作系统将正确地释放线程堆栈使用的内存。</span><br><span class="line">系统将线程的退出代码（在线程的内核对象中维护）设置为线程函数的返回值。</span><br><span class="line">系统将递减线程内核对象的使用计数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用ExitThread函数，线程将自行撤消（最好不要使用这种方法）。创建的C++对象均将通过它们的撤消函数不能正确地撤消</p>
</li>
<li><p>同一个进程或另一个进程中的线程调用TerminateThread函数（应该避免使用这种方法）。该函数是异步的，函数返回时，线程还没有结束，需要WaitForSingleObject；DllMain不会收到被Terminate线程的结束通知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TerminateThread</span><span class="params">(  HANDLE hThread,    <span class="comment">// handle to thread</span></span><br><span class="line">  DWORD dwExitCode   <span class="comment">// exit code);</span></span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>包含线程的进程终止运行（应该避免使用这种方法），对进程中的各个线程来说，ExitProcess和TerminateProcess都将导致对线程的TerminateThread调用，因此进程的main函数结束前，尽量确保工作线程都正常退出。</p>
</li>
<li>大部分的资源都是进程相关的，窗口句柄和hook句柄是线程相关的，线程退出时会释放他们（在C/C++中还有CRT的TLS变量）。</li>
</ul>
<h2 id="线程内幕">线程内幕</h2><ul>
<li>一旦内核对象创建完成，系统就分配用于线程的堆栈的内存。该内存是从进程的地址空间分配而来的，因为线程并不拥有它自己的地址空间</li>
<li>每个线程都有它自己的一组CPU寄存器，称为线程的上下文。该上下文反映了线程上次运行时该线程的C P U寄存器的状态。保存在CONTEXT结构中</li>
<li>在线程函数中建立一个结构化异常处理（SEH）帧，这样，在线程执行时产生的任何异常情况都会得到系统的某种默认处理<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">RtlUserThreadStart</span><span class="params">(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)</span> </span>&#123;</span><br><span class="line">__try &#123;</span><br><span class="line">ExitThread((pfnStartAddr)(pvParam));</span><br><span class="line">&#125;</span><br><span class="line">__except(UnhandledExceptionFilter(GetExceptionInformation())) &#123;</span><br><span class="line">ExitProcess(GetExceptionCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> We never get here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="C/C++运行库注意事项">C/C++运行库注意事项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">多线程(/MT)             libcmt.lib</span><br><span class="line">多线程调试(/MTd)        libcmtd.lib</span><br><span class="line">多线程 DLL (/MD)        msvcrt.lib</span><br><span class="line">多线程调试 DLL (/MDd)   msvcrtd.lib</span><br><span class="line">托管/本机代码           msvcmrt.lib</span><br><span class="line">msil                    msvcurt.lib</span><br></pre></td></tr></table></figure>
<ul>
<li>创建线程安全_beginthreadex,为每一个新线程准备了一个独立数据块，线程局部存储TLS p158</li>
<li>大部分的资源都是进程相关的，窗口句柄和hook句柄是线程相关的，线程退出时会释放他们（在C/C++中还有CRT的TLS变量）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> chBEGINTHREADEX(psa, cbStackSize, pfnStartAddr, \</span><br><span class="line">   pvParam, dwCreateFlags, pdwThreadId)                 \</span><br><span class="line">      ((HANDLE)_beginthreadex(                          \</span><br><span class="line">         (void *)        (psa),                         \</span><br><span class="line">         (unsigned)      (cbStackSize),                 \</span><br><span class="line">         (PTHREAD_START) (pfnStartAddr),                \</span><br><span class="line">         (void *)        (pvParam),                     \</span><br><span class="line">         (unsigned)      (dwCreateFlags),               \</span><br><span class="line">         (unsigned *)    (pdwThreadId)))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="了解自己身份">了解自己身份</h2><ul>
<li>GetCurrentProcess、GetCurrentThread返回的都是伪句柄，如果想要把这个句柄保存下来在其他线程、进程中使用的话，是有歧义的，可以用保存ID来代替，如果一定要保存句柄的话，两种方法：（1）DuplicateHandle（2）先GetCurrentThreadID，再OpenThread。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HANDLEhThreadParent;</span><br><span class="line">DuplicateHandle(</span><br><span class="line">GetCurrentProcess(),      <span class="comment">// Handle of process that thread</span></span><br><span class="line"><span class="comment">//pseudohandle is relative to</span></span><br><span class="line">GetCurrentThread(),       <span class="comment">// Parent thread's pseudohandle</span></span><br><span class="line">GetCurrentProcess(),      <span class="comment">// Handle of process that the new, real,</span></span><br><span class="line"><span class="comment">//thread handle is relative to</span></span><br><span class="line">&amp;hThreadParent,           <span class="comment">// Will receive the new, real,handle</span></span><br><span class="line"><span class="comment">//identifying the parent thread</span></span><br><span class="line"><span class="number">0</span>,                        <span class="comment">// Ignored due toDUPLICATE_SAME_ACCESS</span></span><br><span class="line">FALSE,                    <span class="comment">// New thread handle is notinheritable</span></span><br><span class="line">DUPLICATE_SAME_ACCESS);   <span class="comment">// New thread handle has same access aspseudohandle</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer>
      

        
          <div class="alignleft post-nav">
            <em>上一篇: </em><a href="/2015/10/22/Windows/Different-From-several-Ways-Create-Process/">几种创建进程函数的不同</a>
          </div>
        
        
          <div class="alignright post-nav">
            <em>下一篇: </em><a href="/2015/10/16/Read-Notes/Read-Notes-Windows-Via-C-C-2/">Windows核心编程读书笔记2（第4章 进程）</a>
          </div>
          <div class="clearfix"></div>
        

        
          <div class="copyright">
            
              <span class="claim">转载请注明youngroe.com</span>
            
            
              <span class="from-link">
                <em>本文链接地址:</em>
                <a href="/2015/10/21/Read-Notes/Read-Notes-Windows-Via-C-C-3/">
                  http://www.youngroe.com/2015/10/21/Read-Notes/Read-Notes-Windows-Via-C-C-3/
                </a>
              </span>
            
          </div>
        
        
  
  <div class="categories">
    <a href="/categories/Read-Notes/">Read Notes</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Windows核心编程/">Windows核心编程</a>
  </div>

        <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone"></a><a href="#" class="bds_tsina" data-cmd="tsina"></a><a href="#" class="bds_tqq" data-cmd="tqq"></a><a href="#" class="bds_renren" data-cmd="renren"></a><a href="#" class="bds_weixin" data-cmd="weixin"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"������","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
        
          <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
      </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/img/Alipay.png" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/img/WeChatpay.png" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>
<! -- 添加捐赠图标 -->
        
        <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
  clientID: '503c39aa3fb2b8c1b734',
  clientSecret: '65d784ff7a95a9dbf4a4208c9e32166ca29654f2',
  repo: 'geemion.github.io',
  owner: 'geemion',
  admin: 'geemion',
  pagerDirection:'first',
  id: md5(window.location.pathname)
})

gitalk.render('gitalk-container')
</script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
  <div id="container"></div>
</span>
</article>


<section id="comment">
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Cybersecurity/">Cybersecurity</a><small>1</small></li>
  
    <li><a href="/categories/Debug/">Debug</a><small>7</small></li>
  
    <li><a href="/categories/Kernel/">Kernel</a><small>4</small></li>
  
    <li><a href="/categories/Learning/">Learning</a><small>8</small></li>
  
    <li><a href="/categories/Life/">Life</a><small>7</small></li>
  
    <li><a href="/categories/Others/">Others</a><small>1</small></li>
  
    <li><a href="/categories/Read-Notes/">Read Notes</a><small>7</small></li>
  
    <li><a href="/categories/Tools/">Tools</a><small>6</small></li>
  
    <li><a href="/categories/Vulnerabilities/">Vulnerabilities</a><small>0</small></li>
  
    <li><a href="/categories/Windows/">Windows</a><small>14</small></li>
  
    <li><a href="/categories/life/">life</a><small>0</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/07/01/Windows/delphi_reverse_summary/">Delphi程序逆向反汇编技巧小记</a>
      </li>
    
      <li>
        <a href="/2019/06/25/Kernel/kernel_enum_wfp_callout_function/">Windows内核重拾：如何枚举系统中Windows Filtering Platform (WFP)驱动中的callout函数</a>
      </li>
    
      <li>
        <a href="/2019/05/06/Kernel/windows-driver-testing-basics/">Windows内核重拾：Windows驱动测试基础：工具、功能和示例（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2019/04/06/Windows/how-to-reverse-engineer-software-windows-in-a-right-way/">如何正确的对Windows软件进行逆向工程（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2019/01/12/Windows/a_crash_lead_deadlock/">Windows平台下一个崩溃而导致的死锁分析</a>
      </li>
    
      <li>
        <a href="/2018/12/01/Windows/windows_client_dns_over_https/">Windows客户端如何透明使用DNS-over-HTTPS</a>
      </li>
    
      <li>
        <a href="/2018/10/06/Cybersecurity/ddos-protection-techniques/">现代DDoS对抗技术概述（翻译/转载）</a>
      </li>
    
      <li>
        <a href="/2018/09/18/Life/xian/">西安周末游</a>
      </li>
    
      <li>
        <a href="/2018/01/06/Kernel/WindowsKernel_DebugObject/">Windows内核重拾：DebugObject</a>
      </li>
    
      <li>
        <a href="/2017/10/23/Tools/IDA-Pro-ClassInformer-Tutorial/">IDA Pro ClassInformer使用指南（翻译）</a>
      </li>
    
      <li>
        <a href="/2017/05/23/Windows/Kernel Data and Filtering Support/">Kernel Data and Filtering Support for Windows Server 2008（翻译）</a>
      </li>
    
      <li>
        <a href="/2017/05/17/Windows/Windows-x64-Shellcode/">Windows x64 Shellcode编写指南(翻译)</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/ASM/" style="font-size: 12.5px;">ASM</a> <a href="/tags/Boost/" style="font-size: 10px;">Boost</a> <a href="/tags/DDoS/" style="font-size: 10px;">DDoS</a> <a href="/tags/DNS-over-HTTPS/" style="font-size: 10px;">DNS-over-HTTPS</a> <a href="/tags/Delphi/" style="font-size: 10px;">Delphi</a> <a href="/tags/Dll劫持/" style="font-size: 10px;">Dll劫持</a> <a href="/tags/GCC-GDB/" style="font-size: 10px;">GCC&GDB</a> <a href="/tags/GetVersionEx/" style="font-size: 10px;">GetVersionEx</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IDA-Pro/" style="font-size: 12.5px;">IDA Pro</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MSDN/" style="font-size: 12.5px;">MSDN</a> <a href="/tags/Malware/" style="font-size: 12.5px;">Malware</a> <a href="/tags/MiniDumpWriteDump/" style="font-size: 10px;">MiniDumpWriteDump</a> <a href="/tags/PEB/" style="font-size: 10px;">PEB</a> <a href="/tags/Procmon/" style="font-size: 10px;">Procmon</a> <a href="/tags/Runtime-Error/" style="font-size: 10px;">Runtime Error</a> <a href="/tags/SEH/" style="font-size: 10px;">SEH</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/SysinternalsSuite/" style="font-size: 10px;">SysinternalsSuite</a> <a href="/tags/Tips/" style="font-size: 10px;">Tips</a> <a href="/tags/UAC/" style="font-size: 10px;">UAC</a> <a href="/tags/UAF漏洞/" style="font-size: 10px;">UAF漏洞</a> <a href="/tags/VC/" style="font-size: 10px;">VC</a> <a href="/tags/Visual-Studio/" style="font-size: 12.5px;">Visual Studio</a> <a href="/tags/Windbg/" style="font-size: 10px;">Windbg</a> <a href="/tags/Windows/" style="font-size: 20px;">Windows</a> <a href="/tags/Windows核心编程/" style="font-size: 17.5px;">Windows核心编程</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/getaddrinfo/" style="font-size: 10px;">getaddrinfo</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/libeay32/" style="font-size: 10px;">libeay32</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/ndk/" style="font-size: 10px;">ndk</a> <a href="/tags/sublime-text3/" style="font-size: 10px;">sublime text3</a> <a href="/tags/x64/" style="font-size: 12.5px;">x64</a> <a href="/tags/体验/" style="font-size: 10px;">体验</a> <a href="/tags/内核/" style="font-size: 12.5px;">内核</a> <a href="/tags/内核结构/" style="font-size: 15px;">内核结构</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/安全机制/" style="font-size: 10px;">安全机制</a> <a href="/tags/异常处理/" style="font-size: 10px;">异常处理</a> <a href="/tags/提权/" style="font-size: 10px;">提权</a> <a href="/tags/服务/" style="font-size: 10px;">服务</a> <a href="/tags/权限/" style="font-size: 12.5px;">权限</a> <a href="/tags/栈溢出漏洞/" style="font-size: 10px;">栈溢出漏洞</a> <a href="/tags/测试/" style="font-size: 10px;">测试</a> <a href="/tags/浮躁/" style="font-size: 10px;">浮躁</a> <a href="/tags/漏洞调试/" style="font-size: 12.5px;">漏洞调试</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/脱壳/" style="font-size: 10px;">脱壳</a> <a href="/tags/西安/" style="font-size: 10px;">西安</a> <a href="/tags/计划/" style="font-size: 10px;">计划</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/调试/" style="font-size: 15px;">调试</a> <a href="/tags/转换/" style="font-size: 10px;">转换</a> <a href="/tags/进程/" style="font-size: 10px;">进程</a> <a href="/tags/逆向/" style="font-size: 10px;">逆向</a> <a href="/tags/重庆/" style="font-size: 10px;">重庆</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
<li><a href="http://blog.ourren.com/" title="Ourren">Ourren</a></li>
<li><a href="http://www.hyjal.net/" title="Hyjal">Hyjal</a></li>
<li><a href="http://www.jianshu.com/users/fa15f4e416ae/latest_articles" title="Daemonceltics">Daemonceltics</a></li>
<li><a href="http://papap.info/" title="isee">isee</a></li>
</ul>
</div>

  <script type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=putG&d=yoFnN6V-ovhL-H4e9_69LvkTiX4uX7rEYJ15yL3G1Wg"></script>
</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 Lyon
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>

</body>

</html>